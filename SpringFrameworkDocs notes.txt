Spring Framework Documentation Version 6.0.0

https://docs.spring.io/spring-framework/docs/6.0.0/reference/pdf/spring-framework.pdf

========================================================================================================================
Chapter 1. Spring Framework Overview

    Spring is open source. It has a large and active community that provides continuous feedback based
    on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very
    long time.

    Spring supports a wide range of application scenarios. In a large enterprise, applications often exist
    for a long time and have to run on a JDK and application server whose upgrade cycle is beyond
    developer control. Others may run as a single jar with the server embedded, possibly in a cloud
    environment. Yet others may be standalone applications (such as batch or integration workloads)
    that do not need a server

    1.1. What We Mean by "Spring"
        The term "Spring" means different things in different contexts. It can be used to refer to the Spring
        Framework project itself. Over time, other Spring projects have been
        built on top of the Spring Framework. Most often, when people say "Spring", they mean the entire
        family of projects.

        The Spring Framework is divided into modules. Applications can choose which modules they need.
        At the heart are the modules of the core container, including a configuration model and a
        dependency injection mechanism. Beyond that, the Spring Framework provides foundational
        support for different application architectures, including messaging, transactional data and
        persistence, and web. It also includes the Servlet-based Spring MVC web framework and, in
        parallel, the Spring WebFlux reactive web framework

    1.2. History of Spring and the Spring Framework
        Spring came into being in 2003 as a response to the complexity of the early J2EE specifications.
        While some consider Java EE and its modern-day successor Jakarta EE to be in competition with
        Spring, they are in fact complementary. The Spring programming model does not embrace the
        Jakarta EE platform specification; rather, it integrates with carefully selected individual
        specifications from the traditional EE umbrella:
            • Servlet API (JSR 340)
            • WebSocket API (JSR 356)
            • Concurrency Utilities (JSR 236)
            • JSON Binding API (JSR 367)
            • Bean Validation (JSR 303)
            • JPA (JSR 338)
            • JMS (JSR 914)
            • as well as JTA/JCA setups for transaction coordination, if necessary

        The Spring Framework also supports the Dependency Injection (JSR 330) and Common Annotations
        (JSR 250) specifications, which application developers may choose to use instead of the Spring specific
        mechanisms provided by the Spring Framework.

        As of Spring Framework 6.0, Spring has been upgraded to the Jakarta EE 9 level (e.g. Servlet 5.0+,
        JPA 3.0+), based on the jakarta namespace instead of the traditional javax packages. With EE 9 as
        the minimum and EE 10 supported already, Spring is prepared to provide out-of-the-box support
        for the further evolution of the Jakarta EE APIs. Spring Framework 6.0 is fully compatible with
        Tomcat 10.1, Jetty 11 and Undertow 2.3 as web servers, and also with Hibernate ORM 6.1

        Over time, the role of Java/Jakarta EE in application development has evolved. In the early days of
        J2EE and Spring, applications were created to be deployed to an application server. Today, with the
        help of Spring Boot, applications are created in a devops- and cloud-friendly way, with the Servlet
        container embedded and trivial to change. As of Spring Framework 5, a WebFlux application does
        not even use the Servlet API directly and can run on servers (such as Netty) that are not Servlet
        containers.

        Spring continues to innovate and to evolve. Beyond the Spring Framework, there are other projects,
        such as Spring Boot, Spring Security, Spring Data, Spring Cloud, Spring Batch, among others. It’s
        important to remember that each project has its own source code repository, issue tracker, and
        release cadence

    1.3. Design Philosophy
        When you learn about a framework, it’s important to know not only what it does but what
        principles it follows. Here are the guiding principles of the Spring Framework:
            • Provide choice at every level. Spring lets you defer design decisions as late as possible. For
            example, you can switch persistence providers through configuration without changing your
            code. The same is true for many other infrastructure concerns and integration with third-party
            APIs.
            • Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated about
            how things should be done. It supports a wide range of application needs with different
            perspectives.
            • Maintain strong backward compatibility. Spring’s evolution has been carefully managed to
            force few breaking changes between versions. Spring supports a carefully chosen range of JDK
            versions and third-party libraries to facilitate maintenance of applications and libraries that
            depend on Spring.
            • Care about API design. The Spring team puts a lot of thought and time into making APIs that are
            intuitive and that hold up across many versions and many years.
            • Set high standards for code quality. The Spring Framework puts a strong emphasis on
            meaningful, current, and accurate javadoc. It is one of very few projects that can claim clean
            code structure with no circular dependencies between packages

    1.5. Getting Started
        If you are just getting started with Spring, you may want to begin using the Spring Framework by
        creating a Spring Boot (https://projects.spring.io/spring-boot/)-based application. Spring Boot provides a quick (and opinionated) way to
        create a production-ready Spring-based application. It is based on the Spring Framework, favors
        convention over configuration, and is designed to get you up and running as quickly as possible.
        You can use start.spring.io to generate a basic project or follow one of the "Getting Started" guides,
        such as Getting Started Building a RESTful Web Service. As well as being easier to digest, these
        guides are very task focused, and most of them are based on Spring Boot. They also cover other
        projects from the Spring portfolio that you might want to consider when solving a particular
        problem


========================================================================================================================
Chapter 2. Core Technologies

Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough
treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage
of Spring’s Aspect-Oriented Programming (AOP) technologies

    2.1. The IoC Container

        2.1.1. Introduction to the Spring IoC Container and Beans
            This chapter covers the Spring Framework implementation of the Inversion of Control (IoC)
            principle. IoC is also known as dependency injection (DI). It is a process whereby objects define
            their dependencies (that is, the other objects they work with) only through constructor arguments,
            arguments to a factory method, or properties that are set on the object instance after it is
            constructed or returned from a factory method. The container then injects those dependencies
            when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of
            Control) of the bean itself controlling the instantiation or location of its dependencies by using
            direct construction of classes or a mechanism such as the Service Locator pattern.

            The org.springframework.beans and org.springframework.context packages are the basis for Spring
            Framework’s IoC container.
!!!!
            In Spring, the objects that form the backbone of your application and that are managed by the
            Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and
            managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your
            application. Beans, and the dependencies among them, are reflected in the configuration metadata
            used by a container.

        2.1.2. Container Overview
            The org.springframework.context.ApplicationContext interface represents the Spring IoC container
            and is responsible for instantiating, configuring, and assembling the beans. The container gets its
            instructions on what objects to instantiate, configure, and assemble by reading configuration
            metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets
            you express the objects that compose your application and the rich interdependencies between
            those objects

            Several implementations of the ApplicationContext interface are supplied with Spring. In standalone
            applications, it is common to create an instance of ClassPathXmlApplicationContext or
            FileSystemXmlApplicationContext. While XML has been the traditional format for defining
            configuration metadata, you can instruct the container to use Java annotations or code as the
            metadata

            In most application scenarios, explicit user code is not required to instantiate one or more
            instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or
            so) lines of boilerplate web descriptor XML in the web.xml file of the application typically suffices

            The following diagram shows a high-level view of how Spring works. Your application classes are
            combined with configuration metadata so that, after the ApplicationContext is created and
            initialized, you have a fully configured and executable system or application.

                business objects (POJOs) + configuration metadata => fully configured system ready for use

            This configuration metadata represents how you, as an application developer, tell the
            Spring container to instantiate, configure, and assemble the objects in your application.

            Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is
            what most of this chapter uses to convey key concepts and features of the Spring IoC container.
                (Dan : well...this sucks...i won't add XML examples, unless very important, as nowadays most people
                use Annotations...)

            For information about using other forms of metadata with the Spring container, see:
                • Annotation-based configuration: Spring 2.5 introduced support for annotation-based
                configuration metadata.
                • Java-based configuration: Starting with Spring 3.0, many features provided by the Spring
                JavaConfig project became part of the core Spring Framework. Thus, you can define beans
                external to your application classes by using Java rather than XML files. To use these new
                features, see the @Configuration, @Bean, @Import, and @DependsOn annotations.

            XML-based configuration metadata configures these beans as <bean/> elements inside a top-level <beans/>
            element. Java configuration typically uses @Bean-annotated methods within a @Configuration class.

            These bean definitions correspond to the actual objects that make up your application. Typically,
            you define service layer objects, data access objects (DAOs), presentation objects such as Struts
            Action instances, infrastructure objects such as Hibernate SessionFactories, JMS Queues, and so
            forth. Typically, one does not configure fine-grained domain objects in the container, because it is
            usually the responsibility of DAOs and business logic to create and load domain objects

            Instantiating a Container
            The location path or paths supplied to an ApplicationContext constructor are resource strings that
            let the container load configuration metadata from a variety of external resources, such as the local
            file system, the Java CLASSPATH, and so on.

                ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

            Composing XML-based Configuration Metadata
            It can be useful to have bean definitions span multiple XML files. Often, each individual XML
            configuration file represents a logical layer or module in your architecture

            Using the Container
            The ApplicationContext is the interface for an advanced factory capable of maintaining a registry of
            different beans and their dependencies. By using the method T getBean(String name, Class<T>
            requiredType), you can retrieve instances of your beans

            You can then use getBean to retrieve instances of your beans. The ApplicationContext interface has a
            few other methods for retrieving beans, but, ideally, your application code should never use them.
            Indeed, your application code should have no calls to the getBean() method at all and thus have no
            dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides
            dependency injection for various web framework components such as controllers and JSF-managed
            beans, letting you declare a dependency on a specific bean through metadata (such as an
            autowiring annotation).

        2.1.3. Bean Overview
            A Spring IoC container manages one or more beans. These beans are created with the configuration
            metadata that you supply to the container (for example, in the form of XML <bean/> definitions).
            Within the container itself, these bean definitions are represented as BeanDefinition objects, which
            contain (among other information) the following metadata:
                • A package-qualified class name: typically, the actual implementation class of the bean
                • Bean behavioral configuration elements, which state how the bean should behave in the
                container (scope, lifecycle callbacks, and so forth).
                • References to other beans that are needed for the bean to do its work. These references are also
                called collaborators or dependencies.
                • Other configuration settings to set in the newly created object — for example, the size limit of
                the pool or the number of connections to use in a bean that manages a connection pool.

            ApplicationContext implementations also permit the registration of existing objects that are created
            outside the container (by users). This is done by accessing the ApplicationContext’s BeanFactory
            through the getBeanFactory() method, which returns the DefaultListableBeanFactory
            implementation. DefaultListableBeanFactory supports this registration through the
            registerSingleton(..) and registerBeanDefinition(..) methods. However, typical applications
            work solely with beans defined through regular bean definition metadata.
!!!
            While overriding existing metadata and existing singleton instances is supported to some degree, the
            registration of new beans at runtime (concurrently with live access to the factory) is not officially
            supported and may lead to concurrent access exceptions, inconsistent state in the
            bean container, or both.

            Naming Beans
            Every bean has one or more identifiers. These identifiers must be unique within the container that
            hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the
            extra ones can be considered aliases.

            In XML-based configuration metadata, you use the id attribute, the name attribute, or both to specify
             the bean identifiers. The id attribute lets you specify exactly one id. Conventionally, these names
             are alphanumeric ('myBean', 'someService', etc.), but they can contain special characters as well. If
             you want to introduce other aliases for the bean, you can also specify them in the name attribute,
             separated by a comma (,), semicolon (;), or white space.

            You are not required to supply a name or an id for a bean. If you do not supply a name or id explicitly,
            the container generates a unique name for that bean. However, if you want to refer to that bean by
            name, through the use of the ref element or a Service Locator style lookup, you must provide a name.

                Bean Naming Conventions
                The convention is to use the standard Java convention for instance field names when naming
                beans. That is, bean names start with a lowercase letter and are camel-cased from there.
                Examples of such names include accountManager, accountService, userDao, loginController, and
                so forth.

            Aliasing a Bean outside the Bean Definition
            In a bean definition itself, you can supply more than one name for the bean, by using a
            combination of up to one name specified by the id attribute and any number of other names in the
            name attribute. These names can be equivalent aliases to the same bean and are useful for some
            situations, such as letting each component in an application refer to a common dependency by
            using a bean name that is specific to that component itself.
            In XML-based configuration metadata, you can use the <alias/> element to accomplish this

            For example, the configuration metadata for subsystem A may refer to a DataSource by the name of
            subsystemA-dataSource. The configuration metadata for subsystem B may refer to a DataSource by
            the name of subsystemB-dataSource. When composing the main application that uses both these
            subsystems, the main application refers to the DataSource by the name of myApp-dataSource. To have
            all three names refer to the same object, you can add the following alias definitions to the
            configuration metadata:
                <alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
                <alias name="myApp-dataSource" alias="subsystemB-dataSource"/>

            If you use Java configuration, the @Bean annotation can be used to provide aliases. See Using
            the @Bean Annotation for details.

            Instantiating Beans
            A bean definition is essentially a recipe for creating one or more objects. The container looks at the
            recipe for a named bean when asked and uses the configuration metadata encapsulated by that
            bean definition to create (or acquire) an actual object.

            You can use the Class property in one of two ways:
            • Typically, to specify the bean class to be constructed in the case where the container itself
            directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java
            code with the new operator.
            • To specify the actual class containing the static factory method that is invoked to create the
            object, in the less common case where the container invokes a static factory method on a class
            to create the bean. The object type returned from the invocation of the static factory method
            may be the same class or another class entirely.

            Instantiation with a Constructor
            When you create a bean by the constructor approach, all normal classes are usable by and
            compatible with Spring. That is, the class being developed does not need to implement any specific
            interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice.
            However, depending on what type of IoC you use for that specific bean, you may need a default
            (empty) constructor.

            The Spring IoC container can manage virtually any class you want it to manage. It is not limited to
            managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (noargument) constructor and appropriate setters and getters modeled after the properties in the
            container. You can also have more exotic non-bean-style classes in your container. If, for example,
            you need to use a legacy connection pool that absolutely does not adhere to the JavaBean
            specification, Spring can manage it as well.

            Instantiation with a Static Factory Method
            When defining a bean that you create with a static factory method, use the class attribute to specify
            the class that contains the static factory method and an attribute named factory-method to specify
            the name of the factory method itself. You should be able to call this method (with optional
            arguments, as described later) and return a live object, which subsequently is treated as if it had
            been created through a constructor. One use for such a bean definition is to call static factories in
            legacy code

            In Spring documentation, "factory bean" refers to a bean that is configured in the
            Spring container and that creates objects through an instance or static factory
            method. By contrast, FactoryBean (notice the capitalization) refers to a Spring specific FactoryBean implementation class.

        2.1.4. Dependencies
            A typical enterprise application does not consist of a single object (or bean in the Spring parlance).
            Even the simplest application has a few objects that work together to present what the end-user
            sees as a coherent application. This next section explains how you go from defining a number of
            bean definitions that stand alone to a fully realized application where objects collaborate to achieve
            a goal.

!!!         Dependency Injection
            Dependency injection (DI) is a process whereby objects define their dependencies (that is, the other
            objects with which they work) only through constructor arguments, arguments to a factory method,
            or properties that are set on the object instance after it is constructed or returned from a factory
            method. The container then injects those dependencies when it creates the bean. This process is
            fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the
            instantiation or location of its dependencies on its own by using direct construction of classes or the
            Service Locator pattern.

            Code is cleaner with the DI principle, and decoupling is more effective when objects are provided
            with their dependencies. The object does not look up its dependencies and does not know the
            location or class of the dependencies. As a result, your classes become easier to test, particularly
            when the dependencies are on interfaces or abstract base classes, which allow for stub or mock
            implementations to be used in unit tests

            DI exists in two major variants: Constructor-based dependency injection and Setter-based
            dependency injection.

            Constructor-based Dependency Injection
            Constructor-based DI is accomplished by the container invoking a constructor with a number of
            arguments, each representing a dependency. Calling a static factory method with specific
            arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a
            constructor and to a static factory method similarly.

            Constructor Argument Resolution
            Constructor argument resolution matching occurs by using the argument’s type. If no potential
            ambiguity exists in the constructor arguments of a bean definition, the order in which the
            constructor arguments are defined in a bean definition is the order in which those arguments are
            supplied to the appropriate constructor when the bean is being instantiated

            Setter-based Dependency Injection
            Setter-based DI is accomplished by the container calling setter methods on your beans after
            invoking a no-argument constructor or a no-argument static factory method to instantiate your bean.

            The ApplicationContext supports constructor-based and setter-based DI for the beans it manages. It
            also supports setter-based DI after some dependencies have already been injected through the
            constructor approach. You configure the dependencies in the form of a BeanDefinition, which you
            use in conjunction with PropertyEditor instances to convert properties from one format to another.
            However, most Spring users do not work with these classes directly (that is, programmatically) but
            rather with XML bean definitions, annotated components (that is, classes annotated with @Component,
            @Controller, and so forth), or @Bean methods in Java-based @Configuration classes

!!!!        The Spring team generally advocates constructor injection, as it lets you implement
            application components as immutable objects and ensures that required dependencies are
            not null. Furthermore, constructor-injected components are always returned to the client
            (calling) code in a fully initialized state. As a side note, a large number of constructor
            arguments is a bad code smell, implying that the class likely has too many responsibilities and
            should be refactored to better address proper separation of concerns.

!!          Setter injection should primarily only be used for optional dependencies that can be assigned
            reasonable default values within the class. Otherwise, not-null checks must be performed
            everywhere the code uses the dependency. One benefit of setter injection is that setter
            methods make objects of that class amenable to reconfiguration or re-injection later.
            Management through JMX MBeans is therefore a compelling use case for setter injection.

            Use the DI style that makes the most sense for a particular class. Sometimes, when dealing
            with third-party classes for which you do not have the source, the choice is made for you. For
            example, if a third-party class does not expose any setter methods, then constructor injection
            may be the only available form of DI.

!!!         Dependency Resolution Process
            The container performs bean dependency resolution as follows:
            • The ApplicationContext is created and initialized with configuration metadata that describes all
            the beans. Configuration metadata can be specified by XML, Java code, or annotations.
            • For each bean, its dependencies are expressed in the form of properties, constructor arguments,
            or arguments to the static-factory method (if you use that instead of a normal constructor).
            These dependencies are provided to the bean, when the bean is actually created.
            • Each property or constructor argument is an actual definition of the value to set, or a reference
            to another bean in the container.
            • Each property or constructor argument that is a value is converted from its specified format to
            the actual type of that property or constructor argument. By default, Spring can convert a value
            supplied in string format to all built-in types, such as int, long, String, boolean, and so forth.
            The Spring container validates the configuration of each bean as the container is created. However,
            the bean properties themselves are not set until the bean is actually created. Beans that are
            singleton-scoped and set to be pre-instantiated (the default) are created when the container is
            created. Scopes are defined in Bean Scopes. Otherwise, the bean is created only when it is
            requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s
            dependencies and its dependencies' dependencies (and so on) are created and assigned.

            Circular dependencies
            If you configure beans for
            classes A and B to be injected into each other, the Spring IoC container detects this circular
            reference at runtime, and throws a BeanCurrentlyInCreationException.
            One possible solution is to edit the source code of some classes to be configured by setters
            rather than constructors. Alternatively, avoid constructor injection and use setter injection
            only. In other words, although it is not recommended, you can configure circular
            dependencies with setter injection.
            Unlike the typical case (with no circular dependencies), a circular dependency between bean
            A and bean B forces one of the beans to be injected into the other prior to being fully
            initialized itself (a classic chicken-and-egg scenario).

            You can generally trust Spring to do the right thing. It detects configuration problems, such as
            references to non-existent beans and circular dependencies, at container load-time. Spring sets
            properties and resolves dependencies as late as possible, when the bean is actually created. This
            means that a Spring container that has loaded correctly can later generate an exception when you
            request an object if there is a problem creating that object or one of its dependencies — for
            example, the bean throws an exception as a result of a missing or invalid property. This potentially
            delayed visibility of some configuration issues is why ApplicationContext implementations by
            default pre-instantiate singleton beans. At the cost of some upfront time and memory to create
            these beans before they are actually needed, you discover configuration issues when the
            ApplicationContext is created, not later. You can still override this default behavior so that singleton
            beans initialize lazily, rather than being eagerly pre-instantiated.

            Strongly-typed collection
            Thanks to Java’s support for generic types, you can use strongly typed collections. That is, it is
            possible to declare a Collection type such that it can only contain (for example) String elements. If
            you use Spring to dependency-inject a strongly-typed Collection into a bean, you can take
            advantage of Spring’s type-conversion support such that the elements of your strongly-typed
            Collection instances are converted to the appropriate type prior to being added to the Collection

            Null and Empty String Values
            Spring treats empty arguments for properties and the like as empty Strings.
            The <null/> element handles null values.        (Dan: this is for XML based configurations)

!!          Lazy-initialized Beans
            By default, ApplicationContext implementations eagerly create and configure all singleton beans as
            part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the
            configuration or surrounding environment are discovered immediately, as opposed to hours or
            even days later. When this behavior is not desirable, you can prevent pre-instantiation of a
            singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells
            the IoC container to create a bean instance when it is first requested, rather than at startup.

            However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazyinitialized, the
            ApplicationContext creates the lazy-initialized bean at startup, because it must
            satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean
            elsewhere that is not lazy-initialized.

            Autowiring Collaborators
            The Spring container can autowire relationships between collaborating beans. You can let Spring
            resolve collaborators (other beans) automatically for your bean by inspecting the contents of the
            ApplicationContext. Autowiring has the following advantages:
                • Autowiring can significantly reduce the need to specify properties or constructor arguments.
                (Other mechanisms such as a bean template discussed elsewhere in this chapter are also
                valuable in this regard.)
                • Autowiring can update a configuration as your objects evolve. For example, if you need to add a
                dependency to a class, that dependency can be satisfied automatically without you needing to
                modify the configuration. Thus autowiring can be especially useful during development,
                without negating the option of switching to explicit wiring when the code base becomes more
                stable.

            The following table describes the four autowiring modes:
                no -> (Default) No autowiring. Bean references must be defined by ref elements.
                Changing the default setting is not recommended for larger deployments,
                because specifying collaborators explicitly gives greater control and clarity. To
                some extent, it documents the structure of a system.

                byName -> Autowiring by property name. Spring looks for a bean with the same name as
                the property that needs to be autowired. For example, if a bean definition is
                set to autowire by name and it contains a master property (that is, it has a
                setMaster(..) method), Spring looks for a bean definition named master and
                uses it to set the property.

                byType -> Lets a property be autowired if exactly one bean of the property type exists in
                the container. If more than one exists, a fatal exception is thrown, which
                indicates that you may not use byType autowiring for that bean. If there are no
                matching beans, nothing happens (the property is not set).

                constructor ->  Analogous to byType but applies to constructor arguments. If there is not
                exactly one bean of the constructor argument type in the container, a fatal
                error is raised.

            Consider the limitations and disadvantages of autowiring:
                • Explicit dependencies in property and constructor-arg settings always override autowiring. You
                cannot autowire simple properties such as primitives, Strings, and Classes (and arrays of such
                simple properties). This limitation is by-design.
                • Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is
                careful to avoid guessing in case of ambiguity that might have unexpected results. The
                relationships between your Spring-managed objects are no longer documented explicitly.
                • Wiring information may not be available to tools that may generate documentation from a
                Spring container.
                • Multiple bean definitions within the container may match the type specified by the setter
                method or constructor argument to be autowired. For arrays, collections, or Map instances, this is
                not necessarily a problem. However, for dependencies that expect a single value, this ambiguity
                is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.

            Method Injection
            In most application scenarios, most beans in the container are singletons. When a singleton bean
            needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with
            another non-singleton bean, you typically handle the dependency by defining one bean as a
            property of the other. A problem arises when the bean lifecycles are different. Suppose singleton
            bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A.
            The container creates the singleton bean A only once, and thus only gets one opportunity to set the
            properties. The container cannot provide bean A with a new instance of bean B every time one is
            needed.
            A solution is to forego some inversion of control. You can make bean A aware of the container by
            implementing the ApplicationContextAware interface, and by making a getBean("B") call to the
            container ask for (a typically new) bean B instance every time bean A needs it

            Lookup Method Injection
            Lookup method injection is the ability of the container to override methods on container-managed
            beans and return the lookup result for another named bean in the container. The lookup typically
            involves a prototype bean, as in the scenario described in the preceding section. The Spring
            Framework implements this method injection by using bytecode generation from the CGLIB library
            to dynamically generate a subclass that overrides the method.

            Alternatively, within the annotation-based component model, you can declare a lookup method
            through the @Lookup annotation, as the following example shows:

                (Dan: A method annotated with @Lookup tells Spring to return an instance of the method's return type
                        when we invoke it. Essentially, Spring will override our annotated method and use our method's
                        return type and parameters as arguments to BeanFactory#getBean.

                      @Lookup is useful for:
                        Injecting a prototype-scoped bean into a singleton bean (similar to Provider)
                        Injecting dependencies procedurally)

            Arbitrary Method Replacement
            A less useful form of method injection than lookup method injection is the ability to replace
            arbitrary methods in a managed bean with another method implementation. You can safely skip
            the rest of this section until you actually need this functionality


        2.1.5. Bean Scopes
            When you create a bean definition, you create a recipe for creating actual instances of the class
            defined by that bean definition. The idea that a bean definition is a recipe is important, because it
            means that, as with a class, you can create many object instances from a single recipe.

!!!!        Beans can be defined to be deployed in one of a number of scopes. The Spring Framework supports
            six scopes, four of which are available only if you use a web-aware ApplicationContext. You can also
            create a custom scope.

!!!!        The following table describes the supported scopes:
            Scope                   Description
            singleton               (Default) Scopes a single bean definition to a single object instance for each
                                    Spring IoC container.
            prototype               Scopes a single bean definition to any number of object instances
                                (Dan:  A new object is created each time it is injected/looked up)
            request                 Scopes a single bean definition to the lifecycle of a single HTTP request. That
                                    is, each HTTP request has its own instance of a bean created off the back of a
                                    single bean definition. Only valid in the context of a web-aware Spring
                                    ApplicationContext.
            session                 Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid
                                    in the context of a web-aware Spring ApplicationContext.
            application             Scopes a single bean definition to the lifecycle of a ServletContext. Only valid
                                    in the context of a web-aware Spring ApplicationContext.
            websocket               Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the
                                    context of a web-aware Spring ApplicationContext.

!!!         The Singleton Scope
            Only one shared instance of a singleton bean is managed, and all requests for beans with an ID or
            IDs that match that bean definition result in that one specific bean instance being returned by the
            Spring container.
            To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring
            IoC container creates exactly one instance of the object defined by that bean definition. This single
            instance is stored in a cache of such singleton beans, and all subsequent requests and references
            for that named bean return the cached object.

            Spring’s concept of a singleton bean differs from the singleton pattern as defined in the Gang of
            Four (GoF) patterns book. The GoF singleton hard-codes the scope of an object such that one and
            only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton
            is best described as being per-container and per-bean. This means that, if you define one bean for a
            particular class in a single Spring container, the Spring container creates one and only one instance
            of the class defined by that bean definition.

!!!!!!      The singleton scope is the default scope in Spring.

            The Prototype Scope
            The non-singleton prototype scope of bean deployment results in the creation of a new bean
            instance every time a request for that specific bean is made. That is, the bean is injected into
            another bean or you request it through a getBean() method call on the container.

!!!!!!      As a rule, you should use the prototype scope for all stateful beans and the singleton scope for
            stateless beans.

!!!!        In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean
            The container instantiates, configures, and otherwise assembles a prototype object and hands it to
            the client, with no further record of that prototype instance. Thus, although initialization lifecycle
            callback methods are called on all objects regardless of scope, in the case of prototypes, configured
            destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped
            objects and release expensive resources that the prototype beans hold. To get the Spring container
            to release resources held by prototype-scoped beans, try using a custom bean post-processor, which
            holds a reference to beans that need to be cleaned up.

            Singleton Beans with Prototype-bean Dependencies
            When you use singleton-scoped beans with dependencies on prototype beans, be aware that
            dependencies are resolved at instantiation time. Thus, if you dependency-inject a prototype-scoped
            bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency injected into
            the singleton bean. The prototype instance is the sole instance that is ever supplied to
            the singleton-scoped bean.
            However, suppose you want the singleton-scoped bean to acquire a new instance of the prototypescoped bean
            repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into
            your singleton bean, because that injection occurs only once, when the Spring container
            instantiates the singleton bean and resolves and injects its dependencies. If you need a new
            instance of a prototype bean at runtime more than once, see Method Injection.

            Request, Session, Application, and WebSocket Scopes
            The request, session, application, and websocket scopes are available only if you use a web-aware
            Spring ApplicationContext implementation (such as XmlWebApplicationContext). If you use these
            scopes with regular Spring IoC containers, such as the ClassPathXmlApplicationContext, an
            IllegalStateException that complains about an unknown bean scope is thrown.

            Initial Web Configuration
            To support the scoping of beans at the request, session, application, and websocket levels
            (webscoped beans), some minor initial configuration is required before you define your beans. (This
            initial setup is not required for the standard scopes: singleton and prototype.)
            How you accomplish this initial setup depends on your particular Servlet environment.
            If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by
            the Spring DispatcherServlet, no special setup is necessary. DispatcherServlet already exposes all
            relevant state.
            If you use a Servlet web container, with requests processed outside of Spring’s DispatcherServlet
            (for example, when using JSF or Struts), you need to register the
            org.springframework.web.context.request.RequestContextListener ServletRequestListener. This can
            be done programmatically by using the WebApplicationInitializer interface. Alternatively, add the
            following declaration to your web application’s web.xml file:
                <web-app>
                  ...
                  <listener>
                    <listener-class>
                        org.springframework.web.context.request.RequestContextListener
                    </listener-class>
                  </listener>
                  ...
                </web-app>

            Alternatively, if there are issues with your listener setup, consider using Spring’s
            RequestContextFilter. The filter mapping depends on the surrounding web application
            configuration, so you have to change it as appropriate. The following listing shows the filter part of
            a web application:
                <web-app>
                  ...
                  <filter>
                    <filter-name>requestContextFilter</filter-name>
                    <filter-class>org.springframework.web.filter.RequestContextFilter</filterclass>
                  </filter>
                  <filter-mapping>
                    <filter-name>requestContextFilter</filter-name>
                    <url-pattern>/*</url-pattern>
                  </filter-mapping>
                  ...
                </web-app>

!!!!!!!!    DispatcherServlet, RequestContextListener, and RequestContextFilter all do exactly the same thing,
            namely bind the HTTP request object to the Thread that is servicing that request. This makes beans
            that are request- and session-scoped available further down the call chain

            Request scope
            Consider the following XML configuration for a bean definition:
            <bean id="loginAction" class="com.something.LoginAction" scope="request"/>
            The Spring container creates a new instance of the LoginAction bean by using the loginAction bean
            definition for each and every HTTP request. That is, the loginAction bean is scoped at the HTTP
            request level. You can change the internal state of the instance that is created as much as you want,
            because other instances created from the same loginAction bean definition do not see these
            changes in state. They are particular to an individual request.
!!!         When the request completes processing, the bean that is scoped to the request is discarded

!!!         When using annotation-driven components or Java configuration, the @RequestScope annotation can
            be used to assign a component to the request scope.

            Session Scope
            Consider the following XML configuration for a bean definition:
            <bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
            The Spring container creates a new instance of the UserPreferences bean by using the
            userPreferences bean definition for the lifetime of a single HTTP Session. In other words, the
            userPreferences bean is effectively scoped at the HTTP Session level. As with request-scoped beans,
            you can change the internal state of the instance that is created as much as you want, knowing that
            other HTTP Session instances that are also using instances created from the same userPreferences
            bean definition do not see these changes in state, because they are particular to an individual HTTP
            Session.
!!!!        When the HTTP Session is eventually discarded, the bean that is scoped to that particular HTTP Session is
            also discarded.

!!!         When using annotation-driven components or Java configuration, you can use the @SessionScope
            annotation to assign a component to the session scope

            Application Scope
            Consider the following XML configuration for a bean definition:
            <bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
            The Spring container creates a new instance of the AppPreferences bean by using the appPreferences
            bean definition once for the entire web application. That is, the appPreferences bean is scoped at the
            ServletContext level and stored as a regular ServletContext attribute.

!!          This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton
            per ServletContext, not per Spring ApplicationContext (for which there may be several in any given web
            application), and it is actually exposed and therefore visible as a ServletContext attribute.

!!!         When using annotation-driven components or Java configuration, you can use the
            @ApplicationScope annotation to assign a component to the application scope.


!!!!!       Scoped Beans as Dependencies
            The Spring IoC container manages not only the instantiation of your objects (beans), but also the
            wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request scoped
            bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in
            place of the scoped bean. That is, you need to inject a proxy object that exposes the same public
            interface as the scoped object but that can also retrieve the real target object from the relevant
            scope (such as an HTTP request) and delegate method calls onto the real object.

                  <!-- an HTTP Session-scoped bean exposed as a proxy -->
                  <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
                    <!-- instructs the container to proxy the surrounding bean -->
                    <aop:scoped-proxy/> ①
                  </bean>
                  <!-- a singleton-scoped bean injected with a proxy to the above bean -->
                  <bean id="userService" class="com.something.SimpleUserService">
                    <!-- a reference to the proxied userPreferences bean -->
                    <property name="userPreferences" ref="userPreferences"/>
                  </bean>

            To create such a proxy, you insert a child <aop:scoped-proxy/> element into a scoped bean definition. Why do
            definitions of beans scoped at the request, session and custom-scope levels require the <aop:scopedproxy/>
            element? Consider the following singleton bean definition and contrast it with what you
            need to define for the aforementioned scopes (note that the following userPreferences bean
            definition as it stands is incomplete):
                <bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
                <bean id="userManager" class="com.something.UserManager">
                  <property name="userPreferences" ref="userPreferences"/>
                </bean>

!!!         In the preceding example, the singleton bean (userManager) is injected with a reference to the HTTP
            Session-scoped bean (userPreferences). The salient point here is that the userManager bean is a
            singleton: it is instantiated exactly once per container, and its dependencies (in this case only one,
            the userPreferences bean) are also injected only once. This means that the userManager bean
            operates only on the exact same userPreferences object (that is, the one with which it was originally
            injected).

            This is not the behavior you want when injecting a shorter-lived scoped bean into a longer-lived
            scoped bean (for example, injecting an HTTP Session-scoped collaborating bean as a dependency
            into singleton bean). Rather, you need a single userManager object, and, for the lifetime of an HTTP
            Session, you need a userPreferences object that is specific to the HTTP Session. Thus, the container
            creates an object that exposes the exact same public interface as the UserPreferences class (ideally
            an object that is a UserPreferences instance), which can fetch the real UserPreferences object from
            the scoping mechanism (HTTP request, Session, and so forth). The container injects this proxy
            object into the userManager bean, which is unaware that this UserPreferences reference is a proxy. In
            this example, when a UserManager instance invokes a method on the dependency-injected
            UserPreferences object, it is actually invoking a method on the proxy. The proxy then fetches the
            real UserPreferences object from (in this case) the HTTP Session and delegates the method
            invocation onto the retrieved real UserPreferences object.

            Thus, you need the following (correct and complete) configuration when injecting request- and
            session-scoped beans into collaborating objects, as the following example shows:
                <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
                  <aop:scoped-proxy/>
                </bean>
                <bean id="userManager" class="com.something.UserManager">
                  <property name="userPreferences" ref="userPreferences"/>
                </bean>


            Choosing the Type of Proxy to Create
            By default, when the Spring container creates a proxy for a bean that is marked up with the
            <aop:scoped-proxy/> element, a CGLIB-based class proxy is created.

            CGLIB proxies intercept only public method calls! Do not call non-public methods
            on such a proxy. They are not delegated to the actual scoped target object

!!          Custom Scopes
            The bean scoping mechanism is extensible. You can define your own scopes or even redefine
            existing scopes, although the latter is considered bad practice and you cannot override the built-in
            singleton and prototype scopes.

            Creating a Custom Scope
!!          To integrate your custom scopes into the Spring container, you need to implement the
            org.springframework.beans.factory.config.Scope interface, which is described in this section. For an
            idea of how to implement your own scopes, see the Scope implementations that are supplied with
            the Spring Framework itself and the Scope javadoc, which explains the methods you need to
            implement in more detail

                (Dan: i did not add here more details about the subject, as this is not something that one comes across often)


        2.1.6. Customizing the Nature of a Bean
            The Spring Framework provides a number of interfaces you can use to customize the nature of a
            bean. This section groups them as follows:
                • Lifecycle Callbacks
                • ApplicationContextAware and BeanNameAware
                • Other Aware Interfaces

            Lifecycle Callbacks
    !!!!    To interact with the container’s management of the bean lifecycle, you can implement the Spring
            InitializingBean and DisposableBean interfaces. The container calls afterPropertiesSet() for the
            former and destroy() for the latter to let the bean perform certain actions upon initialization and
            destruction of your beans.

                The JSR-250 @PostConstruct and @PreDestroy annotations are generally considered
                best practice for receiving lifecycle callbacks in a modern Spring application. Using
                these annotations means that your beans are not coupled to Spring-specific
                interfaces. For details, see Using @PostConstruct and @PreDestroy.
                If you do not want to use the JSR-250 annotations but you still want to remove
                coupling, consider init-method and destroy-method bean definition metadata.

            Internally, the Spring Framework uses BeanPostProcessor implementations to process any callback
            interfaces it can find and call the appropriate methods. If you need custom features or other
            lifecycle behavior Spring does not by default offer, you can implement a BeanPostProcessor yourself

            In addition to the initialization and destruction callbacks, Spring-managed objects may also
            implement the Lifecycle interface so that those objects can participate in the startup and shutdown
            process, as driven by the container’s own lifecycle.

    !!!     We recommend that you do not use the InitializingBean interface, because it unnecessarily couples
            the code to Spring. Alternatively, we suggest using the @PostConstruct annotation or specifying a
            POJO initialization method. In the case of XML-based configuration metadata, you can use the initmethod
            attribute to specify the name of the method that has a void no-argument signature. With
            Java configuration, you can use the initMethod attribute of @Bean

            Consider the following example:
                <bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
                Java
                public class ExampleBean {
                  public void init() {
                  // do some initialization work
                  }
                }

            The preceding example has almost exactly the same effect as the following example (which consists of two listings):
                <bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
                Java
                public class AnotherExampleBean implements InitializingBean {
                  @Override
                  public void afterPropertiesSet() {
                  // do some initialization work
                  }
                }

    !!      However, the first of the two preceding examples does not couple the code to Spring.

            We recommend that you do not use the DisposableBean callback interface, because it unnecessarily
            couples the code to Spring. Alternatively, we suggest using the @PreDestroy annotation or specifying
            a generic method that is supported by bean definitions. With XML-based configuration metadata,
            you can use the destroy-method attribute on the <bean/>. With Java configuration, you can use the
            destroyMethod attribute of @Bean.

            You can assign the destroy-method attribute of a <bean> element a special (inferred)
            value, which instructs Spring to automatically detect a public close or shutdown
            method on the specific bean class. (Any class that implements
            java.lang.AutoCloseable or java.io.Closeable would therefore match.) You can
            also set this special (inferred) value on the default-destroy-method attribute of a
            <beans> element to apply this behavior to an entire set of beans (see Default
            Initialization and Destroy Methods). Note that this is the default behavior with Java configuration.

            Default Initialization and Destroy Methods
    !!!!    When you write initialization and destroy method callbacks that do not use the Spring-specific
            InitializingBean and DisposableBean callback interfaces, you typically write methods with names
            such as init(), initialize(), dispose(), and so on. Ideally, the names of such lifecycle callback
            methods are standardized across a project so that all developers use the same method names and
            ensure consistency. You can configure the Spring container to “look” for named initialization and destroy
            callback method names on every bean. This means that you, as an application developer, can write your
            application classes and use an initialization callback called init(), without having to configure an
            init-method="init" attribute with each bean definition. The Spring IoC container calls that method
            when the bean is created (and in accordance with the standard lifecycle callback contract described
            previously). This feature also enforces a consistent naming convention for initialization and destroy
            method callbacks.
            Suppose that your initialization callback methods are named init() and your destroy callback
            methods are named destroy(). Your class then resembles the class in the following example:

                public class DefaultBlogService implements BlogService {
                  private BlogDao blogDao;
                  public void setBlogDao(BlogDao blogDao) {
                    this.blogDao = blogDao;
                  }
                  // this is (unsurprisingly) the initialization callback method
                  public void init() {
                    if (this.blogDao == null) {
                        throw new IllegalStateException("The [blogDao] property must be set.");
                    }
                  }
                }

                <beans default-init-method="init">
                  <bean id="blogService" class="com.something.DefaultBlogService">
                  <property name="blogDao" ref="blogDao" />
                  </bean>
                </beans>

            The presence of the default-init-method attribute on the top-level <beans/> element attribute causes
            the Spring IoC container to recognize a method called init on the bean class as the initialization
            method callback. When a bean is created and assembled, if the bean class has such a method, it is
            invoked at the appropriate time.
            You can configure destroy method callbacks similarly (in XML, that is) by using the defaultdestroy-method
            attribute on the top-level <beans/> element.

            The Spring container guarantees that a configured initialization callback is called immediately after
            a bean is supplied with all dependencies. Thus, the initialization callback is called on the raw bean
            reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target
            bean is fully created first and then an AOP proxy (for example) with its interceptor chain is applied.
            If the target bean and the proxy are defined separately, your code can even interact with the raw
            target bean, bypassing the proxy. Hence, it would be inconsistent to apply the interceptors to the
            init method, because doing so would couple the lifecycle of the target bean to its proxy or
            interceptors and leave strange semantics when your code interacts directly with the raw target
            bean.

            Combining Lifecycle Mechanisms
            As of Spring 2.5, you have three options for controlling bean lifecycle behavior:
                • The InitializingBean and DisposableBean callback interfaces
                • Custom init() and destroy() methods
                • The @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control
                a given bean

            Multiple lifecycle mechanisms configured for the same bean, with different initialization methods,
            are called as follows:
                1. Methods annotated with @PostConstruct
                2. afterPropertiesSet() as defined by the InitializingBean callback interface
                3. A custom configured init() method
            Destroy methods are called in the same order:
                1. Methods annotated with @PreDestroy
                2. destroy() as defined by the DisposableBean callback interface
                3. A custom configured destroy() method

            Startup and Shutdown Callbacks
            The Lifecycle interface defines the essential methods for any object that has its own lifecycle
            requirements (such as starting and stopping some background process):
                public interface Lifecycle {
                  void start();
                  void stop();
                  boolean isRunning();
                }

            Any Spring-managed object may implement the Lifecycle interface. Then, when the
            ApplicationContext itself receives start and stop signals (for example, for a stop/restart scenario at
            runtime), it cascades those calls to all Lifecycle implementations defined within that context.

            The order of startup and shutdown invocations can be important. If a “depends-on” relationship
            exists between any two objects, the dependent side starts after its dependency, and it stops before
            its dependency. However, at times, the direct dependencies are unknown. You may only know that
            objects of a certain type should start prior to objects of another type. In those cases, the
            SmartLifecycle interface defines another option, namely the getPhase() method as defined on its
            super-interface, Phased.

            When starting, the objects with the lowest phase start first. When stopping, the reverse order is
            followed. Therefore, an object that implements SmartLifecycle and whose getPhase() method
            returns Integer.MIN_VALUE would be among the first to start and the last to stop. At the other end of
            the spectrum, a phase value of Integer.MAX_VALUE would indicate that the object should be started
            last and stopped first (likely because it depends on other processes to be running). When
            considering the phase value, it is also important to know that the default phase for any “normal”
            Lifecycle object that does not implement SmartLifecycle is 0.


            Shutting Down the Spring IoC Container Gracefully in Non-Web Applications
    !!!!    This section applies only to non-web applications. Spring’s web-based
            ApplicationContext implementations already have code in place to gracefully shut
            down the Spring IoC container when the relevant web application is shut down

            If you use Spring’s IoC container in a non-web application environment (for example, in a rich
            client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful
            shutdown and calls the relevant destroy methods on your singleton beans so that all resources are
            released. You must still configure and implement these destroy callbacks correctly

            Thus, beans can programmatically manipulate the ApplicationContext that created them, through
            the ApplicationContext interface or by casting the reference to a known subclass of this interface
            (such as ConfigurableApplicationContext, which exposes additional functionality). One use would be
            the programmatic retrieval of other beans. Sometimes this capability is useful. However, in general,
            you should avoid it, because it couples the code to Spring and does not follow the Inversion of
            Control style, where collaborators are provided to beans as properties. Other methods of the
            ApplicationContext provide access to file resources, publishing application events, and accessing a
            MessageSource. These additional features are described in Additional Capabilities of the
            ApplicationContext.

            Other Aware Interfaces
            Besides ApplicationContextAware and BeanNameAware (discussed earlier), Spring offers a wide range of
            Aware callback interfaces that let beans indicate to the container that they require a certain
            infrastructure dependency. As a general rule, the name indicates the dependency type. The
            following table summarizes the most important Aware interfaces:
                Name                            Injected Dependency
                ApplicationContextAware         Declaring ApplicationContext.
                ApplicationEventPublisherAware  Event publisher of the enclosing ApplicationContext
                BeanClassLoaderAware            Class loader used to load the bean classes
                BeanFactoryAware                Declaring BeanFactory.
                BeanNameAware                   Name of the declaring bean
                LoadTimeWeaverAware             Defined weaver for processing class definition at load time.
                MessageSourceAware              Configured strategy for resolving messages (with support for parametrization
                                                and internationalization).
                NotificationPublisherAware      Spring JMX notification publisher.
                ResourceLoaderAware             Configured loader for low-level access to resources.
                ServletConfigAware              Current ServletConfig the container runs in. Valid only in
                                                a web-aware Spring ApplicationContext.
                ServletContextAware             Current ServletContext the container runs in. Valid only in
                                                a web-aware Spring ApplicationContext.

            Note again that using these interfaces ties your code to the Spring API and does not follow the
            Inversion of Control style. As a result, we recommend them for infrastructure beans that require
            programmatic access to the container.


        2.1.7. Bean Definition Inheritance
            A bean definition can contain a lot of configuration information, including constructor arguments,
            property values, and container-specific information, such as the initialization method, a static
            factory method name, and so on. A child bean definition inherits configuration data from a parent
            definition. The child definition can override some values or add others as needed. Using parent and
            child bean definitions can save a lot of typing. Effectively, this is a form of templating.

            If you work with an ApplicationContext interface programmatically, child bean definitions are
            represented by the ChildBeanDefinition class. Most users do not work with them on this level.
            Instead, they configure bean definitions declaratively in a class such as the
            ClassPathXmlApplicationContext. When you use XML-based configuration metadata, you can
            indicate a child bean definition by using the parent attribute, specifying the parent bean as the
            value of this attribute

            A child bean definition inherits scope, constructor argument values, property values, and method
            overrides from the parent, with the option to add new values. Any scope, initialization method,
            destroy method, or static factory method settings that you specify override the corresponding
            parent settings.
            The remaining settings are always taken from the child definition: depends on, autowire mode,
            dependency check, singleton, and lazy init


        2.1.8. Container Extension Points
            Typically, an application developer does not need to subclass ApplicationContext implementation
            classes. Instead, the Spring IoC container can be extended by plugging in implementations of
            special integration interfaces. The next few sections describe these integration interfaces.

            Customizing Beans by Using a BeanPostProcessor
            The BeanPostProcessor interface defines callback methods that you can implement to provide your
            own (or override the container’s default) instantiation logic, dependency resolution logic, and so
            forth. If you want to implement some custom logic after the Spring container finishes instantiating,
            configuring, and initializing a bean, you can plug in one or more custom BeanPostProcessor
            implementations

            An ApplicationContext automatically detects any beans that are defined in the configuration
            metadata that implement the BeanPostProcessor interface. The ApplicationContext registers these
            beans as post-processors so that they can be called later, upon bean creation. Bean post-processors
            can be deployed in the container in the same fashion as any other beans.

            Using callback interfaces or annotations in conjunction with a custom BeanPostProcessor
            implementation is a common means of extending the Spring IoC container. An example is Spring’s
            AutowiredAnnotationBeanPostProcessor — a BeanPostProcessor implementation that ships with the
            Spring distribution and autowires annotated fields, setter methods, and arbitrary config methods.

            Customizing Configuration Metadata with a BeanFactoryPostProcessor
            The next extension point that we look at is the
            org.springframework.beans.factory.config.BeanFactoryPostProcessor. The semantics of this
            interface are similar to those of the BeanPostProcessor, with one major difference:
            BeanFactoryPostProcessor operates on the bean configuration metadata. That is, the Spring IoC
            container lets a BeanFactoryPostProcessor read the configuration metadata and potentially change it
            before the container instantiates any beans other than BeanFactoryPostProcessor instances.

            A bean factory post-processor is automatically run when it is declared inside an ApplicationContext,
            in order to apply changes to the configuration metadata that define the container. Spring includes a
            number of predefined bean factory post-processors, such as PropertyOverrideConfigurer and
            PropertySourcesPlaceholderConfigurer.

    !!!     Customizing Instantiation Logic with a FactoryBean
            You can implement the org.springframework.beans.factory.FactoryBean interface for objects that are
            themselves factories.
            The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation
            logic. If you have complex initialization code that is better expressed in Java as opposed to a
            (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex
            initialization inside that class, and then plug your custom FactoryBean into the container.

            The FactoryBean concept and interface are used in a number of places within the Spring
            Framework. More than 50 implementations of the FactoryBean interface ship with Spring itself.

        2.1.9. Annotation-based Container Configuration
            Are annotations better than XML for configuring Spring?
            The introduction of annotation-based configuration raised the question of whether this
            approach is “better” than XML. The short answer is “it depends.” The long answer is that each
            approach has its pros and cons, and, usually, it is up to the developer to decide which strategy
            suits them better. Due to the way they are defined, annotations provide a lot of context in
            their declaration, leading to shorter and more concise configuration. However, XML excels at
            wiring up components without touching their source code or recompiling them. Some
            developers prefer having the wiring close to the source while others argue that annotated
            classes are no longer POJOs and, furthermore, that the configuration becomes decentralized
            and harder to control.
            No matter the choice, Spring can accommodate both styles and even mix them together. I

            An alternative to XML setup is provided by annotation-based configuration, which relies on the
            bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of
            using XML to describe a bean wiring, the developer moves the configuration into the component
            class itself by using annotations on the relevant class, method, or field declaration. As mentioned in
            Example: The AutowiredAnnotationBeanPostProcessor, using a BeanPostProcessor in conjunction with
            annotations is a common means of extending the Spring IoC container. For example, Spring 2.5
            introduced an annotation-based approach to drive Spring’s dependency injection. Essentially, the
            @Autowired annotation provides the same capabilities as described in Autowiring Collaborators but
            with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250
            annotations, such as @PostConstruct and @PreDestroy. Spring 3.0 added support for JSR-330
            (Dependency Injection for Java) annotations contained in the jakarta.inject package such as
            @Inject and @Named. Details about those annotations can be found in the relevant section.

    !!!!!   Annotation injection is performed before XML injection. Thus, the XML
            configuration overrides the annotations for properties wired through both
            approaches.

            The <context:annotation-config/> element (defined in XML config) implicitly registers the following
            post-processors:
                • ConfigurationClassPostProcessor
                • AutowiredAnnotationBeanPostProcessor
                • CommonAnnotationBeanPostProcessor
                • PersistenceAnnotationBeanPostProcessor
                • EventListenerMethodProcessor

            Using @Autowired
            JSR 330’s @Inject annotation can be used in place of Spring’s @Autowired annotation
            in the examples included in this section. See here for more details.

                public class MovieRecommender {
                  private final CustomerPreferenceDao customerPreferenceDao;

                  @Autowired
                  public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
                    this.customerPreferenceDao = customerPreferenceDao;
                  }
                  // ...
                }

            As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no
            longer necessary if the target bean defines only one constructor to begin with.
            However, if several constructors are available and there is no primary/default
            constructor, at least one of the constructors must be annotated with @Autowired in
            order to instruct the container which one to use. See the discussion on constructor
            resolution for details.

    !!!     You can also apply the @Autowired annotation to traditional setter methods
    !!!     You can apply @Autowired to fields as well and even mix it with constructors
    !!!     You can also apply the annotation to methods with arbitrary names and multiple arguments, as the
            following example shows:
                public class MovieRecommender {
                  private MovieCatalog movieCatalog;
                  private CustomerPreferenceDao customerPreferenceDao;

                  @Autowired
                  public void prepare(MovieCatalog movieCatalog,
                    CustomerPreferenceDao customerPreferenceDao) {
                        this.movieCatalog = movieCatalog;
                        this.customerPreferenceDao = customerPreferenceDao;
                  }
                  // ...
                }

            Make sure that your target components (for example, MovieCatalog, CustomerPreferenceDao) are consistently
            declared by the type that you use for your @Autowired-annotated injection points. Otherwise, injection may
            fail due to a "no type match found" error at runtime.

            For XML-defined beans or component classes found via classpath scanning, the
            container usually knows the concrete type up front. However, for @Bean factory
            methods, you need to make sure that the declared return type is sufficiently
            expressive. For components that implement several interfaces or for components
            potentially referred to by their implementation type, consider declaring the most
            specific return type on your factory method (at least as specific as required by the
            injection points referring to your bean).

            Your target beans can implement the org.springframework.core.Ordered interface
            or use the @Order or standard @Priority annotation if you want items in the array
            or list to be sorted in a specific order. Otherwise, their order follows the
            registration order of the corresponding target bean definitions in the container.

            @Order values may influence priorities at injection
            points, but be aware that they do not influence singleton startup order, which is an
            orthogonal concern determined by dependency relationships and @DependsOn declarations.

    !!!     By default, autowiring fails when no matching candidate beans are available for a given injection
            point. In the case of a declared array, collection, or map, at least one matching element is expected.

            The default behavior is to treat annotated methods and fields as indicating required dependencies.
            You can change this behavior as demonstrated in the following example, enabling the framework to
            skip a non-satisfiable injection point through marking it as non-required (i.e., by setting the
            required attribute in @Autowired to false):
                public class SimpleMovieLister {
                  private MovieFinder movieFinder;

                  @Autowired(required = false)
                  public void setMovieFinder(MovieFinder movieFinder) {
                    this.movieFinder = movieFinder;
                  }
                  // ...
                }
    !!!     A non-required method will not be called at all if its dependency (or one of its
            dependencies, in case of multiple arguments) is not available. A non-required field
            will not get populated at all in such cases, leaving its default value in place.
            In other words, setting the required attribute to false indicates that the
            corresponding property is optional for autowiring purposes, and the property will
            be ignored if it cannot be autowired. This allows properties to be assigned default
            values that can be optionally overridden via dependency injection

    !!!!!   Only one constructor of any given bean class may declare @Autowired with the
            required attribute set to true, indicating the constructor to autowire when used as
            a Spring bean. As a consequence, if the required attribute is left at its default value
            true, only a single constructor may be annotated with @Autowired. If multiple
            constructors declare the annotation, they will all have to declare required=false in
            order to be considered as candidates for autowiring (analogous to
            autowire=constructor in XML). The constructor with the greatest number of
            dependencies that can be satisfied by matching beans in the Spring container will
            be chosen. If none of the candidates can be satisfied, then a primary/default
            constructor (if present) will be used. Similarly, if a class declares multiple
            constructors but none of them is annotated with @Autowired, then a
            primary/default constructor (if present) will be used. If a class only declares a
            single constructor to begin with, it will always be used, even if not annotated. Note
            that an annotated constructor does not have to be public.

            Alternatively, you can express the non-required nature of a particular dependency through Java 8’s
            java.util.Optional, as the following example shows:

              @Autowired
              public void setMovieFinder(Optional<MovieFinder> movieFinder) {
              ...
              }

            You can also use @Autowired for interfaces that are well-known resolvable dependencies:
            BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and
            MessageSource. These interfaces and their extended interfaces, such as
            ConfigurableApplicationContext or ResourcePatternResolver, are automatically resolved, with no
            special setup necessary

            The @Autowired, @Inject, @Value, and @Resource annotations are handled by Spring
            BeanPostProcessor implementations. This means that you cannot apply these
            annotations within your own BeanPostProcessor or BeanFactoryPostProcessor types
            (if any). These types must be 'wired up' explicitly by using XML or a Spring @Bean method

            Fine-tuning Annotation-based Autowiring with @Primary
    !!!!    Because autowiring by type may lead to multiple candidates, it is often necessary to have more
            control over the selection process. One way to accomplish this is with Spring’s @Primary annotation.
            @Primary indicates that a particular bean should be given preference when multiple beans are
            candidates to be autowired to a single-valued dependency. If exactly one primary bean exists
            among the candidates, it becomes the autowired value.

            Fine-tuning Annotation-based Autowiring with Qualifiers
    !!!     @Primary is an effective way to use autowiring by type with several instances when one primary
            candidate can be determined. When you need more control over the selection process, you can use
            Spring’s @Qualifier annotation. You can associate qualifier values with specific arguments,
            narrowing the set of type matches so that a specific bean is chosen for each argument.

            @Autowired is fundamentally about type-driven injection with optional semantic qualifiers. This
            means that qualifier values, even with the bean name fallback, always have narrowing semantics
            within the set of type matches. They do not semantically express a reference to a unique bean id.
            Good qualifier values are main or EMEA or persistent, expressing characteristics of a specific
            component

            Qualifiers also apply to typed collections, as discussed earlier — for example, to Set<MovieCatalog>.
            In this case, all matching beans, according to the declared qualifiers, are injected as a collection.
            This implies that qualifiers do not have to be unique. Rather, they constitute filtering criteria. For
            example, you can define multiple MovieCatalog beans with the same qualifier value “action”, all of
            which are injected into a Set<MovieCatalog> annotated with @Qualifier("action").

    !!!!    If there is no other resolution indicator (such as a qualifier or a primary marker), for a
            non-unique dependency situation, Spring matches the injection point name (that
            is, the field name or parameter name) against the target bean names and chooses
            the same-named candidate, if any.
                Dan : bean name means if you use XML for defining beans something like the "name" attribute from below:
                    <bean name="anotherExample" class="examples.ExampleBeanTwo"/>

            That said, if you intend to express annotation-driven injection by name, do not primarily use
            @Autowired, even if it is capable of selecting by bean name among type-matching candidates.
            Instead, use the JSR-250 @Resource annotation, which is semantically defined to identify a specific
            target component by its unique name, with the declared type being irrelevant for the matching
            process. @Autowired has rather different semantics: After selecting candidate beans by type, the
            specified String qualifier value is considered within those type-selected candidates only

    !!!     @Autowired applies to fields, constructors, and multi-argument methods, allowing for narrowing
            through qualifier annotations at the parameter level. In contrast, @Resource is supported only for
            fields and bean property setter methods with a single argument. As a consequence, you should stick
            with qualifiers if your injection target is a constructor or a multi-argument method.

            You can create your own custom qualifier annotations. To do so, define an annotation and provide
            the @Qualifier annotation within your definition, as the following example shows
                Dan: see Genre interface in this project

            In some cases, using an annotation without a value may suffice. This can be useful when the
            annotation serves a more generic purpose and can be applied across several different types of
            dependencies.

            Using Generics as Autowiring Qualifiers
            In addition to the @Qualifier annotation, you can use Java generic types as an implicit form of qualification.

            Dan: Adding this for more context, in order for you to understand later one...Lets assume that you have 2 beans
            StringStore and IntegerStore that you want to inject.Next...from the documentation:
            Assuming that the preceding beans implement a generic interface, (that is, Store<String> and
            Store<Integer>), you can @Autowire the Store interface and the generic is used as a qualifier, as the
            following example shows:

                @Autowired
                private Store<String> s1; // <String> qualifier, injects the stringStore bean
                @Autowired
                private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean

            Generic qualifiers also apply when autowiring lists, Map instances and arrays:
                // Inject all Store beans as long as they have an <Integer> generic
                // Store<String> beans will not appear in this list
                @Autowired
                private List<Store<Integer>> s;

            Injection with @Resource
            Spring also supports injection by using the JSR-250 @Resource annotation
            (jakarta.annotation.Resource) on fields or bean property setter methods. This is a common pattern
            in Jakarta EE: for example, in JSF-managed beans and JAX-WS endpoints. Spring supports this
            pattern for Spring-managed objects as well.
            @Resource takes a name attribute.

    !!!!    By default, Spring interprets that value as the bean name to be injected. In other words, it follows
            by-name semantics
            If no name is explicitly specified, the default name is derived from the field name or setter method.
            In case of a field, it takes the field name. In case of a setter method, it takes the bean property name.

    !!      In the exclusive case of @Resource usage with no explicit name specified, and similar to @Autowired,
            @Resource finds a primary type match instead of a specific named bean and resolves well known
            resolvable dependencies

            Thus, in the following example, the customerPreferenceDao field first looks for a bean named
            "customerPreferenceDao" and then falls back to a primary type match for the type
            CustomerPreferenceDao:

                 @Resource
                 private CustomerPreferenceDao customerPreferenceDao;
                 @Resource
                 private ApplicationContext context;

    !!!     The context field is injected based on the known resolvable dependency type: ApplicationContext.

            Using @Value
            @Value is typically used to inject externalized properties

                @Configuration
                @PropertySource("classpath:application.properties")
                public class AppConfig { }

                @Value("${catalog.name}") String catalog
                    Dan: this will look into the application.properties file for a key catalog.name and inject the string value
                        of that key

            If you want to maintain strict control over nonexistent values, you should declare a
            PropertySourcesPlaceholderConfigurer bean, as the following example shows:
                @Configuration
                public class AppConfig {
                  @Bean
                  public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer()
                {
                  return new PropertySourcesPlaceholderConfigurer();
                  }
                }
            Using the above configuration ensures Spring initialization failure if any ${} placeholder could not
            be resolved

    !!!!    Spring Boot configures by default a PropertySourcesPlaceholderConfigurer bean
            that will get properties from application.properties and application.yml files.

            Built-in converter support provided by Spring allows simple type conversion (to Integer or int for
            example) to be automatically handled. Multiple comma-separated values can be automatically
            converted to String array without extra effort.

            Using @PostConstruct and @PreDestroy
            The CommonAnnotationBeanPostProcessor not only recognizes the @Resource annotation but also the
            JSR-250 lifecycle annotations: jakarta.annotation.PostConstruct and jakarta.annotation.PreDestroy.
            Introduced in Spring 2.5, the support for these annotations offers an alternative to the lifecycle
            callback mechanism described in initialization callbacks and destruction callbacks. Provided that
            the CommonAnnotationBeanPostProcessor is registered within the Spring ApplicationContext, a method
            carrying one of these annotations is invoked at the same point in the lifecycle as the corresponding
            Spring lifecycle interface method or explicitly declared callback method.

                  @PostConstruct
                  public void populateMovieCache() {
                    // populates the movie cache upon initialization...
                  }
                  @PreDestroy
                  public void clearMovieCache() {
                    // clears the movie cache upon destruction...
                  }

        2.1.10. Classpath Scanning and Managed Components
            Most examples in this chapter use XML to specify the configuration metadata that produces each
            BeanDefinition within the Spring container. The previous section (Annotation-based Container
            Configuration) demonstrates how to provide a lot of the configuration metadata through sourcelevel annotations.
            Even in those examples, however, the “base” bean definitions are explicitly
            defined in the XML file, while the annotations drive only the dependency injection. This section
            describes an option for implicitly detecting the candidate components by scanning the classpath.
            Candidate components are classes that match against a filter criteria and have a corresponding
            bean definition registered with the container. This removes the need to use XML to perform bean
            registration. Instead, you can use annotations (for example, @Component), AspectJ type expressions,
            or your own custom filter criteria to select which classes have bean definitions registered with the
            container

            @Component and Further Stereotype Annotations
    !!!!    The @Repository annotation is a marker for any class that fulfills the role or stereotype of a
            repository (also known as Data Access Object or DAO). Among the uses of this marker is the
            automatic translation of exceptions, as described in Exception Translation.

    !!!!    Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is
            a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are
            specializations of @Component for more specific use cases (in the persistence, service, and
            presentation layers, respectively). Therefore, you can annotate your component classes with
            @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes
            are more properly suited for processing by tools or associating with aspects. For example, these
            stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can
            also carry additional semantics in future releases of the Spring Framework. Thus, if you are
            choosing between using @Component or @Service for your service layer, @Service is clearly the better
            choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic
            exception translation in your persistence layer.

            Using Meta-annotations and Composed Annotations
            Many of the annotations provided by Spring can be used as meta-annotations in your own code. A
            meta-annotation is an annotation that can be applied to another annotation. For example, the
            @Service annotation mentioned earlier is meta-annotated with @Component

            The @Component causes @Service to be treated in the same way as @Component.

            You can also combine meta-annotations to create “composed annotations”. For example, the
            @RestController annotation from Spring MVC is composed of @Controller and @ResponseBody

            Automatically Detecting Classes and Registering Bean Definitions
            Spring can automatically detect stereotyped classes and register corresponding BeanDefinition
            instances with the ApplicationContext.

    !!!     To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to
            your @Configuration class, where the basePackages attribute is a common parent package for the two
            classes. (Alternatively, you can specify a comma- or semicolon- or space-separated list that includes
            the parent package of each class.)

                @Configuration
                @ComponentScan(basePackages = "org.example")
                public class AppConfig {
                  // ...
                }

            Using Filters to Customize Scanning
            By default, classes annotated with @Component, @Repository, @Service, @Controller, @Configuration, or
            a custom annotation that itself is annotated with @Component are the only detected candidate
            components. However, you can modify and extend this behavior by applying custom filters. Add
            them as includeFilters or excludeFilters attributes of the @ComponentScan annotation (or as
            <context:include-filter /> or <context:exclude-filter /> child elements of the <context:componentscan> element
            in XML configuration).

                Dan: too detailed for now

            Defining Bean Metadata within Components
            The @Bean methods in a regular Spring component are processed differently than their counterparts
            inside a Spring @Configuration class. The difference is that @Component classes are not enhanced with
            CGLIB to intercept the invocation of methods and fields. CGLIB proxying is the means by which
            invoking methods or fields within @Bean methods in @Configuration classes creates bean metadata
            references to collaborating objects. Such methods are not invoked with normal Java semantics but
            rather go through the container in order to provide the usual lifecycle management and proxying
            of Spring beans, even when referring to other beans through programmatic calls to @Bean methods.
            In contrast, invoking a method or field in a @Bean method within a plain @Component class has
            standard Java semantics, with no special CGLIB processing or other constraints applying.

            You may declare @Bean methods as static, allowing for them to be called without
            creating their containing configuration class as an instance. This makes particular
            sense when defining post-processor beans (for example, of type
            BeanFactoryPostProcessor or BeanPostProcessor), since such beans get initialized
            early in the container lifecycle and should avoid triggering other parts of the
            configuration at that point

    !!!!    The Java language visibility of @Bean methods does not have an immediate impact
            on the resulting bean definition in Spring’s container. You can freely declare your
            factory methods as you see fit in non-@Configuration classes and also for static
            methods anywhere. However, regular @Bean methods in @Configuration classes
            need to be overridable — that is, they must not be declared as private or final.

            Finally, a single class may hold multiple @Bean methods for the same bean, as an
            arrangement of multiple factory methods to use depending on available
            dependencies at runtime. This is the same algorithm as for choosing the
            “greediest” constructor or factory method in other configuration scenarios: The
            variant with the largest number of satisfiable dependencies is picked at
            construction time, analogous to how the container selects between multiple
            @Autowired constructors.

            Naming Autodetected Components
            When a component is autodetected as part of the scanning process, its bean name is generated by
            the BeanNameGenerator strategy known to that scanner. By default, any Spring stereotype annotation
            (@Component, @Repository, @Service, and @Controller) that contains a name value thereby provides
            that name to the corresponding bean definition.
            If such an annotation contains no name value or for any other detected component (such as those
            discovered by custom filters), the default bean name generator returns the uncapitalized nonqualified class name.

            If you do not want to rely on the default bean-naming strategy, you can provide a custom beannaming strategy.
            First, implement the BeanNameGenerator interface, and be sure to include a default
            no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as
            the following example annotation and bean definition show.

    !!!!    If you run into naming conflicts due to multiple autodetected components having
            the same non-qualified class name (i.e., classes with identical names but residing
            in different packages), you may need to configure a BeanNameGenerator that defaults
            to the fully qualified class name for the generated bean name. As of Spring
            Framework 5.2.3, the FullyQualifiedAnnotationBeanNameGenerator located in
            package org.springframework.context.annotation can be used for such purposes.

            Providing a Scope for Autodetected Components
            As with Spring-managed components in general, the default and most common scope for
            autodetected components is singleton. However, sometimes you need a different scope that can be
            specified by the @Scope annotation. You can provide the name of the scope within the annotation, as
            the following example shows:

                @Scope("prototype")
                @Repository
                public class MovieFinderImpl implements MovieFinder {
                  // ...
                }

            @Scope annotations are only introspected on the concrete bean class (for annotated
            components) or the factory method (for @Bean methods). In contrast to XML bean
            definitions, there is no notion of bean definition inheritance, and inheritance
            hierarchies at the class level are irrelevant for metadata purposes.

            For details on web-specific scopes such as “request” or “session” in a Spring context, see Request,
            Session, Application, and WebSocket Scopes.

            When using certain non-singleton scopes, it may be necessary to generate proxies for the scoped
            objects. The reasoning is described in Scoped Beans as Dependencies. For this purpose, a scoped proxy attribute
            is available on the component-scan element. The three possible values are: no,
            interfaces, and targetClass. For example, the following configuration results in standard JDK
            dynamic proxies:
                @Configuration
                @ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
                public class AppConfig {
                  // ...
                }

            Providing Qualifier Metadata with Annotations
            The @Qualifier annotation is discussed in Fine-tuning Annotation-based Autowiring with Qualifiers.
            The examples in that section demonstrate the use of the @Qualifier annotation and custom qualifier
            annotations to provide fine-grained control when you resolve autowire candidates. Because those
            examples were based on XML bean definitions, the qualifier metadata was provided on the
            candidate bean definitions by using the qualifier or meta child elements of the bean element in the
            XML. When relying upon classpath scanning for auto-detection of components, you can provide the
            qualifier metadata with type-level annotations on the candidate class. The following three
            examples demonstrate this technique:
                @Component
                @Qualifier("Action")
                public class ActionMovieCatalog implements MovieCatalog {
                  // ...
                }

                @Component
                @Genre("Action")
                public class ActionMovieCatalog implements MovieCatalog {
                  // ...
                }

                @Component
                @Offline
                public class CachingMovieCatalog implements MovieCatalog {
                  // ...
                }

    !!!!    As with most annotation-based alternatives, keep in mind that the annotation
            metadata is bound to the class definition itself, while the use of XML allows for
            multiple beans of the same type to provide variations in their qualifier metadata,
            because that metadata is provided per-instance rather than per-class.

            Generating an Index of Candidate Components
    !!      While classpath scanning is very fast, it is possible to improve the startup performance of large
            applications by creating a static list of candidates at compilation time. In this mode, all modules that
            are targets of component scanning must use this mechanism.

            Your existing @ComponentScan or <context:component-scan/> directives must remain
            unchanged to request the context to scan candidates in certain packages. When
            the ApplicationContext detects such an index, it automatically uses it rather than
            scanning the classpath.
            To generate the index, add an additional dependency to each module that contains components that
            are targets for component scan directives. The following example shows how to do so with Maven:
                <dependency>
                  <groupId>org.springframework</groupId>
                  <artifactId>spring-context-indexer</artifactId>
                  <version>6.0.0</version>
                  <optional>true</optional>
                </dependency>

            The spring-context-indexer artifact generates a META-INF/spring.components file that is included in
            the jar file.

        2.1.11. Using JSR 330 Standard Annotations
    !!!!    Starting with Spring 3.0, Spring offers support for JSR-330 standard annotations (Dependency
            Injection). Those annotations are scanned in the same way as the Spring annotations. To use them,
            you need to have the relevant jars in your classpath

                <dependency>
                  <groupId>jakarta.inject</groupId>
                  <artifactId>jakarta.inject-api</artifactId>
                  <version>1</version>
                </dependency>

            Dependency Injection with @Inject and @Named
    !!!!    Instead of @Autowired, you can use @jakarta.inject.Inject as follows:
                  private MovieFinder movieFinder;
                  @Inject
                  public void setMovieFinder(MovieFinder movieFinder) {
                    this.movieFinder = movieFinder;
                  }

    !!!!    As with @Autowired, you can use @Inject at the field level, method level and constructor-argument
            level. Furthermore, you may declare your injection point as a Provider, allowing for on-demand
            access to beans of shorter scopes or lazy access to other beans through a Provider.get() call
                private Provider<MovieFinder> movieFinder;
                @Inject
                public void setMovieFinder(Provider<MovieFinder> movieFinder) {
                    this.movieFinder = movieFinder;
                }
                public void listMovies() {
                    this.movieFinder.get().findMovies(...);
                  // ...
                }

            If you would like to use a qualified name for the dependency that should be injected, you should
            use the @Named annotation, as the following example shows:
                @Inject
                public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
                  this.movieFinder = movieFinder;
                }

            As with @Autowired, @Inject can also be used with java.util.Optional or @Nullable. This is even
            more applicable here, since @Inject does not have a required attribute.

            @Named and @ManagedBean: Standard Equivalents to the @Component Annotation
    !!!     Instead of @Component, you can use @jakarta.inject.Named or jakarta.annotation.ManagedBean,

            It is very common to use @Component without specifying a name for the component. @Named can be
            used in a similar fashion
            When you use @Named or @ManagedBean, you can use component scanning in the exact same way as
            when you use Spring annotation

            In contrast to @Component, the JSR-330 @Named and the JSR-250 @ManagedBean
            annotations are not composable. You should use Spring’s stereotype model for
            building custom component annotations.
                Dan: see below other differences of Standard Annotations

    !!!!    Limitations of JSR-330 Standard Annotations
            Spring              jakarta.inject.*                jakarta.inject restrictions / comments
            @Autowired          @Inject                         @Inject has no 'required'
                                                                attribute. Can be used with Java
                                                                8’s Optional instead.
            @Component          @Named / @ManagedBean           JSR-330 does not provide a
                                                                composable model, only a way
                                                                to identify named components.
            @Scope("singleton") @Singleton                      The JSR-330 default scope is like
                                                                Spring’s prototype. However, in
                                                                order to keep it consistent with
                                                                Spring’s general defaults, a JSR330
                                                                bean declared in the Spring
                                                                container is a singleton by
                                                                default. In order to use a scope
                                                                other than singleton, you
                                                                should use Spring’s @Scope
                                                                annotation. jakarta.inject also
                                                                provides a jakarta.inject.Scope
                                                                annotation: however, this one is
                                                                only intended to be used for
                                                                creating custom annotations
            @Qualifier          @Qualifier / @Named             jakarta.inject.Qualifier is just
                                                                a meta-annotation for building
                                                                custom qualifiers. Concrete
                                                                String qualifiers (like Spring’s
                                                                @Qualifier with a value) can be
                                                                associated through
                                                                jakarta.inject.Named.
            @Value              -                               no equivalent
            @Lazy               -                               no equivalent
            ObjectFactory       Provider                        jakarta.inject.Provider is a
                                                                direct alternative to Spring’s
                                                                ObjectFactory, only with a
                                                                shorter get() method name. It
                                                                can also be used in combination
                                                                with Spring’s @Autowired or with
                                                                non-annotated constructors and
                                                                setter methods.


        2.1.12. Java-based Container Configuration
            This section covers how to use annotations in your Java code to configure the Spring container.

            Basic Concepts: @Bean and @Configuration
    !!!!!   The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated
            classes and @Bean-annotated methods.
            The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new
            object to be managed by the Spring IoC container. For those familiar with Spring’s <beans/> XML
            configuration, the @Bean annotation plays the same role as the <bean/> element. You can use @Bean
            -annotated methods with any Spring @Component. However, they are most often used with
            @Configuration beans.

            Annotating a class with @Configuration indicates that its primary purpose is as a source of bean
            definitions. Furthermore, @Configuration classes let inter-bean dependencies be defined by calling
            other @Bean methods in the same class.

    !!!     Full @Configuration vs “lite” @Bean mode?
            When @Bean methods are declared within classes that are not annotated with @Configuration,
            they are referred to as being processed in a “lite” mode. Bean methods declared in a
            @Component or even in a plain old class are considered to be “lite”, with a different primary
            purpose of the containing class and a @Bean method being a sort of bonus there. For example,
            service components may expose management views to the container through an additional
            @Bean method on each applicable component class. In such scenarios, @Bean methods are a
            general-purpose factory method mechanism.
            Unlike full @Configuration, lite @Bean methods cannot declare inter-bean dependencies.
            Instead, they operate on their containing component’s internal state and, optionally, on
            arguments that they may declare. Such a @Bean method should therefore not invoke other
            @Bean methods. Each such method is literally only a factory method for a particular bean
            reference, without any special runtime semantics. The positive side-effect here is that no
            CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class
            design (that is, the containing class may be final and so forth).
    !!!!!   In common scenarios, @Bean methods are to be declared within @Configuration classes,
            ensuring that “full” mode is always used and that cross-method references therefore get
            redirected to the container’s lifecycle management. This prevents the same @Bean method
            from accidentally being invoked through a regular Java call, which helps to reduce subtle
            bugs that can be hard to track down when operating in “lite” mode.

            Instantiating the Spring Container by Using AnnotationConfigApplicationContext
            The following sections document Spring’s AnnotationConfigApplicationContext, introduced in Spring
            3.0. This versatile ApplicationContext implementation is capable of accepting not only
            @Configuration classes as input but also plain @Component classes and classes annotated with JSR-330
            metadata.

            When @Configuration classes are provided as input, the @Configuration class itself is registered as a
            bean definition and all declared @Bean methods within the class are also registered as bean
            definitions.
            When @Component and JSR-330 classes are provided, they are registered as bean definitions, and it is
            assumed that DI metadata such as @Autowired or @Inject are used within those classes where
            necessary

            Simple Construction
    !!      In much the same way that Spring XML files are used as input when instantiating a
            ClassPathXmlApplicationContext, you can use @Configuration classes as input when instantiating an
            AnnotationConfigApplicationContext. This allows for completely XML-free usage of the Spring
            container
                Dan: see my class MainContainerConfiguration as example

            As mentioned earlier, AnnotationConfigApplicationContext is not limited to working only with
            @Configuration classes. Any @Component or JSR-330 annotated class may be supplied as input to the
            constructor, as the following example shows:

    !!      Building the Container Programmatically by Using register(Class<?>…)
            You can instantiate an AnnotationConfigApplicationContext by using a no-arg constructor and then
            configure it by using the register() method. This approach is particularly useful when
            programmatically building an AnnotationConfigApplicationContext. T

    !!      Enabling Component Scanning with scan(String…)
            To enable component scanning, you can annotate your @Configuration class as follows:
                @Configuration
                @ComponentScan(basePackages = "com.acme") ①
                public class AppConfig {
                  // ...
                }

            AnnotationConfigApplicationContext exposes the scan(String…) method to allow for the same
            component-scanning functionality, as the following example shows

            Remember that @Configuration classes are meta-annotated with @Component, so they
            are candidates for component-scanning. In the preceding example, assuming that
            AppConfig is declared within the com.acme package (or any package underneath), it
            is picked up during the call to scan(). Upon refresh(), all its @Bean methods are
            processed and registered as bean definitions within the container.

            Support for Web Applications with AnnotationConfigWebApplicationContext
            A WebApplicationContext variant of AnnotationConfigApplicationContext is available with
            AnnotationConfigWebApplicationContext. You can use this implementation when configuring the
            Spring ContextLoaderListener servlet listener, Spring MVC DispatcherServlet, and so forth
                Dan : there is a web.xml example in the documentation for a typical Spring MVC web app

            Using the @Bean Annotation
    !!!     @Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation
            supports some of the attributes offered by <bean/>, such as:
                • init-method
                • destroy-method
                • autowiring
                • name.
            You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.

            Declaring a Bean
    !!!!    To declare a bean, you can annotate a method with the @Bean annotation. You use this method to
            register a bean definition within an ApplicationContext of the type specified as the method’s return
            value. By default, the bean name is the same as the method name. The following example shows a
            @Bean method declaration:
                @Configuration
                public class AppConfig {
                  @Bean
                  public TransferServiceImpl transferService() {
                  return new TransferServiceImpl();
                  }
                }
            Both declarations make a bean named transferService available in the ApplicationContext, bound
            to an object instance of type TransferServiceImpl.

    !!!     You can also use default methods to define beans. This allows composition of bean configurations
            by implementing interfaces with bean definitions on default methods
                Dan : see BaseConfig

            You can also declare your @Bean method with an interface (or base class) return type...example:
                @Configuration
                public class AppConfig {
                  @Bean
                  public TransferService transferService() {
                  return new TransferServiceImpl();
                  }
                }

            However, this limits the visibility for advance type prediction to the specified interface type
            (TransferService). Then, with the full type (TransferServiceImpl) known to the container only once
            the affected singleton bean has been instantiated. Non-lazy singleton beans get instantiated
            according to their declaration order, so you may see different type matching results depending on
            when another component tries to match by a non-declared type (such as @Autowired
            TransferServiceImpl, which resolves only once the transferService bean has been instantiated).
                Dan:...i don't quite understand this..

    !!!!!!  If you consistently refer to your types by a declared service interface, your @Bean
            return types may safely join that design decision. However, for components that
            implement several interfaces or for components potentially referred to by their
            implementation type, it is safer to declare the most specific return type possible (at
            least as specific as required by the injection points that refer to your bean).

            Bean Dependencies
            A @Bean-annotated method can have an arbitrary number of parameters that describe the
            dependencies required to build that bean. For instance, if our TransferService requires an
            AccountRepository, we can materialize that dependency with a method parameter

            Receiving Lifecycle Callbacks
            Any classes defined with the @Bean annotation support the regular lifecycle callbacks and can use
            the @PostConstruct and @PreDestroy annotations from JSR-250. See JSR-250 annotations for further details.
            The regular Spring lifecycle callbacks are fully supported as well. If a bean implements
            InitializingBean, DisposableBean, or Lifecycle, their respective methods are called by the container.

            By default, beans defined with Java configuration that have a public close or
            shutdown method are automatically enlisted with a destruction callback. If you
            have a public close or shutdown method and you do not wish for it to be called
            when the container shuts down, you can add @Bean(destroyMethod="") to your bean
            definition to disable the default (inferred) mode.

            Using the @Scope Annotation
            You can specify that your beans defined with the @Bean annotation should have a specific scope. You
            can use any of the standard scopes specified in the Bean Scopes section.
            The default scope is singleton, but you can override this with the @Scope annotation, as the
            following example shows:
                @Configuration
                public class MyConfiguration {
                  @Bean
                  @Scope("prototype")
                  public Encryptor encryptor() {
                  // ...
                  }
                }

            Customizing Bean Naming
            By default, configuration classes use a @Bean method’s name as the name of the resulting bean. This
            functionality can be overridden, however, with the name attribute

            Using the @Configuration annotation
    !!!     @Configuration is a class-level annotation indicating that an object is a source of bean definitions.
            @Configuration classes declare beans through @Bean-annotated methods. Calls to @Bean methods on
            @Configuration classes can also be used to define inter-bean dependencies. See Basic Concepts: @Bean
            and @Configuration for a general introduction.

            Injecting Inter-bean Dependencies
            When beans have dependencies on one another, expressing that dependency is as simple as having
            one bean method call another, as the following example shows:
                @Configuration
                public class AppConfig {
                  @Bean
                  public BeanOne beanOne() {
                    return new BeanOne(beanTwo());
                  }
                  @Bean
                  public BeanTwo beanTwo() {
                    return new BeanTwo();
                  }
                }

    !!!!!   In the preceding example, beanOne receives a reference to beanTwo through constructor injection.
            This method of declaring inter-bean dependencies works only when the @Bean
            method is declared within a @Configuration class. You cannot declare inter-bean
            dependencies by using plain @Component classes.

            Lookup Method Injection
            As noted earlier, lookup method injection is an advanced feature that you should use rarely. It is
            useful in cases where a singleton-scoped bean has a dependency on a prototype-scoped bean. Using
            Java for this type of configuration provides a natural means for implementing this pattern.
                Dan: the example is in the book...makes sense, did not add it as it is too detailed for now

            Further Information About How Java-based Configuration Works Internally
                Dan: see examples from package beanCalledTwice
            clientDao() has been called once in clientService1() and once in clientService2(). Since this
            method creates a new instance of ClientDaoImpl and returns it, you would normally expect to have
            two instances (one for each service). That definitely would be problematic: In Spring, instantiated
            beans have a singleton scope by default. This is where the magic comes in: All @Configuration
            classes are subclassed at startup-time with CGLIB. In the subclass, the child method checks the
            container first for any cached (scoped) beans before it calls the parent method and creates a new
            instance.

            The behavior could be different according to the scope of your bean. We are
            talking about singletons here.

    !!      Using the @Import Annotation
            Much as the <import/> element is used within Spring XML files to aid in modularizing
            configurations, the @Import annotation allows for loading @Bean definitions from another
            configuration class,

            Now, rather than needing to specify both ConfigA.class and ConfigB.class when instantiating the
            context, only ConfigB needs to be supplied explicitly
            This approach simplifies container instantiation, as only one class needs to be dealt with, rather
            than requiring you to remember a potentially large number of @Configuration classes during
            construction.

            Injecting Dependencies on Imported @Bean Definitions
            There is another way to achieve the same result. Remember that @Configuration classes are
            ultimately only another bean in the container: This means that they can take advantage of
            @Autowired and @Value injection and other features the same as any other bean

    !!!!!   Make sure that the dependencies you inject that way are of the simplest kind only.
            @Configuration classes are processed quite early during the initialization of the
            context, and forcing a dependency to be injected this way may lead to unexpected
            early initialization. Whenever possible, resort to parameter-based injection, as in
            the preceding example.
                Dan: so the example from package "importt" is good ! use that approach
            Also, be particularly careful with BeanPostProcessor and BeanFactoryPostProcessor
            definitions through @Bean. Those should usually be declared as static @Bean
            methods, not triggering the instantiation of their containing configuration class.
            Otherwise, @Autowired and @Value may not work on the configuration class itself,
            since it is possible to create it as a bean instance earlier than
            AutowiredAnnotationBeanPostProcessor.

    !!      If you want to influence the startup creation order of certain beans, consider
            declaring some of them as @Lazy (for creation on first access instead of on startup)
            or as @DependsOn certain other beans (making sure that specific other beans are
            created before the current bean, beyond what the latter’s direct dependencies imply).

            Conditionally Include @Configuration Classes or @Bean Methods
    !!!     It is often useful to conditionally enable or disable a complete @Configuration class or even
            individual @Bean methods, based on some arbitrary system state. One common example of this is to
            use the @Profile annotation to activate beans only when a specific profile has been enabled in the
            Spring Environment (see Bean Definition Profiles for details).

            The @Profile annotation is actually implemented by using a much more flexible annotation called
            @Conditional. The @Conditional annotation indicates specific
            org.springframework.context.annotation.Condition implementations that should be consulted
            before a @Bean is registered.

            XML-centric Use of @Configuration Classes
            It may be preferable to bootstrap the Spring container from XML and include @Configuration classes
            in an ad-hoc fashion. For example, in a large existing codebase that uses Spring XML, it is easier to
            create @Configuration classes on an as-needed basis and include them from the existing XML files.
            Later in this section, we cover the options for using @Configuration classes in this kind of “XMLcentric” situation.

            @Configuration Class-centric Use of XML with @ImportResource
            In applications where @Configuration classes are the primary mechanism for configuring the
            container, it is still likely necessary to use at least some XML. In these scenarios, you can use
            @ImportResource and define only as much XML as you need. Doing so achieves a “Java-centric”
            approach to configuring the container and keeps XML to a bare minimum. The following example
            (which includes a configuration class, an XML file that defines a bean, a properties file, and the main
            class) shows how to use the @ImportResource annotation to achieve “Java-centric” configuration that
            uses XML as needed

        2.1.13. Environment Abstraction
    !!!!    The Environment interface is an abstraction integrated in the container that models two key aspects
            of the application environment: profiles and properties.

    !!!!    A profile is a named, logical group of bean definitions to be registered with the container only if the
            given profile is active. Beans may be assigned to a profile whether defined in XML or with
            annotations. The role of the Environment object with relation to profiles is in determining which
            profiles (if any) are currently active, and which profiles (if any) should be active by default.

    !!!!    Properties play an important role in almost all applications and may originate from a variety of
            sources: properties files, JVM system properties, system environment variables, JNDI, servlet
            context parameters, ad-hoc Properties objects, Map objects, and so on. The role of the Environment
            object with relation to properties is to provide the user with a convenient service interface for
            configuring property sources and resolving properties from them

            Bean Definition Profiles
            Bean definition profiles provide a mechanism in the core container that allows for registration of
            different beans in different environments. The word, “environment,” can mean different things to
            different users, and this feature can help with many use cases:
                • Registering customized implementations of beans for customer A versus customer B
                deployments
                • Working against an in-memory datasource in development versus looking up that same
                datasource from JNDI when in QA or production.

            .....
            If we generalize the use case shown in the preceding example of environment-specific bean
            definitions, we end up with the need to register certain bean definitions in certain contexts but not
            in others. You could say that you want to register a certain profile of bean definitions in situation A
            and a different profile in situation B. We start by updating our configuration to reflect this need.

            Using @Profile
            The @Profile annotation lets you indicate that a component is eligible for registration when one or
            more specified profiles are active.
            Example:
                @Configuration
                @Profile("development")
                public class StandaloneDataConfig {
                  @Bean
                  public DataSource dataSource() {
                     return new EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript("classpath:com/bank/config/sql/schema.sql")
                        .addScript("classpath:com/bank/config/sql/test-data.sql")
                        .build();
                  }
                }

    !!      The profile string may contain a simple profile name (for example, production) or a profile
            expression. A profile expression allows for more complicated profile logic to be expressed (for
            example, production & us-east). The following operators are supported in profile expressions:
            • !: A logical “not” of the profile
            • &: A logical “and” of the profiles
            • |: A logical “or” of the profiles

            You cannot mix the & and | operators without using parentheses. For example,
            production & us-east | eu-central is not a valid expression. It must be expressed
            as production & (us-east | eu-central).

    !!      You can use @Profile as a meta-annotation for the purpose of creating a custom composed
            annotation. The following example defines a custom @Production annotation that you can use as a
            drop-in replacement for @Profile("production")
                @Target(ElementType.TYPE)
                @Retention(RetentionPolicy.RUNTIME)
                @Profile("production")
                public @interface Production {
                }

            If a @Configuration class is marked with @Profile, all of the @Bean methods and
            @Import annotations associated with that class are bypassed unless one or more of
            the specified profiles are active. If a @Component or @Configuration class is marked
            with @Profile({"p1", "p2"}), that class is not registered or processed unless
            profiles 'p1' or 'p2' have been activated. If a given profile is prefixed with the NOT
            operator (!), the annotated element is registered only if the profile is not active.
            For example, given @Profile({"p1", "!p2"}), registration will occur if profile 'p1' is
            active or if profile 'p2' is not active.

    !!!     @Profile can also be declared at the method level to include only one particular bean of a
            configuration class

            https://stackoverflow.com/questions/11869064/maven-profiles-or-spring-profiles

            With @Profile on @Bean methods, a special scenario may apply: In the case of
            overloaded @Bean methods of the same Java method name (analogous to
            constructor overloading), a @Profile condition needs to be consistently declared on
            all overloaded methods. If the conditions are inconsistent, only the condition on
            the first declaration among the overloaded methods matters. Therefore, @Profile
            can not be used to select an overloaded method with a particular argument
            signature over another. Resolution between all factory methods for the same bean
            follows Spring’s constructor resolution algorithm at creation time.
            If you want to define alternative beans with different profile conditions, use
            distinct Java method names that point to the same bean name by using the @Bean
            name attribute, as shown in the preceding example.

            Activating a Profile
            Now that we have updated our configuration, we still need to instruct Spring which profile is
            active. If we started our sample application right now, we would see a
            NoSuchBeanDefinitionException thrown, because the container could not find the Spring bean
            named dataSource.

            Activating a profile can be done in several ways, but the most straightforward is to do it
            programmatically against the Environment API which is available through an ApplicationContext.
                Dan: See MainProfile class
    !!!     In addition, you can also declaratively activate profiles through the spring.profiles.active
            property, which may be specified through system environment variables, JVM system properties,
            servlet context parameters in web.xml, or even as an entry in JNDI (see PropertySource Abstraction).

            Note that profiles are not an “either-or” proposition. You can activate multiple profiles at once.
            Programmatically, you can provide multiple profile names to the setActiveProfiles() method,
            which accepts String… varargs.

            Default Profile
            The default profile represents the profile that is enabled by default.
            If no profile is active, the dataSource is created. You can see this as a way to provide a default
            definition for one or more beans. If any profile is enabled, the default profile does not apply

            PropertySource Abstraction
            Spring’s Environment abstraction provides search operations over a configurable hierarchy of
            property sources
            In the preceding snippet, we see a high-level way of asking Spring whether the my-property
            property is defined for the current environment. To answer this question, the Environment object
            performs a search over a set of PropertySource objects. A PropertySource is a simple abstraction over
            any source of key-value pairs, and Spring’s StandardEnvironment is configured with two
            PropertySource objects — one representing the set of JVM system properties
            (System.getProperties()) and one representing the set of system environment variables
            (System.getenv()).

            These default property sources are present for StandardEnvironment, for use in
            standalone applications. StandardServletEnvironment is populated with additional
            default property sources including servlet config, servlet context parameters, and
            a JndiPropertySource if JNDI is available.

            Note that property values are not merged but rather completely overridden by a preceding entry.
            For a common StandardServletEnvironment, the full hierarchy is as follows, with the
            highest-precedence entries at the top:
                1. ServletConfig parameters (if applicable — for example, in case of a
                DispatcherServlet context)
                2. ServletContext parameters (web.xml context-param entries)
                3. JNDI environment variables (java:comp/env/ entries)
                4. JVM system properties (-D command-line arguments)
                5. JVM system environment (operating system environment variables)


        2.1.14. Registering a LoadTimeWeaver
            The LoadTimeWeaver is used by Spring to dynamically transform classes as they are loaded into the
            Java virtual machine (JVM).
            To enable load-time weaving, you can add the @EnableLoadTimeWeaving to one of your @Configuration
            classes

            Dan: this is too detailed for now, and there is not much info in the document about this
            concept/functionality

        2.1.15. Additional Capabilities of the ApplicationContext
            Many people use the ApplicationContext in a
            completely declarative fashion, not even creating it programmatically, but instead relying on
            support classes such as ContextLoader to automatically instantiate an ApplicationContext as part of
            the normal startup process of a Jakarta EE web application.

            To enhance BeanFactory functionality in a more framework-oriented style, the org.springframework.context
            package also provides the following functionality:
    !!!!        • Access to messages in i18n-style, through the MessageSource interface.
    !!!!        • Access to resources, such as URLs and files, through the ResourceLoader interface.
                • Event publication, namely to beans that implement the ApplicationListener interface, through
                the use of the ApplicationEventPublisher interface.
                • Loading of multiple (hierarchical) contexts, letting each be focused on one particular layer, such
                as the web layer of an application, through the HierarchicalBeanFactory interface.

            Internationalization using MessageSource
    !!!     The ApplicationContext interface extends an interface called MessageSource and, therefore, provides
            internationalization (“i18n”) functionality. Spring also provides the HierarchicalMessageSource
            interface, which can resolve messages hierarchically. Together, these interfaces provide the
            foundation upon which Spring effects message resolution.

            When an ApplicationContext is loaded, it automatically searches for a MessageSource bean defined in
            the context. The bean must have the name messageSource. If such a bean is found, all calls to the
            preceding methods are delegated to the message source. If no message source is found, the
            ApplicationContext attempts to find a parent containing a bean with the same name. If it does, it
            uses that bean as the MessageSource. If the ApplicationContext cannot find any source for messages,
            an empty DelegatingMessageSource is instantiated in order to be able to accept calls to the methods
            defined above.

            Because Spring’s MessageSource is based on Java’s ResourceBundle, it does not merge
            bundles with the same base name, but will only use the first bundle found.
            Subsequent message bundles with the same base name are ignored.

            As an alternative to ResourceBundleMessageSource, Spring provides a
            ReloadableResourceBundleMessageSource class. This variant supports the same
            bundle file format but is more flexible than the standard JDK based
            ResourceBundleMessageSource implementation. In particular, it allows for reading
            files from any Spring resource location (not only from the classpath) and supports
            hot reloading of bundle property files (while efficiently caching them in between).

            Standard and Custom Events
    !!!!    Event handling in the ApplicationContext is provided through the ApplicationEvent class and the
            ApplicationListener interface. If a bean that implements the ApplicationListener interface is
            deployed into the context, every time an ApplicationEvent gets published to the ApplicationContext,
            that bean is notified. Essentially, this is the standard Observer design pattern.

    !!      As of Spring 4.2, the event infrastructure has been significantly improved and
            offers an annotation-based model as well as the ability to publish any arbitrary
            event (that is, an object that does not necessarily extend from ApplicationEvent).
            When such an object is published, we wrap it in an event for you.

            The following table describes the standard events that Spring provides:
            Event                               Explanation
            ContextRefreshedEvent               Published when the ApplicationContext is initialized or refreshed
                                                (for example, by using the refresh() method on the
                                                ConfigurableApplicationContext interface). Here, “initialized” means
                                                that all beans are loaded, post-processor beans are detected and
                                                activated, singletons are pre-instantiated, and the
                                                ApplicationContext object is ready for use. As long as the context has
                                                not been closed, a refresh can be triggered multiple times, provided
                                                that the chosen ApplicationContext actually supports such “hot”
                                                refreshes. For example, XmlWebApplicationContext supports hot
                                                refreshes, but GenericApplicationContext does not.

            ContextStartedEvent                 Published when the ApplicationContext is started by using the
                                                start() method on the ConfigurableApplicationContext interface.
                                                Here, “started” means that all Lifecycle beans receive an explicit
                                                start signal. Typically, this signal is used to restart beans after an
                                                explicit stop, but it may also be used to start components that have
                                                not been configured for autostart (for example, components that
                                                have not already started on initialization).

            ContextStoppedEvent                 Published when the ApplicationContext is stopped by using the
                                                stop() method on the ConfigurableApplicationContext interface.
                                                Here, “stopped” means that all Lifecycle beans receive an explicit
                                                stop signal. A stopped context may be restarted through a start()
                                                call.

            ContextClosedEvent                  Published when the ApplicationContext is being closed by using the
                                                close() method on the ConfigurableApplicationContext interface or
                                                via a JVM shutdown hook. Here, "closed" means that all singleton
                                                beans will be destroyed. Once the context is closed, it reaches its end
                                                of life and cannot be refreshed or restarted.

            RequestHandledEvent                 A web-specific event telling all beans that an HTTP request has been
                                                serviced. This event is published after the request is complete. This
                                                event is only applicable to web applications that use Spring’s
                                                DispatcherServlet.
            ServletRequestHandledEvent          A subclass of RequestHandledEvent that adds Servlet-specific context
                                                information.

            You can also create and publish your own custom events. The following example shows a simple
            class that extends Spring’s ApplicationEvent base class:
                Dan: see "event" package

    !!!     To publish a custom ApplicationEvent, call the publishEvent() method on an
            ApplicationEventPublisher. Typically, this is done by creating a class that implements
            ApplicationEventPublisherAware and registering it as a Spring bean


            At configuration time, the Spring container detects that EmailService implements
            ApplicationEventPublisherAware and automatically calls setApplicationEventPublisher().
            In reality, the parameter passed in is the Spring container itself. You are interacting with
            the application context through its ApplicationEventPublisher interface.

    !!      To receive the custom ApplicationEvent, you can create a class that implements ApplicationListener
            and register it as a Spring bean.

            You can register as many event listeners as
    !!!!    you wish, but note that, by default, event listeners receive events synchronously. This means that
            the publishEvent() method blocks until all listeners have finished processing the event. One
            advantage of this synchronous and single-threaded approach is that, when a listener receives an
            event, it operates inside the transaction context of the publisher if a transaction context is available.
            If another strategy for event publication becomes necessary, see the javadoc for Spring’s
            ApplicationEventMulticaster interface and SimpleApplicationEventMulticaster implementation for
            configuration options

    !!!     Spring’s eventing mechanism is designed for simple communication between
            Spring beans within the same application context. However, for more
            sophisticated enterprise integration needs, the separately maintained Spring
            Integration project provides complete support for building lightweight, patternoriented, event-driven architectures that build upon the well-known Spring
            programming model.

            Annotation-based Event Listeners
            You can register an event listener on any method of a managed bean by using the @EventListener
            annotation.

            The method signature once again declares the event type to which it listens, but, this time, with a
            flexible name and without implementing a specific listener interface. The event type can also be
            narrowed through generics as long as the actual event type resolves your generic parameter in its
            implementation hierarchy.

    !!!!
            If your method should listen to several events or if you want to define it with no parameter at all,
            the event types can also be specified on the annotation itself.

            It is also possible to add additional runtime filtering by using the condition attribute of the
            annotation that defines a SpEL expression, which should match to actually invoke the method for a
            particular event.
            The following example shows how our notifier can be rewritten to be invoked only if the content
            attribute of the event is equal to my-event

            If you need to publish an event as the result of processing another event, you can change the
            method signature to return the event that should be published,
            The handleBlockedListEvent() method publishes a new ListUpdateEvent for every BlockedListEvent
            that it handles. If you need to publish several events, you can return a Collection or an array of
            events instead.

            Asynchronous Listeners
    !!!!    If you want a particular listener to process events asynchronously, you can reuse the regular @Async
            support.

            Be aware of the following limitations when using asynchronous events:
            • If an asynchronous event listener throws an Exception, it is not propagated to the caller. See
            AsyncUncaughtExceptionHandler for more details.
            • Asynchronous event listener methods cannot publish a subsequent event by returning a value.
            If you need to publish another event as the result of the processing, inject an
            ApplicationEventPublisher to publish the event manually.

            Ordering Listeners
    !!      If you need one listener to be invoked before another one, you can add the @Order annotation to the
            method declaration

            Generic Events
            You can also use generics to further define the structure of your event. Consider using an
            EntityCreatedEvent<T> where T is the type of the actual entity that got created. For example, you can
            create the following listener definition to receive only EntityCreatedEvent for a Person:
                @EventListener
                public void onPersonCreated(EntityCreatedEvent<Person> event) {
                  // ...
                }

            Convenient Access to Low-level Resources
            For optimal usage and understanding of application contexts, you should familiarize yourself with
            Spring’s Resource abstraction, as described in Resources.

             An application context is a ResourceLoader, which can be used to load Resource objects. A Resource is
             essentially a more feature rich version of the JDK java.net.URL class. In fact, the implementations of
             the Resource wrap an instance of java.net.URL, where appropriate. A Resource can obtain low-level
             resources from almost any location in a transparent fashion, including from the classpath, a
             filesystem location, anywhere describable with a standard URL, and some other variations
             If the resource location string is a simple path without any special prefixes, where those resources come
             from is specific and appropriate to the actual application context type.

             You can also expose properties of type Resource, to be used to access static resources.

    !!!!     Application Startup Tracking
             The ApplicationContext manages the lifecycle of Spring applications and provides a rich
             programming model around components. As a result, complex applications can have equally
             complex component graphs and startup phases.
             Tracking the application startup steps with specific metrics can help understand where time is
             being spent during the startup phase, but it can also be used as a way to better understand the
             context lifecycle as a whole.
             The AbstractApplicationContext (and its subclasses) is instrumented with an ApplicationStartup,
             which collects StartupStep data about various startup phases:
             • application context lifecycle (base packages scanning, config classes management)
             • beans lifecycle (instantiation, smart initialization, post processing)
             • application events processing

            Spring Framework ships with an implementation for tracking startup steps with Java Flight Recorder:
            FlightRecorderApplicationStartup. To use this variant, you must configure an instance of it to the
            ApplicationContext as soon as it’s been created.

     !!!!   ApplicationStartup is meant to be only used during application startup and for the
            core container; this is by no means a replacement for Java profilers or metrics
            libraries like Micrometer

            Deploying a Spring ApplicationContext as a Jakarta EE RAR File
            It is possible to deploy a Spring ApplicationContext as a RAR file, encapsulating the context and all
            of its required bean classes and library JARs in a Jakarta EE RAR deployment unit. This is the
            equivalent of bootstrapping a stand-alone ApplicationContext (only hosted in Jakarta EE
            environment) being able to access the Jakarta EE servers facilities. RAR deployment is a more
            natural alternative to a scenario of deploying a headless WAR file — in effect, a WAR file without
            any HTTP entry points that is used only for bootstrapping a Spring ApplicationContext in a Jakarta
            EE environment

            See the javadoc of the SpringContextResourceAdapter class for the configuration details involved in
            RAR deployment.
            For a simple deployment of a Spring ApplicationContext as a Jakarta EE RAR file:
                1. Package all application classes into a RAR file (which is a standard JAR file with a different file
                extension).
                2. Add all required library JARs into the root of the RAR archive.
                3. Add a META-INF/ra.xml deployment descriptor (as shown in the javadoc for
                SpringContextResourceAdapter) and the corresponding Spring XML bean definition file(s)
                (typically META-INF/applicationContext.xml).
                4. Drop the resulting RAR file into your application server’s deployment directory.


        2.1.16. The BeanFactory API
            The BeanFactory API provides the underlying basis for Spring’s IoC functionality

            BeanFactory and related interfaces (such as BeanFactoryAware, InitializingBean, DisposableBean) are
            important integration points for other framework components. By not requiring any annotations or
            even reflection, they allow for very efficient interaction between the container and its components.
            Application-level beans may use the same callback interfaces but typically prefer declarative
            dependency injection instead, either through annotations or through programmatic configuration.

            BeanFactory or ApplicationContext?
            This section explains the differences between the BeanFactory and ApplicationContext container
            levels and the implications on bootstrapping.

            You should use an ApplicationContext unless you have a good reason for not doing so, with
            GenericApplicationContext and its subclass AnnotationConfigApplicationContext as the common
            implementations for custom bootstrapping. These are the primary entry points to Spring’s core
            container for all common purposes: loading of configuration files, triggering a classpath scan,
            programmatically registering bean definitions and annotated classes, and (as of 5.0) registering
            functional bean definitions.

    !!!!    Because an ApplicationContext includes all the functionality of a BeanFactory, it is generally
            recommended over a plain BeanFactory, except for scenarios where full control over bean
            processing is needed


    2.2 Resources
        This chapter covers how Spring handles resources and how you can work with resources in Spring.
        It includes the following topics:
        • Introduction
        • The Resource Interface
        • Built-in Resource Implementations
        • The ResourceLoader Interface
        • The ResourcePatternResolver Interface
        • The ResourceLoaderAware Interface
        • Resources as Dependencies
        • Application Contexts and Resource Paths

        2.2.1. Introduction
            Java’s standard java.net.URL class and standard handlers for various URL prefixes, unfortunately,
            are not quite adequate enough for all access to low-level resources. For example, there is no
            standardized URL implementation that may be used to access a resource that needs to be obtained
            from the classpath or relative to a ServletContext. While it is possible to register new handlers for
            specialized URL prefixes (similar to existing handlers for prefixes such as http:), this is generally
            quite complicated, and the URL interface still lacks some desirable functionality, such as a method to
            check for the existence of the resource being pointed to.

        2.2.2. The Resource Interface
            Spring’s Resource interface located in the org.springframework.core.io. package is meant to be a
            more capable interface for abstracting access to low-level resources. The following listing provides
            an overview of the Resource interface.

            As the definition of the Resource interface shows, it extends the InputStreamSource interface.

            Some of the most important methods from the Resource interface are:
                • getInputStream(): Locates and opens the resource, returning an InputStream for reading from
                the resource. It is expected that each invocation returns a fresh InputStream. It is the
                responsibility of the caller to close the stream.
                • exists(): Returns a boolean indicating whether this resource actually exists in physical form.
                • isOpen(): Returns a boolean indicating whether this resource represents a handle with an open
                stream. If true, the InputStream cannot be read multiple times and must be read once only and
                then closed to avoid resource leaks. Returns false for all usual resource implementations, with
                the exception of InputStreamResource
                • getDescription(): Returns a description for this resource, to be used for error output when
                working with the resource. This is often the fully qualified file name or the actual URL of the
                resource.

            While the Resource interface is used a lot with Spring and by Spring, it is actually very convenient to
            use as a general utility class by itself in your own code, for access to resources, even when your
            code does not know or care about any other parts of Spring. While this couples your code to Spring,
            it really only couples it to this small set of utility classes, which serves as a more capable
            replacement for URL and can be considered equivalent to any other library you would use for this
            purpose.

        2.2.3. Built-in Resource Implementations
            Spring includes several built-in Resource implementations:
            • UrlResource
                UrlResource wraps a java.net.URL and can be used to access any object that is normally accessible
                with a URL, such as files, an HTTPS target, an FTP target, and others. All URLs have a standardized
                String representation, such that appropriate standardized prefixes are used to indicate one URL
                type from another. This includes file: for accessing filesystem paths, https: for accessing resources
                through the HTTPS protocol, ftp: for accessing resources through FTP, and others.
            • ClassPathResource
                This class represents a resource that should be obtained from the classpath. It uses either the
                thread context class loader, a given class loader, or a given class for loading resources.
            • FileSystemResource
                This is a Resource implementation for java.io.File handles. It also supports java.nio.file.Path
                handles, applying Spring’s standard String-based path transformations but performing all
                operations via the java.nio.file.Files API. For pure java.nio.path.Path based support use a
                PathResource instead. FileSystemResource supports resolution as a File and as a URL.
            • PathResource
                This is a Resource implementation for java.nio.file.Path handles, performing all operations and
                transformations via the Path API
            • ServletContextResource
                This is a Resource implementation for ServletContext resources that interprets relative paths within
                the relevant web application’s root directory
            • InputStreamResource
                An InputStreamResource is a Resource implementation for a given InputStream. It should be used only
                if no specific Resource implementation is applicable. In particular, prefer ByteArrayResource or any
                of the file-based Resource implementations where possible
            • ByteArrayResource
                This is a Resource implementation for a given byte array. It creates a ByteArrayInputStream for the
                given byte array.

        2.2.4. The ResourceLoader Interface
            The ResourceLoader interface is meant to be implemented by objects that can return (that is, load)
            Resource instances.
            All application contexts implement the ResourceLoader interface. Therefore, all application contexts
            may be used to obtain Resource instances.

!!!         When you call getResource() on a specific application context, and the location path specified
            doesn’t have a specific prefix, you get back a Resource type that is appropriate to that particular
            application context. For example, assume the following snippet of code was run against a
            ClassPathXmlApplicationContext instance:
                Resource template = ctx.getResource("some/resource/path/myTemplate.txt");
!!!         Against a ClassPathXmlApplicationContext, that code returns a ClassPathResource. If the same
            method were run against a FileSystemXmlApplicationContext instance, it would return a
            FileSystemResource. For a WebApplicationContext, it would return a ServletContextResource. It would
            similarly return appropriate objects for each context.

            On the other hand, you may also force ClassPathResource to be used, regardless of the application
            context type, by specifying the special classpath: prefix, as the following example shows:
                Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");

!!!         Similarly, you can force a UrlResource to be used by specifying any of the standard java.net.URL
            prefixes. The following examples use the file and https prefixes:
                Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");
                Resource template = ctx.getResource("https://myhost.com/resource/path/myTemplate.txt");

        2.2.5. The ResourcePatternResolver Interface
            The ResourcePatternResolver interface is an extension to the ResourceLoader interface which defines
            a strategy for resolving a location pattern (for example, an Ant-style path pattern) into Resource
            objects.

        2.2.6. The ResourceLoaderAware Interface
            The ResourceLoaderAware interface is a special callback interface which identifies components that
            expect to be provided a ResourceLoader reference

!!!         Since an ApplicationContext is a ResourceLoader, the bean could also implement the
            ApplicationContextAware interface and use the supplied application context directly to load
            resources. However, in general, it is better to use the specialized ResourceLoader interface if that is
            all you need. The code would be coupled only to the resource loading interface (which can be
            considered a utility interface) and not to the whole Spring ApplicationContext interface

            For more flexibility (including the ability to autowire fields and multiple parameter methods), consider
            using the annotation-based autowiring features. In that case, the ResourceLoader is autowired into a
            field, constructor argument, or method parameter that expects the ResourceLoader type as long as
            the field, constructor, or method in question carries the @Autowired annotation

        2.2.7. Resources as Dependencies
!!          If the bean itself is going to determine and supply the resource path through some sort of dynamic
            process, it probably makes sense for the bean to use the ResourceLoader or ResourcePatternResolver
            interface to load resources. For example, consider the loading of a template of some sort, where the
            specific resource that is needed depends on the role of the user. If the resources are static, it makes
            sense to eliminate the use of the ResourceLoader interface (or ResourcePatternResolver interface)
            completely, have the bean expose the Resource properties it needs, and expect them to be injected
            into it.






































































































































