Spring Framework Documentation Version 6.0.0

https://docs.spring.io/spring-framework/docs/6.0.0/reference/pdf/spring-framework.pdf

========================================================================================================================
Chapter 1. Spring Framework Overview

    Spring is open source. It has a large and active community that provides continuous feedback based
    on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very
    long time.

    Spring supports a wide range of application scenarios. In a large enterprise, applications often exist
    for a long time and have to run on a JDK and application server whose upgrade cycle is beyond
    developer control. Others may run as a single jar with the server embedded, possibly in a cloud
    environment. Yet others may be standalone applications (such as batch or integration workloads)
    that do not need a server

    1.1. What We Mean by "Spring"
        The term "Spring" means different things in different contexts. It can be used to refer to the Spring
        Framework project itself. Over time, other Spring projects have been
        built on top of the Spring Framework. Most often, when people say "Spring", they mean the entire
        family of projects.

        The Spring Framework is divided into modules. Applications can choose which modules they need.
        At the heart are the modules of the core container, including a configuration model and a
        dependency injection mechanism. Beyond that, the Spring Framework provides foundational
        support for different application architectures, including messaging, transactional data and
        persistence, and web. It also includes the Servlet-based Spring MVC web framework and, in
        parallel, the Spring WebFlux reactive web framework

    1.2. History of Spring and the Spring Framework
        Spring came into being in 2003 as a response to the complexity of the early J2EE specifications.
        While some consider Java EE and its modern-day successor Jakarta EE to be in competition with
        Spring, they are in fact complementary. The Spring programming model does not embrace the
        Jakarta EE platform specification; rather, it integrates with carefully selected individual
        specifications from the traditional EE umbrella:
            • Servlet API (JSR 340)
            • WebSocket API (JSR 356)
            • Concurrency Utilities (JSR 236)
            • JSON Binding API (JSR 367)
            • Bean Validation (JSR 303)
            • JPA (JSR 338)
            • JMS (JSR 914)
            • as well as JTA/JCA setups for transaction coordination, if necessary

        The Spring Framework also supports the Dependency Injection (JSR 330) and Common Annotations
        (JSR 250) specifications, which application developers may choose to use instead of the Spring specific
        mechanisms provided by the Spring Framework.

        As of Spring Framework 6.0, Spring has been upgraded to the Jakarta EE 9 level (e.g. Servlet 5.0+,
        JPA 3.0+), based on the jakarta namespace instead of the traditional javax packages. With EE 9 as
        the minimum and EE 10 supported already, Spring is prepared to provide out-of-the-box support
        for the further evolution of the Jakarta EE APIs. Spring Framework 6.0 is fully compatible with
        Tomcat 10.1, Jetty 11 and Undertow 2.3 as web servers, and also with Hibernate ORM 6.1

        Over time, the role of Java/Jakarta EE in application development has evolved. In the early days of
        J2EE and Spring, applications were created to be deployed to an application server. Today, with the
        help of Spring Boot, applications are created in a devops- and cloud-friendly way, with the Servlet
        container embedded and trivial to change. As of Spring Framework 5, a WebFlux application does
        not even use the Servlet API directly and can run on servers (such as Netty) that are not Servlet
        containers.

        Spring continues to innovate and to evolve. Beyond the Spring Framework, there are other projects,
        such as Spring Boot, Spring Security, Spring Data, Spring Cloud, Spring Batch, among others. It’s
        important to remember that each project has its own source code repository, issue tracker, and
        release cadence

    1.3. Design Philosophy
        When you learn about a framework, it’s important to know not only what it does but what
        principles it follows. Here are the guiding principles of the Spring Framework:
            • Provide choice at every level. Spring lets you defer design decisions as late as possible. For
            example, you can switch persistence providers through configuration without changing your
            code. The same is true for many other infrastructure concerns and integration with third-party
            APIs.
            • Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated about
            how things should be done. It supports a wide range of application needs with different
            perspectives.
            • Maintain strong backward compatibility. Spring’s evolution has been carefully managed to
            force few breaking changes between versions. Spring supports a carefully chosen range of JDK
            versions and third-party libraries to facilitate maintenance of applications and libraries that
            depend on Spring.
            • Care about API design. The Spring team puts a lot of thought and time into making APIs that are
            intuitive and that hold up across many versions and many years.
            • Set high standards for code quality. The Spring Framework puts a strong emphasis on
            meaningful, current, and accurate javadoc. It is one of very few projects that can claim clean
            code structure with no circular dependencies between packages

    1.5. Getting Started
        If you are just getting started with Spring, you may want to begin using the Spring Framework by
        creating a Spring Boot (https://projects.spring.io/spring-boot/)-based application. Spring Boot provides a quick (and opinionated) way to
        create a production-ready Spring-based application. It is based on the Spring Framework, favors
        convention over configuration, and is designed to get you up and running as quickly as possible.
        You can use start.spring.io to generate a basic project or follow one of the "Getting Started" guides,
        such as Getting Started Building a RESTful Web Service. As well as being easier to digest, these
        guides are very task focused, and most of them are based on Spring Boot. They also cover other
        projects from the Spring portfolio that you might want to consider when solving a particular
        problem


========================================================================================================================
Chapter 2. Core Technologies

Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough
treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage
of Spring’s Aspect-Oriented Programming (AOP) technologies

    2.1. The IoC Container

        2.1.1. Introduction to the Spring IoC Container and Beans
            This chapter covers the Spring Framework implementation of the Inversion of Control (IoC)
            principle. IoC is also known as dependency injection (DI). It is a process whereby objects define
            their dependencies (that is, the other objects they work with) only through constructor arguments,
            arguments to a factory method, or properties that are set on the object instance after it is
            constructed or returned from a factory method. The container then injects those dependencies
            when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of
            Control) of the bean itself controlling the instantiation or location of its dependencies by using
            direct construction of classes or a mechanism such as the Service Locator pattern.

            The org.springframework.beans and org.springframework.context packages are the basis for Spring
            Framework’s IoC container.
!!!!
            In Spring, the objects that form the backbone of your application and that are managed by the
            Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and
            managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your
            application. Beans, and the dependencies among them, are reflected in the configuration metadata
            used by a container.

        2.1.2. Container Overview
            The org.springframework.context.ApplicationContext interface represents the Spring IoC container
            and is responsible for instantiating, configuring, and assembling the beans. The container gets its
            instructions on what objects to instantiate, configure, and assemble by reading configuration
            metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets
            you express the objects that compose your application and the rich interdependencies between
            those objects

            Several implementations of the ApplicationContext interface are supplied with Spring. In standalone
            applications, it is common to create an instance of ClassPathXmlApplicationContext or
            FileSystemXmlApplicationContext. While XML has been the traditional format for defining
            configuration metadata, you can instruct the container to use Java annotations or code as the
            metadata

            In most application scenarios, explicit user code is not required to instantiate one or more
            instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or
            so) lines of boilerplate web descriptor XML in the web.xml file of the application typically suffices

            The following diagram shows a high-level view of how Spring works. Your application classes are
            combined with configuration metadata so that, after the ApplicationContext is created and
            initialized, you have a fully configured and executable system or application.

                business objects (POJOs) + configuration metadata => fully configured system ready for use

            This configuration metadata represents how you, as an application developer, tell the
            Spring container to instantiate, configure, and assemble the objects in your application.

            Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is
            what most of this chapter uses to convey key concepts and features of the Spring IoC container.
                (Dan : well...this sucks...i won't add XML examples, unless very important, as nowadays most people
                use Annotations...)

            For information about using other forms of metadata with the Spring container, see:
                • Annotation-based configuration: Spring 2.5 introduced support for annotation-based
                configuration metadata.
                • Java-based configuration: Starting with Spring 3.0, many features provided by the Spring
                JavaConfig project became part of the core Spring Framework. Thus, you can define beans
                external to your application classes by using Java rather than XML files. To use these new
                features, see the @Configuration, @Bean, @Import, and @DependsOn annotations.

            XML-based configuration metadata configures these beans as <bean/> elements inside a top-level <beans/>
            element. Java configuration typically uses @Bean-annotated methods within a @Configuration class.

            These bean definitions correspond to the actual objects that make up your application. Typically,
            you define service layer objects, data access objects (DAOs), presentation objects such as Struts
            Action instances, infrastructure objects such as Hibernate SessionFactories, JMS Queues, and so
            forth. Typically, one does not configure fine-grained domain objects in the container, because it is
            usually the responsibility of DAOs and business logic to create and load domain objects

            Instantiating a Container
            The location path or paths supplied to an ApplicationContext constructor are resource strings that
            let the container load configuration metadata from a variety of external resources, such as the local
            file system, the Java CLASSPATH, and so on.

                ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

            Composing XML-based Configuration Metadata
            It can be useful to have bean definitions span multiple XML files. Often, each individual XML
            configuration file represents a logical layer or module in your architecture

            Using the Container
            The ApplicationContext is the interface for an advanced factory capable of maintaining a registry of
            different beans and their dependencies. By using the method T getBean(String name, Class<T>
            requiredType), you can retrieve instances of your beans

            You can then use getBean to retrieve instances of your beans. The ApplicationContext interface has a
            few other methods for retrieving beans, but, ideally, your application code should never use them.
            Indeed, your application code should have no calls to the getBean() method at all and thus have no
            dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides
            dependency injection for various web framework components such as controllers and JSF-managed
            beans, letting you declare a dependency on a specific bean through metadata (such as an
            autowiring annotation).

        2.1.3. Bean Overview
            A Spring IoC container manages one or more beans. These beans are created with the configuration
            metadata that you supply to the container (for example, in the form of XML <bean/> definitions).
            Within the container itself, these bean definitions are represented as BeanDefinition objects, which
            contain (among other information) the following metadata:
                • A package-qualified class name: typically, the actual implementation class of the bean
                • Bean behavioral configuration elements, which state how the bean should behave in the
                container (scope, lifecycle callbacks, and so forth).
                • References to other beans that are needed for the bean to do its work. These references are also
                called collaborators or dependencies.
                • Other configuration settings to set in the newly created object — for example, the size limit of
                the pool or the number of connections to use in a bean that manages a connection pool.

            ApplicationContext implementations also permit the registration of existing objects that are created
            outside the container (by users). This is done by accessing the ApplicationContext’s BeanFactory
            through the getBeanFactory() method, which returns the DefaultListableBeanFactory
            implementation. DefaultListableBeanFactory supports this registration through the
            registerSingleton(..) and registerBeanDefinition(..) methods. However, typical applications
            work solely with beans defined through regular bean definition metadata.
!!!
            While overriding existing metadata and existing singleton instances is supported to some degree, the
            registration of new beans at runtime (concurrently with live access to the factory) is not officially
            supported and may lead to concurrent access exceptions, inconsistent state in the
            bean container, or both.

            Naming Beans
            Every bean has one or more identifiers. These identifiers must be unique within the container that
            hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the
            extra ones can be considered aliases.

            In XML-based configuration metadata, you use the id attribute, the name attribute, or both to specify
             the bean identifiers. The id attribute lets you specify exactly one id. Conventionally, these names
             are alphanumeric ('myBean', 'someService', etc.), but they can contain special characters as well. If
             you want to introduce other aliases for the bean, you can also specify them in the name attribute,
             separated by a comma (,), semicolon (;), or white space.

            You are not required to supply a name or an id for a bean. If you do not supply a name or id explicitly,
            the container generates a unique name for that bean. However, if you want to refer to that bean by
            name, through the use of the ref element or a Service Locator style lookup, you must provide a name.

                Bean Naming Conventions
                The convention is to use the standard Java convention for instance field names when naming
                beans. That is, bean names start with a lowercase letter and are camel-cased from there.
                Examples of such names include accountManager, accountService, userDao, loginController, and
                so forth.

            Aliasing a Bean outside the Bean Definition
            In a bean definition itself, you can supply more than one name for the bean, by using a
            combination of up to one name specified by the id attribute and any number of other names in the
            name attribute. These names can be equivalent aliases to the same bean and are useful for some
            situations, such as letting each component in an application refer to a common dependency by
            using a bean name that is specific to that component itself.
            In XML-based configuration metadata, you can use the <alias/> element to accomplish this

            For example, the configuration metadata for subsystem A may refer to a DataSource by the name of
            subsystemA-dataSource. The configuration metadata for subsystem B may refer to a DataSource by
            the name of subsystemB-dataSource. When composing the main application that uses both these
            subsystems, the main application refers to the DataSource by the name of myApp-dataSource. To have
            all three names refer to the same object, you can add the following alias definitions to the
            configuration metadata:
                <alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
                <alias name="myApp-dataSource" alias="subsystemB-dataSource"/>

            If you use Java configuration, the @Bean annotation can be used to provide aliases. See Using
            the @Bean Annotation for details.

            Instantiating Beans
            A bean definition is essentially a recipe for creating one or more objects. The container looks at the
            recipe for a named bean when asked and uses the configuration metadata encapsulated by that
            bean definition to create (or acquire) an actual object.

            You can use the Class property in one of two ways:
            • Typically, to specify the bean class to be constructed in the case where the container itself
            directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java
            code with the new operator.
            • To specify the actual class containing the static factory method that is invoked to create the
            object, in the less common case where the container invokes a static factory method on a class
            to create the bean. The object type returned from the invocation of the static factory method
            may be the same class or another class entirely.

            Instantiation with a Constructor
            When you create a bean by the constructor approach, all normal classes are usable by and
            compatible with Spring. That is, the class being developed does not need to implement any specific
            interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice.
            However, depending on what type of IoC you use for that specific bean, you may need a default
            (empty) constructor.

            The Spring IoC container can manage virtually any class you want it to manage. It is not limited to
            managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (noargument) constructor and appropriate setters and getters modeled after the properties in the
            container. You can also have more exotic non-bean-style classes in your container. If, for example,
            you need to use a legacy connection pool that absolutely does not adhere to the JavaBean
            specification, Spring can manage it as well.

            Instantiation with a Static Factory Method
            When defining a bean that you create with a static factory method, use the class attribute to specify
            the class that contains the static factory method and an attribute named factory-method to specify
            the name of the factory method itself. You should be able to call this method (with optional
            arguments, as described later) and return a live object, which subsequently is treated as if it had
            been created through a constructor. One use for such a bean definition is to call static factories in
            legacy code

            In Spring documentation, "factory bean" refers to a bean that is configured in the
            Spring container and that creates objects through an instance or static factory
            method. By contrast, FactoryBean (notice the capitalization) refers to a Spring specific FactoryBean implementation class.

        2.1.4. Dependencies
            A typical enterprise application does not consist of a single object (or bean in the Spring parlance).
            Even the simplest application has a few objects that work together to present what the end-user
            sees as a coherent application. This next section explains how you go from defining a number of
            bean definitions that stand alone to a fully realized application where objects collaborate to achieve
            a goal.

!!!         Dependency Injection
            Dependency injection (DI) is a process whereby objects define their dependencies (that is, the other
            objects with which they work) only through constructor arguments, arguments to a factory method,
            or properties that are set on the object instance after it is constructed or returned from a factory
            method. The container then injects those dependencies when it creates the bean. This process is
            fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the
            instantiation or location of its dependencies on its own by using direct construction of classes or the
            Service Locator pattern.

            Code is cleaner with the DI principle, and decoupling is more effective when objects are provided
            with their dependencies. The object does not look up its dependencies and does not know the
            location or class of the dependencies. As a result, your classes become easier to test, particularly
            when the dependencies are on interfaces or abstract base classes, which allow for stub or mock
            implementations to be used in unit tests

            DI exists in two major variants: Constructor-based dependency injection and Setter-based
            dependency injection.

            Constructor-based Dependency Injection
            Constructor-based DI is accomplished by the container invoking a constructor with a number of
            arguments, each representing a dependency. Calling a static factory method with specific
            arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a
            constructor and to a static factory method similarly.

            Constructor Argument Resolution
            Constructor argument resolution matching occurs by using the argument’s type. If no potential
            ambiguity exists in the constructor arguments of a bean definition, the order in which the
            constructor arguments are defined in a bean definition is the order in which those arguments are
            supplied to the appropriate constructor when the bean is being instantiated

            Setter-based Dependency Injection
            Setter-based DI is accomplished by the container calling setter methods on your beans after
            invoking a no-argument constructor or a no-argument static factory method to instantiate your bean.

            The ApplicationContext supports constructor-based and setter-based DI for the beans it manages. It
            also supports setter-based DI after some dependencies have already been injected through the
            constructor approach. You configure the dependencies in the form of a BeanDefinition, which you
            use in conjunction with PropertyEditor instances to convert properties from one format to another.
            However, most Spring users do not work with these classes directly (that is, programmatically) but
            rather with XML bean definitions, annotated components (that is, classes annotated with @Component,
            @Controller, and so forth), or @Bean methods in Java-based @Configuration classes

!!!!        The Spring team generally advocates constructor injection, as it lets you implement
            application components as immutable objects and ensures that required dependencies are
            not null. Furthermore, constructor-injected components are always returned to the client
            (calling) code in a fully initialized state. As a side note, a large number of constructor
            arguments is a bad code smell, implying that the class likely has too many responsibilities and
            should be refactored to better address proper separation of concerns.

!!          Setter injection should primarily only be used for optional dependencies that can be assigned
            reasonable default values within the class. Otherwise, not-null checks must be performed
            everywhere the code uses the dependency. One benefit of setter injection is that setter
            methods make objects of that class amenable to reconfiguration or re-injection later.
            Management through JMX MBeans is therefore a compelling use case for setter injection.

            Use the DI style that makes the most sense for a particular class. Sometimes, when dealing
            with third-party classes for which you do not have the source, the choice is made for you. For
            example, if a third-party class does not expose any setter methods, then constructor injection
            may be the only available form of DI.

!!!         Dependency Resolution Process
            The container performs bean dependency resolution as follows:
            • The ApplicationContext is created and initialized with configuration metadata that describes all
            the beans. Configuration metadata can be specified by XML, Java code, or annotations.
            • For each bean, its dependencies are expressed in the form of properties, constructor arguments,
            or arguments to the static-factory method (if you use that instead of a normal constructor).
            These dependencies are provided to the bean, when the bean is actually created.
            • Each property or constructor argument is an actual definition of the value to set, or a reference
            to another bean in the container.
            • Each property or constructor argument that is a value is converted from its specified format to
            the actual type of that property or constructor argument. By default, Spring can convert a value
            supplied in string format to all built-in types, such as int, long, String, boolean, and so forth.
            The Spring container validates the configuration of each bean as the container is created. However,
            the bean properties themselves are not set until the bean is actually created. Beans that are
            singleton-scoped and set to be pre-instantiated (the default) are created when the container is
            created. Scopes are defined in Bean Scopes. Otherwise, the bean is created only when it is
            requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s
            dependencies and its dependencies' dependencies (and so on) are created and assigned.

            Circular dependencies
            If you configure beans for
            classes A and B to be injected into each other, the Spring IoC container detects this circular
            reference at runtime, and throws a BeanCurrentlyInCreationException.
            One possible solution is to edit the source code of some classes to be configured by setters
            rather than constructors. Alternatively, avoid constructor injection and use setter injection
            only. In other words, although it is not recommended, you can configure circular
            dependencies with setter injection.
            Unlike the typical case (with no circular dependencies), a circular dependency between bean
            A and bean B forces one of the beans to be injected into the other prior to being fully
            initialized itself (a classic chicken-and-egg scenario).

            You can generally trust Spring to do the right thing. It detects configuration problems, such as
            references to non-existent beans and circular dependencies, at container load-time. Spring sets
            properties and resolves dependencies as late as possible, when the bean is actually created. This
            means that a Spring container that has loaded correctly can later generate an exception when you
            request an object if there is a problem creating that object or one of its dependencies — for
            example, the bean throws an exception as a result of a missing or invalid property. This potentially
            delayed visibility of some configuration issues is why ApplicationContext implementations by
            default pre-instantiate singleton beans. At the cost of some upfront time and memory to create
            these beans before they are actually needed, you discover configuration issues when the
            ApplicationContext is created, not later. You can still override this default behavior so that singleton
            beans initialize lazily, rather than being eagerly pre-instantiated.

            Strongly-typed collection
            Thanks to Java’s support for generic types, you can use strongly typed collections. That is, it is
            possible to declare a Collection type such that it can only contain (for example) String elements. If
            you use Spring to dependency-inject a strongly-typed Collection into a bean, you can take
            advantage of Spring’s type-conversion support such that the elements of your strongly-typed
            Collection instances are converted to the appropriate type prior to being added to the Collection

            Null and Empty String Values
            Spring treats empty arguments for properties and the like as empty Strings.
            The <null/> element handles null values.        (Dan: this is for XML based configurations)

!!          Lazy-initialized Beans
            By default, ApplicationContext implementations eagerly create and configure all singleton beans as
            part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the
            configuration or surrounding environment are discovered immediately, as opposed to hours or
            even days later. When this behavior is not desirable, you can prevent pre-instantiation of a
            singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells
            the IoC container to create a bean instance when it is first requested, rather than at startup.

            However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazyinitialized, the
            ApplicationContext creates the lazy-initialized bean at startup, because it must
            satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean
            elsewhere that is not lazy-initialized.

            Autowiring Collaborators
            The Spring container can autowire relationships between collaborating beans. You can let Spring
            resolve collaborators (other beans) automatically for your bean by inspecting the contents of the
            ApplicationContext. Autowiring has the following advantages:
                • Autowiring can significantly reduce the need to specify properties or constructor arguments.
                (Other mechanisms such as a bean template discussed elsewhere in this chapter are also
                valuable in this regard.)
                • Autowiring can update a configuration as your objects evolve. For example, if you need to add a
                dependency to a class, that dependency can be satisfied automatically without you needing to
                modify the configuration. Thus autowiring can be especially useful during development,
                without negating the option of switching to explicit wiring when the code base becomes more
                stable.

            The following table describes the four autowiring modes:
                no -> (Default) No autowiring. Bean references must be defined by ref elements.
                Changing the default setting is not recommended for larger deployments,
                because specifying collaborators explicitly gives greater control and clarity. To
                some extent, it documents the structure of a system.

                byName -> Autowiring by property name. Spring looks for a bean with the same name as
                the property that needs to be autowired. For example, if a bean definition is
                set to autowire by name and it contains a master property (that is, it has a
                setMaster(..) method), Spring looks for a bean definition named master and
                uses it to set the property.

                byType -> Lets a property be autowired if exactly one bean of the property type exists in
                the container. If more than one exists, a fatal exception is thrown, which
                indicates that you may not use byType autowiring for that bean. If there are no
                matching beans, nothing happens (the property is not set).

                constructor ->  Analogous to byType but applies to constructor arguments. If there is not
                exactly one bean of the constructor argument type in the container, a fatal
                error is raised.

            Consider the limitations and disadvantages of autowiring:
                • Explicit dependencies in property and constructor-arg settings always override autowiring. You
                cannot autowire simple properties such as primitives, Strings, and Classes (and arrays of such
                simple properties). This limitation is by-design.
                • Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is
                careful to avoid guessing in case of ambiguity that might have unexpected results. The
                relationships between your Spring-managed objects are no longer documented explicitly.
                • Wiring information may not be available to tools that may generate documentation from a
                Spring container.
                • Multiple bean definitions within the container may match the type specified by the setter
                method or constructor argument to be autowired. For arrays, collections, or Map instances, this is
                not necessarily a problem. However, for dependencies that expect a single value, this ambiguity
                is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.

            Method Injection
            In most application scenarios, most beans in the container are singletons. When a singleton bean
            needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with
            another non-singleton bean, you typically handle the dependency by defining one bean as a
            property of the other. A problem arises when the bean lifecycles are different. Suppose singleton
            bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A.
            The container creates the singleton bean A only once, and thus only gets one opportunity to set the
            properties. The container cannot provide bean A with a new instance of bean B every time one is
            needed.
            A solution is to forego some inversion of control. You can make bean A aware of the container by
            implementing the ApplicationContextAware interface, and by making a getBean("B") call to the
            container ask for (a typically new) bean B instance every time bean A needs it

            Lookup Method Injection
            Lookup method injection is the ability of the container to override methods on container-managed
            beans and return the lookup result for another named bean in the container. The lookup typically
            involves a prototype bean, as in the scenario described in the preceding section. The Spring
            Framework implements this method injection by using bytecode generation from the CGLIB library
            to dynamically generate a subclass that overrides the method.

            Alternatively, within the annotation-based component model, you can declare a lookup method
            through the @Lookup annotation, as the following example shows:

                (Dan: A method annotated with @Lookup tells Spring to return an instance of the method's return type
                        when we invoke it. Essentially, Spring will override our annotated method and use our method's
                        return type and parameters as arguments to BeanFactory#getBean.

                      @Lookup is useful for:
                        Injecting a prototype-scoped bean into a singleton bean (similar to Provider)
                        Injecting dependencies procedurally)

            Arbitrary Method Replacement
            A less useful form of method injection than lookup method injection is the ability to replace
            arbitrary methods in a managed bean with another method implementation. You can safely skip
            the rest of this section until you actually need this functionality


        2.1.5. Bean Scopes
            When you create a bean definition, you create a recipe for creating actual instances of the class
            defined by that bean definition. The idea that a bean definition is a recipe is important, because it
            means that, as with a class, you can create many object instances from a single recipe.

!!!!        Beans can be defined to be deployed in one of a number of scopes. The Spring Framework supports
            six scopes, four of which are available only if you use a web-aware ApplicationContext. You can also
            create a custom scope.

!!!!        The following table describes the supported scopes:
            Scope                   Description
            singleton               (Default) Scopes a single bean definition to a single object instance for each
                                    Spring IoC container.
            prototype               Scopes a single bean definition to any number of object instances
                                (Dan:  A new object is created each time it is injected/looked up)
            request                 Scopes a single bean definition to the lifecycle of a single HTTP request. That
                                    is, each HTTP request has its own instance of a bean created off the back of a
                                    single bean definition. Only valid in the context of a web-aware Spring
                                    ApplicationContext.
            session                 Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid
                                    in the context of a web-aware Spring ApplicationContext.
            application             Scopes a single bean definition to the lifecycle of a ServletContext. Only valid
                                    in the context of a web-aware Spring ApplicationContext.
            websocket               Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the
                                    context of a web-aware Spring ApplicationContext.

!!!         The Singleton Scope
            Only one shared instance of a singleton bean is managed, and all requests for beans with an ID or
            IDs that match that bean definition result in that one specific bean instance being returned by the
            Spring container.
            To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring
            IoC container creates exactly one instance of the object defined by that bean definition. This single
            instance is stored in a cache of such singleton beans, and all subsequent requests and references
            for that named bean return the cached object.

            Spring’s concept of a singleton bean differs from the singleton pattern as defined in the Gang of
            Four (GoF) patterns book. The GoF singleton hard-codes the scope of an object such that one and
            only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton
            is best described as being per-container and per-bean. This means that, if you define one bean for a
            particular class in a single Spring container, the Spring container creates one and only one instance
            of the class defined by that bean definition.

!!!!!!      The singleton scope is the default scope in Spring.

            The Prototype Scope
            The non-singleton prototype scope of bean deployment results in the creation of a new bean
            instance every time a request for that specific bean is made. That is, the bean is injected into
            another bean or you request it through a getBean() method call on the container.

!!!!!!      As a rule, you should use the prototype scope for all stateful beans and the singleton scope for
            stateless beans.

!!!!        In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean
            The container instantiates, configures, and otherwise assembles a prototype object and hands it to
            the client, with no further record of that prototype instance. Thus, although initialization lifecycle
            callback methods are called on all objects regardless of scope, in the case of prototypes, configured
            destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped
            objects and release expensive resources that the prototype beans hold. To get the Spring container
            to release resources held by prototype-scoped beans, try using a custom bean post-processor, which
            holds a reference to beans that need to be cleaned up.

            Singleton Beans with Prototype-bean Dependencies
            When you use singleton-scoped beans with dependencies on prototype beans, be aware that
            dependencies are resolved at instantiation time. Thus, if you dependency-inject a prototype-scoped
            bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency injected into
            the singleton bean. The prototype instance is the sole instance that is ever supplied to
            the singleton-scoped bean.
            However, suppose you want the singleton-scoped bean to acquire a new instance of the prototypescoped bean
            repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into
            your singleton bean, because that injection occurs only once, when the Spring container
            instantiates the singleton bean and resolves and injects its dependencies. If you need a new
            instance of a prototype bean at runtime more than once, see Method Injection.

            Request, Session, Application, and WebSocket Scopes
            The request, session, application, and websocket scopes are available only if you use a web-aware
            Spring ApplicationContext implementation (such as XmlWebApplicationContext). If you use these
            scopes with regular Spring IoC containers, such as the ClassPathXmlApplicationContext, an
            IllegalStateException that complains about an unknown bean scope is thrown.

            Initial Web Configuration
            To support the scoping of beans at the request, session, application, and websocket levels
            (webscoped beans), some minor initial configuration is required before you define your beans. (This
            initial setup is not required for the standard scopes: singleton and prototype.)
            How you accomplish this initial setup depends on your particular Servlet environment.
            If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by
            the Spring DispatcherServlet, no special setup is necessary. DispatcherServlet already exposes all
            relevant state.
            If you use a Servlet web container, with requests processed outside of Spring’s DispatcherServlet
            (for example, when using JSF or Struts), you need to register the
            org.springframework.web.context.request.RequestContextListener ServletRequestListener. This can
            be done programmatically by using the WebApplicationInitializer interface. Alternatively, add the
            following declaration to your web application’s web.xml file:
                <web-app>
                  ...
                  <listener>
                    <listener-class>
                        org.springframework.web.context.request.RequestContextListener
                    </listener-class>
                  </listener>
                  ...
                </web-app>

            Alternatively, if there are issues with your listener setup, consider using Spring’s
            RequestContextFilter. The filter mapping depends on the surrounding web application
            configuration, so you have to change it as appropriate. The following listing shows the filter part of
            a web application:
                <web-app>
                  ...
                  <filter>
                    <filter-name>requestContextFilter</filter-name>
                    <filter-class>org.springframework.web.filter.RequestContextFilter</filterclass>
                  </filter>
                  <filter-mapping>
                    <filter-name>requestContextFilter</filter-name>
                    <url-pattern>/*</url-pattern>
                  </filter-mapping>
                  ...
                </web-app>

!!!!!!!!    DispatcherServlet, RequestContextListener, and RequestContextFilter all do exactly the same thing,
            namely bind the HTTP request object to the Thread that is servicing that request. This makes beans
            that are request- and session-scoped available further down the call chain

            Request scope
            Consider the following XML configuration for a bean definition:
            <bean id="loginAction" class="com.something.LoginAction" scope="request"/>
            The Spring container creates a new instance of the LoginAction bean by using the loginAction bean
            definition for each and every HTTP request. That is, the loginAction bean is scoped at the HTTP
            request level. You can change the internal state of the instance that is created as much as you want,
            because other instances created from the same loginAction bean definition do not see these
            changes in state. They are particular to an individual request.
!!!         When the request completes processing, the bean that is scoped to the request is discarded

!!!         When using annotation-driven components or Java configuration, the @RequestScope annotation can
            be used to assign a component to the request scope.

            Session Scope
            Consider the following XML configuration for a bean definition:
            <bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
            The Spring container creates a new instance of the UserPreferences bean by using the
            userPreferences bean definition for the lifetime of a single HTTP Session. In other words, the
            userPreferences bean is effectively scoped at the HTTP Session level. As with request-scoped beans,
            you can change the internal state of the instance that is created as much as you want, knowing that
            other HTTP Session instances that are also using instances created from the same userPreferences
            bean definition do not see these changes in state, because they are particular to an individual HTTP
            Session.
!!!!        When the HTTP Session is eventually discarded, the bean that is scoped to that particular HTTP Session is
            also discarded.

!!!         When using annotation-driven components or Java configuration, you can use the @SessionScope
            annotation to assign a component to the session scope

            Application Scope
            Consider the following XML configuration for a bean definition:
            <bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
            The Spring container creates a new instance of the AppPreferences bean by using the appPreferences
            bean definition once for the entire web application. That is, the appPreferences bean is scoped at the
            ServletContext level and stored as a regular ServletContext attribute.

!!          This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton
            per ServletContext, not per Spring ApplicationContext (for which there may be several in any given web
            application), and it is actually exposed and therefore visible as a ServletContext attribute.

!!!         When using annotation-driven components or Java configuration, you can use the
            @ApplicationScope annotation to assign a component to the application scope.


!!!!!       Scoped Beans as Dependencies
            The Spring IoC container manages not only the instantiation of your objects (beans), but also the
            wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request scoped
            bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in
            place of the scoped bean. That is, you need to inject a proxy object that exposes the same public
            interface as the scoped object but that can also retrieve the real target object from the relevant
            scope (such as an HTTP request) and delegate method calls onto the real object.

                  <!-- an HTTP Session-scoped bean exposed as a proxy -->
                  <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
                    <!-- instructs the container to proxy the surrounding bean -->
                    <aop:scoped-proxy/> ①
                  </bean>
                  <!-- a singleton-scoped bean injected with a proxy to the above bean -->
                  <bean id="userService" class="com.something.SimpleUserService">
                    <!-- a reference to the proxied userPreferences bean -->
                    <property name="userPreferences" ref="userPreferences"/>
                  </bean>

            To create such a proxy, you insert a child <aop:scoped-proxy/> element into a scoped bean definition. Why do
            definitions of beans scoped at the request, session and custom-scope levels require the <aop:scopedproxy/>
            element? Consider the following singleton bean definition and contrast it with what you
            need to define for the aforementioned scopes (note that the following userPreferences bean
            definition as it stands is incomplete):
                <bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
                <bean id="userManager" class="com.something.UserManager">
                  <property name="userPreferences" ref="userPreferences"/>
                </bean>

!!!         In the preceding example, the singleton bean (userManager) is injected with a reference to the HTTP
            Session-scoped bean (userPreferences). The salient point here is that the userManager bean is a
            singleton: it is instantiated exactly once per container, and its dependencies (in this case only one,
            the userPreferences bean) are also injected only once. This means that the userManager bean
            operates only on the exact same userPreferences object (that is, the one with which it was originally
            injected).

            This is not the behavior you want when injecting a shorter-lived scoped bean into a longer-lived
            scoped bean (for example, injecting an HTTP Session-scoped collaborating bean as a dependency
            into singleton bean). Rather, you need a single userManager object, and, for the lifetime of an HTTP
            Session, you need a userPreferences object that is specific to the HTTP Session. Thus, the container
            creates an object that exposes the exact same public interface as the UserPreferences class (ideally
            an object that is a UserPreferences instance), which can fetch the real UserPreferences object from
            the scoping mechanism (HTTP request, Session, and so forth). The container injects this proxy
            object into the userManager bean, which is unaware that this UserPreferences reference is a proxy. In
            this example, when a UserManager instance invokes a method on the dependency-injected
            UserPreferences object, it is actually invoking a method on the proxy. The proxy then fetches the
            real UserPreferences object from (in this case) the HTTP Session and delegates the method
            invocation onto the retrieved real UserPreferences object.

            Thus, you need the following (correct and complete) configuration when injecting request- and
            session-scoped beans into collaborating objects, as the following example shows:
                <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
                  <aop:scoped-proxy/>
                </bean>
                <bean id="userManager" class="com.something.UserManager">
                  <property name="userPreferences" ref="userPreferences"/>
                </bean>


            Choosing the Type of Proxy to Create
            By default, when the Spring container creates a proxy for a bean that is marked up with the
            <aop:scoped-proxy/> element, a CGLIB-based class proxy is created.

            CGLIB proxies intercept only public method calls! Do not call non-public methods
            on such a proxy. They are not delegated to the actual scoped target object

!!          Custom Scopes
            The bean scoping mechanism is extensible. You can define your own scopes or even redefine
            existing scopes, although the latter is considered bad practice and you cannot override the built-in
            singleton and prototype scopes.

            Creating a Custom Scope
!!          To integrate your custom scopes into the Spring container, you need to implement the
            org.springframework.beans.factory.config.Scope interface, which is described in this section. For an
            idea of how to implement your own scopes, see the Scope implementations that are supplied with
            the Spring Framework itself and the Scope javadoc, which explains the methods you need to
            implement in more detail

                (Dan: i did not add here more details about the subject, as this is not something that one comes across often)


        2.1.6. Customizing the Nature of a Bean
            The Spring Framework provides a number of interfaces you can use to customize the nature of a
            bean. This section groups them as follows:
                • Lifecycle Callbacks
                • ApplicationContextAware and BeanNameAware
                • Other Aware Interfaces

            Lifecycle Callbacks
    !!!!    To interact with the container’s management of the bean lifecycle, you can implement the Spring
            InitializingBean and DisposableBean interfaces. The container calls afterPropertiesSet() for the
            former and destroy() for the latter to let the bean perform certain actions upon initialization and
            destruction of your beans.

                The JSR-250 @PostConstruct and @PreDestroy annotations are generally considered
                best practice for receiving lifecycle callbacks in a modern Spring application. Using
                these annotations means that your beans are not coupled to Spring-specific
                interfaces. For details, see Using @PostConstruct and @PreDestroy.
                If you do not want to use the JSR-250 annotations but you still want to remove
                coupling, consider init-method and destroy-method bean definition metadata.

            Internally, the Spring Framework uses BeanPostProcessor implementations to process any callback
            interfaces it can find and call the appropriate methods. If you need custom features or other
            lifecycle behavior Spring does not by default offer, you can implement a BeanPostProcessor yourself

            In addition to the initialization and destruction callbacks, Spring-managed objects may also
            implement the Lifecycle interface so that those objects can participate in the startup and shutdown
            process, as driven by the container’s own lifecycle.

    !!!     We recommend that you do not use the InitializingBean interface, because it unnecessarily couples
            the code to Spring. Alternatively, we suggest using the @PostConstruct annotation or specifying a
            POJO initialization method. In the case of XML-based configuration metadata, you can use the initmethod
            attribute to specify the name of the method that has a void no-argument signature. With
            Java configuration, you can use the initMethod attribute of @Bean

            Consider the following example:
                <bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
                Java
                public class ExampleBean {
                  public void init() {
                  // do some initialization work
                  }
                }

            The preceding example has almost exactly the same effect as the following example (which consists of two listings):
                <bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
                Java
                public class AnotherExampleBean implements InitializingBean {
                  @Override
                  public void afterPropertiesSet() {
                  // do some initialization work
                  }
                }

    !!      However, the first of the two preceding examples does not couple the code to Spring.

            We recommend that you do not use the DisposableBean callback interface, because it unnecessarily
            couples the code to Spring. Alternatively, we suggest using the @PreDestroy annotation or specifying
            a generic method that is supported by bean definitions. With XML-based configuration metadata,
            you can use the destroy-method attribute on the <bean/>. With Java configuration, you can use the
            destroyMethod attribute of @Bean.

            You can assign the destroy-method attribute of a <bean> element a special (inferred)
            value, which instructs Spring to automatically detect a public close or shutdown
            method on the specific bean class. (Any class that implements
            java.lang.AutoCloseable or java.io.Closeable would therefore match.) You can
            also set this special (inferred) value on the default-destroy-method attribute of a
            <beans> element to apply this behavior to an entire set of beans (see Default
            Initialization and Destroy Methods). Note that this is the default behavior with Java configuration.

            Default Initialization and Destroy Methods
    !!!!    When you write initialization and destroy method callbacks that do not use the Spring-specific
            InitializingBean and DisposableBean callback interfaces, you typically write methods with names
            such as init(), initialize(), dispose(), and so on. Ideally, the names of such lifecycle callback
            methods are standardized across a project so that all developers use the same method names and
            ensure consistency. You can configure the Spring container to “look” for named initialization and destroy
            callback method names on every bean. This means that you, as an application developer, can write your
            application classes and use an initialization callback called init(), without having to configure an
            init-method="init" attribute with each bean definition. The Spring IoC container calls that method
            when the bean is created (and in accordance with the standard lifecycle callback contract described
            previously). This feature also enforces a consistent naming convention for initialization and destroy
            method callbacks.
            Suppose that your initialization callback methods are named init() and your destroy callback
            methods are named destroy(). Your class then resembles the class in the following example:

                public class DefaultBlogService implements BlogService {
                  private BlogDao blogDao;
                  public void setBlogDao(BlogDao blogDao) {
                    this.blogDao = blogDao;
                  }
                  // this is (unsurprisingly) the initialization callback method
                  public void init() {
                    if (this.blogDao == null) {
                        throw new IllegalStateException("The [blogDao] property must be set.");
                    }
                  }
                }

                <beans default-init-method="init">
                  <bean id="blogService" class="com.something.DefaultBlogService">
                  <property name="blogDao" ref="blogDao" />
                  </bean>
                </beans>

            The presence of the default-init-method attribute on the top-level <beans/> element attribute causes
            the Spring IoC container to recognize a method called init on the bean class as the initialization
            method callback. When a bean is created and assembled, if the bean class has such a method, it is
            invoked at the appropriate time.
            You can configure destroy method callbacks similarly (in XML, that is) by using the defaultdestroy-method
            attribute on the top-level <beans/> element.

            The Spring container guarantees that a configured initialization callback is called immediately after
            a bean is supplied with all dependencies. Thus, the initialization callback is called on the raw bean
            reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target
            bean is fully created first and then an AOP proxy (for example) with its interceptor chain is applied.
            If the target bean and the proxy are defined separately, your code can even interact with the raw
            target bean, bypassing the proxy. Hence, it would be inconsistent to apply the interceptors to the
            init method, because doing so would couple the lifecycle of the target bean to its proxy or
            interceptors and leave strange semantics when your code interacts directly with the raw target
            bean.

            Combining Lifecycle Mechanisms
            As of Spring 2.5, you have three options for controlling bean lifecycle behavior:
                • The InitializingBean and DisposableBean callback interfaces
                • Custom init() and destroy() methods
                • The @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control
                a given bean

            Multiple lifecycle mechanisms configured for the same bean, with different initialization methods,
            are called as follows:
                1. Methods annotated with @PostConstruct
                2. afterPropertiesSet() as defined by the InitializingBean callback interface
                3. A custom configured init() method
            Destroy methods are called in the same order:
                1. Methods annotated with @PreDestroy
                2. destroy() as defined by the DisposableBean callback interface
                3. A custom configured destroy() method

            Startup and Shutdown Callbacks
            The Lifecycle interface defines the essential methods for any object that has its own lifecycle
            requirements (such as starting and stopping some background process):
                public interface Lifecycle {
                  void start();
                  void stop();
                  boolean isRunning();
                }

            Any Spring-managed object may implement the Lifecycle interface. Then, when the
            ApplicationContext itself receives start and stop signals (for example, for a stop/restart scenario at
            runtime), it cascades those calls to all Lifecycle implementations defined within that context.

            The order of startup and shutdown invocations can be important. If a “depends-on” relationship
            exists between any two objects, the dependent side starts after its dependency, and it stops before
            its dependency. However, at times, the direct dependencies are unknown. You may only know that
            objects of a certain type should start prior to objects of another type. In those cases, the
            SmartLifecycle interface defines another option, namely the getPhase() method as defined on its
            super-interface, Phased.

            When starting, the objects with the lowest phase start first. When stopping, the reverse order is
            followed. Therefore, an object that implements SmartLifecycle and whose getPhase() method
            returns Integer.MIN_VALUE would be among the first to start and the last to stop. At the other end of
            the spectrum, a phase value of Integer.MAX_VALUE would indicate that the object should be started
            last and stopped first (likely because it depends on other processes to be running). When
            considering the phase value, it is also important to know that the default phase for any “normal”
            Lifecycle object that does not implement SmartLifecycle is 0.


            Shutting Down the Spring IoC Container Gracefully in Non-Web Applications
    !!!!    This section applies only to non-web applications. Spring’s web-based
            ApplicationContext implementations already have code in place to gracefully shut
            down the Spring IoC container when the relevant web application is shut down

            If you use Spring’s IoC container in a non-web application environment (for example, in a rich
            client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful
            shutdown and calls the relevant destroy methods on your singleton beans so that all resources are
            released. You must still configure and implement these destroy callbacks correctly

            Thus, beans can programmatically manipulate the ApplicationContext that created them, through
            the ApplicationContext interface or by casting the reference to a known subclass of this interface
            (such as ConfigurableApplicationContext, which exposes additional functionality). One use would be
            the programmatic retrieval of other beans. Sometimes this capability is useful. However, in general,
            you should avoid it, because it couples the code to Spring and does not follow the Inversion of
            Control style, where collaborators are provided to beans as properties. Other methods of the
            ApplicationContext provide access to file resources, publishing application events, and accessing a
            MessageSource. These additional features are described in Additional Capabilities of the
            ApplicationContext.

            Other Aware Interfaces
            Besides ApplicationContextAware and BeanNameAware (discussed earlier), Spring offers a wide range of
            Aware callback interfaces that let beans indicate to the container that they require a certain
            infrastructure dependency. As a general rule, the name indicates the dependency type. The
            following table summarizes the most important Aware interfaces:
                Name                            Injected Dependency
                ApplicationContextAware         Declaring ApplicationContext.
                ApplicationEventPublisherAware  Event publisher of the enclosing ApplicationContext
                BeanClassLoaderAware            Class loader used to load the bean classes
                BeanFactoryAware                Declaring BeanFactory.
                BeanNameAware                   Name of the declaring bean
                LoadTimeWeaverAware             Defined weaver for processing class definition at load time.
                MessageSourceAware              Configured strategy for resolving messages (with support for parametrization
                                                and internationalization).
                NotificationPublisherAware      Spring JMX notification publisher.
                ResourceLoaderAware             Configured loader for low-level access to resources.
                ServletConfigAware              Current ServletConfig the container runs in. Valid only in
                                                a web-aware Spring ApplicationContext.
                ServletContextAware             Current ServletContext the container runs in. Valid only in
                                                a web-aware Spring ApplicationContext.

            Note again that using these interfaces ties your code to the Spring API and does not follow the
            Inversion of Control style. As a result, we recommend them for infrastructure beans that require
            programmatic access to the container.


        2.1.7. Bean Definition Inheritance
            A bean definition can contain a lot of configuration information, including constructor arguments,
            property values, and container-specific information, such as the initialization method, a static
            factory method name, and so on. A child bean definition inherits configuration data from a parent
            definition. The child definition can override some values or add others as needed. Using parent and
            child bean definitions can save a lot of typing. Effectively, this is a form of templating.

            If you work with an ApplicationContext interface programmatically, child bean definitions are
            represented by the ChildBeanDefinition class. Most users do not work with them on this level.
            Instead, they configure bean definitions declaratively in a class such as the
            ClassPathXmlApplicationContext. When you use XML-based configuration metadata, you can
            indicate a child bean definition by using the parent attribute, specifying the parent bean as the
            value of this attribute

            A child bean definition inherits scope, constructor argument values, property values, and method
            overrides from the parent, with the option to add new values. Any scope, initialization method,
            destroy method, or static factory method settings that you specify override the corresponding
            parent settings.
            The remaining settings are always taken from the child definition: depends on, autowire mode,
            dependency check, singleton, and lazy init


        2.1.8. Container Extension Points
            Typically, an application developer does not need to subclass ApplicationContext implementation
            classes. Instead, the Spring IoC container can be extended by plugging in implementations of
            special integration interfaces. The next few sections describe these integration interfaces.

            Customizing Beans by Using a BeanPostProcessor
            The BeanPostProcessor interface defines callback methods that you can implement to provide your
            own (or override the container’s default) instantiation logic, dependency resolution logic, and so
            forth. If you want to implement some custom logic after the Spring container finishes instantiating,
            configuring, and initializing a bean, you can plug in one or more custom BeanPostProcessor
            implementations

            An ApplicationContext automatically detects any beans that are defined in the configuration
            metadata that implement the BeanPostProcessor interface. The ApplicationContext registers these
            beans as post-processors so that they can be called later, upon bean creation. Bean post-processors
            can be deployed in the container in the same fashion as any other beans.

            Using callback interfaces or annotations in conjunction with a custom BeanPostProcessor
            implementation is a common means of extending the Spring IoC container. An example is Spring’s
            AutowiredAnnotationBeanPostProcessor — a BeanPostProcessor implementation that ships with the
            Spring distribution and autowires annotated fields, setter methods, and arbitrary config methods.

            Customizing Configuration Metadata with a BeanFactoryPostProcessor
            The next extension point that we look at is the
            org.springframework.beans.factory.config.BeanFactoryPostProcessor. The semantics of this
            interface are similar to those of the BeanPostProcessor, with one major difference:
            BeanFactoryPostProcessor operates on the bean configuration metadata. That is, the Spring IoC
            container lets a BeanFactoryPostProcessor read the configuration metadata and potentially change it
            before the container instantiates any beans other than BeanFactoryPostProcessor instances.

            A bean factory post-processor is automatically run when it is declared inside an ApplicationContext,
            in order to apply changes to the configuration metadata that define the container. Spring includes a
            number of predefined bean factory post-processors, such as PropertyOverrideConfigurer and
            PropertySourcesPlaceholderConfigurer.

    !!!     Customizing Instantiation Logic with a FactoryBean
            You can implement the org.springframework.beans.factory.FactoryBean interface for objects that are
            themselves factories.
            The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation
            logic. If you have complex initialization code that is better expressed in Java as opposed to a
            (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex
            initialization inside that class, and then plug your custom FactoryBean into the container.

            The FactoryBean concept and interface are used in a number of places within the Spring
            Framework. More than 50 implementations of the FactoryBean interface ship with Spring itself.

        2.1.9. Annotation-based Container Configuration
            Are annotations better than XML for configuring Spring?
            The introduction of annotation-based configuration raised the question of whether this
            approach is “better” than XML. The short answer is “it depends.” The long answer is that each
            approach has its pros and cons, and, usually, it is up to the developer to decide which strategy
            suits them better. Due to the way they are defined, annotations provide a lot of context in
            their declaration, leading to shorter and more concise configuration. However, XML excels at
            wiring up components without touching their source code or recompiling them. Some
            developers prefer having the wiring close to the source while others argue that annotated
            classes are no longer POJOs and, furthermore, that the configuration becomes decentralized
            and harder to control.
            No matter the choice, Spring can accommodate both styles and even mix them together. I

            An alternative to XML setup is provided by annotation-based configuration, which relies on the
            bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of
            using XML to describe a bean wiring, the developer moves the configuration into the component
            class itself by using annotations on the relevant class, method, or field declaration. As mentioned in
            Example: The AutowiredAnnotationBeanPostProcessor, using a BeanPostProcessor in conjunction with
            annotations is a common means of extending the Spring IoC container. For example, Spring 2.5
            introduced an annotation-based approach to drive Spring’s dependency injection. Essentially, the
            @Autowired annotation provides the same capabilities as described in Autowiring Collaborators but
            with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250
            annotations, such as @PostConstruct and @PreDestroy. Spring 3.0 added support for JSR-330
            (Dependency Injection for Java) annotations contained in the jakarta.inject package such as
            @Inject and @Named. Details about those annotations can be found in the relevant section.

    !!!!!   Annotation injection is performed before XML injection. Thus, the XML
            configuration overrides the annotations for properties wired through both
            approaches.

            The <context:annotation-config/> element (defined in XML config) implicitly registers the following
            post-processors:
                • ConfigurationClassPostProcessor
                • AutowiredAnnotationBeanPostProcessor
                • CommonAnnotationBeanPostProcessor
                • PersistenceAnnotationBeanPostProcessor
                • EventListenerMethodProcessor

            Using @Autowired
            JSR 330’s @Inject annotation can be used in place of Spring’s @Autowired annotation
            in the examples included in this section. See here for more details.

                public class MovieRecommender {
                  private final CustomerPreferenceDao customerPreferenceDao;

                  @Autowired
                  public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
                    this.customerPreferenceDao = customerPreferenceDao;
                  }
                  // ...
                }

            As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no
            longer necessary if the target bean defines only one constructor to begin with.
            However, if several constructors are available and there is no primary/default
            constructor, at least one of the constructors must be annotated with @Autowired in
            order to instruct the container which one to use. See the discussion on constructor
            resolution for details.

    !!!     You can also apply the @Autowired annotation to traditional setter methods
    !!!     You can apply @Autowired to fields as well and even mix it with constructors
    !!!     You can also apply the annotation to methods with arbitrary names and multiple arguments, as the
            following example shows:
                public class MovieRecommender {
                  private MovieCatalog movieCatalog;
                  private CustomerPreferenceDao customerPreferenceDao;

                  @Autowired
                  public void prepare(MovieCatalog movieCatalog,
                    CustomerPreferenceDao customerPreferenceDao) {
                        this.movieCatalog = movieCatalog;
                        this.customerPreferenceDao = customerPreferenceDao;
                  }
                  // ...
                }

            Make sure that your target components (for example, MovieCatalog, CustomerPreferenceDao) are consistently
            declared by the type that you use for your @Autowired-annotated injection points. Otherwise, injection may
            fail due to a "no type match found" error at runtime.

            For XML-defined beans or component classes found via classpath scanning, the
            container usually knows the concrete type up front. However, for @Bean factory
            methods, you need to make sure that the declared return type is sufficiently
            expressive. For components that implement several interfaces or for components
            potentially referred to by their implementation type, consider declaring the most
            specific return type on your factory method (at least as specific as required by the
            injection points referring to your bean).

            Your target beans can implement the org.springframework.core.Ordered interface
            or use the @Order or standard @Priority annotation if you want items in the array
            or list to be sorted in a specific order. Otherwise, their order follows the
            registration order of the corresponding target bean definitions in the container.

            @Order values may influence priorities at injection
            points, but be aware that they do not influence singleton startup order, which is an
            orthogonal concern determined by dependency relationships and @DependsOn declarations.

    !!!     By default, autowiring fails when no matching candidate beans are available for a given injection
            point. In the case of a declared array, collection, or map, at least one matching element is expected.

            The default behavior is to treat annotated methods and fields as indicating required dependencies.
            You can change this behavior as demonstrated in the following example, enabling the framework to
            skip a non-satisfiable injection point through marking it as non-required (i.e., by setting the
            required attribute in @Autowired to false):
                public class SimpleMovieLister {
                  private MovieFinder movieFinder;

                  @Autowired(required = false)
                  public void setMovieFinder(MovieFinder movieFinder) {
                    this.movieFinder = movieFinder;
                  }
                  // ...
                }
    !!!     A non-required method will not be called at all if its dependency (or one of its
            dependencies, in case of multiple arguments) is not available. A non-required field
            will not get populated at all in such cases, leaving its default value in place.
            In other words, setting the required attribute to false indicates that the
            corresponding property is optional for autowiring purposes, and the property will
            be ignored if it cannot be autowired. This allows properties to be assigned default
            values that can be optionally overridden via dependency injection

    !!!!!   Only one constructor of any given bean class may declare @Autowired with the
            required attribute set to true, indicating the constructor to autowire when used as
            a Spring bean. As a consequence, if the required attribute is left at its default value
            true, only a single constructor may be annotated with @Autowired. If multiple
            constructors declare the annotation, they will all have to declare required=false in
            order to be considered as candidates for autowiring (analogous to
            autowire=constructor in XML). The constructor with the greatest number of
            dependencies that can be satisfied by matching beans in the Spring container will
            be chosen. If none of the candidates can be satisfied, then a primary/default
            constructor (if present) will be used. Similarly, if a class declares multiple
            constructors but none of them is annotated with @Autowired, then a
            primary/default constructor (if present) will be used. If a class only declares a
            single constructor to begin with, it will always be used, even if not annotated. Note
            that an annotated constructor does not have to be public.

            Alternatively, you can express the non-required nature of a particular dependency through Java 8’s
            java.util.Optional, as the following example shows:

              @Autowired
              public void setMovieFinder(Optional<MovieFinder> movieFinder) {
              ...
              }

            You can also use @Autowired for interfaces that are well-known resolvable dependencies:
            BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and
            MessageSource. These interfaces and their extended interfaces, such as
            ConfigurableApplicationContext or ResourcePatternResolver, are automatically resolved, with no
            special setup necessary

            The @Autowired, @Inject, @Value, and @Resource annotations are handled by Spring
            BeanPostProcessor implementations. This means that you cannot apply these
            annotations within your own BeanPostProcessor or BeanFactoryPostProcessor types
            (if any). These types must be 'wired up' explicitly by using XML or a Spring @Bean method

            Fine-tuning Annotation-based Autowiring with @Primary
    !!!!    Because autowiring by type may lead to multiple candidates, it is often necessary to have more
            control over the selection process. One way to accomplish this is with Spring’s @Primary annotation.
            @Primary indicates that a particular bean should be given preference when multiple beans are
            candidates to be autowired to a single-valued dependency. If exactly one primary bean exists
            among the candidates, it becomes the autowired value.

            Fine-tuning Annotation-based Autowiring with Qualifiers
    !!!     @Primary is an effective way to use autowiring by type with several instances when one primary
            candidate can be determined. When you need more control over the selection process, you can use
            Spring’s @Qualifier annotation. You can associate qualifier values with specific arguments,
            narrowing the set of type matches so that a specific bean is chosen for each argument.

            @Autowired is fundamentally about type-driven injection with optional semantic qualifiers. This
            means that qualifier values, even with the bean name fallback, always have narrowing semantics
            within the set of type matches. They do not semantically express a reference to a unique bean id.
            Good qualifier values are main or EMEA or persistent, expressing characteristics of a specific
            component

            Qualifiers also apply to typed collections, as discussed earlier — for example, to Set<MovieCatalog>.
            In this case, all matching beans, according to the declared qualifiers, are injected as a collection.
            This implies that qualifiers do not have to be unique. Rather, they constitute filtering criteria. For
            example, you can define multiple MovieCatalog beans with the same qualifier value “action”, all of
            which are injected into a Set<MovieCatalog> annotated with @Qualifier("action").

    !!!!    If there is no other resolution indicator (such as a qualifier or a primary marker), for a
            non-unique dependency situation, Spring matches the injection point name (that
            is, the field name or parameter name) against the target bean names and chooses
            the same-named candidate, if any.
                Dan : bean name means if you use XML for defining beans something like the "name" attribute from below:
                    <bean name="anotherExample" class="examples.ExampleBeanTwo"/>

            That said, if you intend to express annotation-driven injection by name, do not primarily use
            @Autowired, even if it is capable of selecting by bean name among type-matching candidates.
            Instead, use the JSR-250 @Resource annotation, which is semantically defined to identify a specific
            target component by its unique name, with the declared type being irrelevant for the matching
            process. @Autowired has rather different semantics: After selecting candidate beans by type, the
            specified String qualifier value is considered within those type-selected candidates only

    !!!     @Autowired applies to fields, constructors, and multi-argument methods, allowing for narrowing
            through qualifier annotations at the parameter level. In contrast, @Resource is supported only for
            fields and bean property setter methods with a single argument. As a consequence, you should stick
            with qualifiers if your injection target is a constructor or a multi-argument method.

            You can create your own custom qualifier annotations. To do so, define an annotation and provide
            the @Qualifier annotation within your definition, as the following example shows
                Dan: see Genre interface in this project

            In some cases, using an annotation without a value may suffice. This can be useful when the
            annotation serves a more generic purpose and can be applied across several different types of
            dependencies.

            Using Generics as Autowiring Qualifiers
            In addition to the @Qualifier annotation, you can use Java generic types as an implicit form of qualification.

            Dan: Adding this for more context, in order for you to understand later one...Lets assume that you have 2 beans
            StringStore and IntegerStore that you want to inject.Next...from the documentation:
            Assuming that the preceding beans implement a generic interface, (that is, Store<String> and
            Store<Integer>), you can @Autowire the Store interface and the generic is used as a qualifier, as the
            following example shows:

                @Autowired
                private Store<String> s1; // <String> qualifier, injects the stringStore bean
                @Autowired
                private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean

            Generic qualifiers also apply when autowiring lists, Map instances and arrays:
                // Inject all Store beans as long as they have an <Integer> generic
                // Store<String> beans will not appear in this list
                @Autowired
                private List<Store<Integer>> s;

            Injection with @Resource
            Spring also supports injection by using the JSR-250 @Resource annotation
            (jakarta.annotation.Resource) on fields or bean property setter methods. This is a common pattern
            in Jakarta EE: for example, in JSF-managed beans and JAX-WS endpoints. Spring supports this
            pattern for Spring-managed objects as well.
            @Resource takes a name attribute.

    !!!!    By default, Spring interprets that value as the bean name to be injected. In other words, it follows
            by-name semantics
            If no name is explicitly specified, the default name is derived from the field name or setter method.
            In case of a field, it takes the field name. In case of a setter method, it takes the bean property name.

    !!      In the exclusive case of @Resource usage with no explicit name specified, and similar to @Autowired,
            @Resource finds a primary type match instead of a specific named bean and resolves well known
            resolvable dependencies

            Thus, in the following example, the customerPreferenceDao field first looks for a bean named
            "customerPreferenceDao" and then falls back to a primary type match for the type
            CustomerPreferenceDao:

                 @Resource
                 private CustomerPreferenceDao customerPreferenceDao;
                 @Resource
                 private ApplicationContext context;

    !!!     The context field is injected based on the known resolvable dependency type: ApplicationContext.

            Using @Value
            @Value is typically used to inject externalized properties

                @Configuration
                @PropertySource("classpath:application.properties")
                public class AppConfig { }

                @Value("${catalog.name}") String catalog
                    Dan: this will look into the application.properties file for a key catalog.name and inject the string value
                        of that key

            If you want to maintain strict control over nonexistent values, you should declare a
            PropertySourcesPlaceholderConfigurer bean, as the following example shows:
                @Configuration
                public class AppConfig {
                  @Bean
                  public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer()
                {
                  return new PropertySourcesPlaceholderConfigurer();
                  }
                }
            Using the above configuration ensures Spring initialization failure if any ${} placeholder could not
            be resolved

    !!!!    Spring Boot configures by default a PropertySourcesPlaceholderConfigurer bean
            that will get properties from application.properties and application.yml files.

            Built-in converter support provided by Spring allows simple type conversion (to Integer or int for
            example) to be automatically handled. Multiple comma-separated values can be automatically
            converted to String array without extra effort.

            Using @PostConstruct and @PreDestroy
            The CommonAnnotationBeanPostProcessor not only recognizes the @Resource annotation but also the
            JSR-250 lifecycle annotations: jakarta.annotation.PostConstruct and jakarta.annotation.PreDestroy.
            Introduced in Spring 2.5, the support for these annotations offers an alternative to the lifecycle
            callback mechanism described in initialization callbacks and destruction callbacks. Provided that
            the CommonAnnotationBeanPostProcessor is registered within the Spring ApplicationContext, a method
            carrying one of these annotations is invoked at the same point in the lifecycle as the corresponding
            Spring lifecycle interface method or explicitly declared callback method.

                  @PostConstruct
                  public void populateMovieCache() {
                    // populates the movie cache upon initialization...
                  }
                  @PreDestroy
                  public void clearMovieCache() {
                    // clears the movie cache upon destruction...
                  }

        2.1.10. Classpath Scanning and Managed Components
            Most examples in this chapter use XML to specify the configuration metadata that produces each
            BeanDefinition within the Spring container. The previous section (Annotation-based Container
            Configuration) demonstrates how to provide a lot of the configuration metadata through sourcelevel annotations.
            Even in those examples, however, the “base” bean definitions are explicitly
            defined in the XML file, while the annotations drive only the dependency injection. This section
            describes an option for implicitly detecting the candidate components by scanning the classpath.
            Candidate components are classes that match against a filter criteria and have a corresponding
            bean definition registered with the container. This removes the need to use XML to perform bean
            registration. Instead, you can use annotations (for example, @Component), AspectJ type expressions,
            or your own custom filter criteria to select which classes have bean definitions registered with the
            container

            @Component and Further Stereotype Annotations
    !!!!    The @Repository annotation is a marker for any class that fulfills the role or stereotype of a
            repository (also known as Data Access Object or DAO). Among the uses of this marker is the
            automatic translation of exceptions, as described in Exception Translation.

    !!!!    Spring provides further stereotype annotations: @Component, @Service, and @Controller. @Component is
            a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are
            specializations of @Component for more specific use cases (in the persistence, service, and
            presentation layers, respectively). Therefore, you can annotate your component classes with
            @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes
            are more properly suited for processing by tools or associating with aspects. For example, these
            stereotype annotations make ideal targets for pointcuts. @Repository, @Service, and @Controller can
            also carry additional semantics in future releases of the Spring Framework. Thus, if you are
            choosing between using @Component or @Service for your service layer, @Service is clearly the better
            choice. Similarly, as stated earlier, @Repository is already supported as a marker for automatic
            exception translation in your persistence layer.

            Using Meta-annotations and Composed Annotations
            Many of the annotations provided by Spring can be used as meta-annotations in your own code. A
            meta-annotation is an annotation that can be applied to another annotation. For example, the
            @Service annotation mentioned earlier is meta-annotated with @Component

            The @Component causes @Service to be treated in the same way as @Component.

            You can also combine meta-annotations to create “composed annotations”. For example, the
            @RestController annotation from Spring MVC is composed of @Controller and @ResponseBody

            Automatically Detecting Classes and Registering Bean Definitions
            Spring can automatically detect stereotyped classes and register corresponding BeanDefinition
            instances with the ApplicationContext.

    !!!     To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to
            your @Configuration class, where the basePackages attribute is a common parent package for the two
            classes. (Alternatively, you can specify a comma- or semicolon- or space-separated list that includes
            the parent package of each class.)

                @Configuration
                @ComponentScan(basePackages = "org.example")
                public class AppConfig {
                  // ...
                }

            Using Filters to Customize Scanning
            By default, classes annotated with @Component, @Repository, @Service, @Controller, @Configuration, or
            a custom annotation that itself is annotated with @Component are the only detected candidate
            components. However, you can modify and extend this behavior by applying custom filters. Add
            them as includeFilters or excludeFilters attributes of the @ComponentScan annotation (or as
            <context:include-filter /> or <context:exclude-filter /> child elements of the <context:componentscan> element
            in XML configuration).

                Dan: too detailed for now

            Defining Bean Metadata within Components
            The @Bean methods in a regular Spring component are processed differently than their counterparts
            inside a Spring @Configuration class. The difference is that @Component classes are not enhanced with
            CGLIB to intercept the invocation of methods and fields. CGLIB proxying is the means by which
            invoking methods or fields within @Bean methods in @Configuration classes creates bean metadata
            references to collaborating objects. Such methods are not invoked with normal Java semantics but
            rather go through the container in order to provide the usual lifecycle management and proxying
            of Spring beans, even when referring to other beans through programmatic calls to @Bean methods.
            In contrast, invoking a method or field in a @Bean method within a plain @Component class has
            standard Java semantics, with no special CGLIB processing or other constraints applying.

            You may declare @Bean methods as static, allowing for them to be called without
            creating their containing configuration class as an instance. This makes particular
            sense when defining post-processor beans (for example, of type
            BeanFactoryPostProcessor or BeanPostProcessor), since such beans get initialized
            early in the container lifecycle and should avoid triggering other parts of the
            configuration at that point

    !!!!    The Java language visibility of @Bean methods does not have an immediate impact
            on the resulting bean definition in Spring’s container. You can freely declare your
            factory methods as you see fit in non-@Configuration classes and also for static
            methods anywhere. However, regular @Bean methods in @Configuration classes
            need to be overridable — that is, they must not be declared as private or final.

            Finally, a single class may hold multiple @Bean methods for the same bean, as an
            arrangement of multiple factory methods to use depending on available
            dependencies at runtime. This is the same algorithm as for choosing the
            “greediest” constructor or factory method in other configuration scenarios: The
            variant with the largest number of satisfiable dependencies is picked at
            construction time, analogous to how the container selects between multiple
            @Autowired constructors.

            Naming Autodetected Components
            When a component is autodetected as part of the scanning process, its bean name is generated by
            the BeanNameGenerator strategy known to that scanner. By default, any Spring stereotype annotation
            (@Component, @Repository, @Service, and @Controller) that contains a name value thereby provides
            that name to the corresponding bean definition.
            If such an annotation contains no name value or for any other detected component (such as those
            discovered by custom filters), the default bean name generator returns the uncapitalized nonqualified class name.

            If you do not want to rely on the default bean-naming strategy, you can provide a custom beannaming strategy.
            First, implement the BeanNameGenerator interface, and be sure to include a default
            no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as
            the following example annotation and bean definition show.

    !!!!    If you run into naming conflicts due to multiple autodetected components having
            the same non-qualified class name (i.e., classes with identical names but residing
            in different packages), you may need to configure a BeanNameGenerator that defaults
            to the fully qualified class name for the generated bean name. As of Spring
            Framework 5.2.3, the FullyQualifiedAnnotationBeanNameGenerator located in
            package org.springframework.context.annotation can be used for such purposes.

            Providing a Scope for Autodetected Components
            As with Spring-managed components in general, the default and most common scope for
            autodetected components is singleton. However, sometimes you need a different scope that can be
            specified by the @Scope annotation. You can provide the name of the scope within the annotation, as
            the following example shows:

                @Scope("prototype")
                @Repository
                public class MovieFinderImpl implements MovieFinder {
                  // ...
                }

            @Scope annotations are only introspected on the concrete bean class (for annotated
            components) or the factory method (for @Bean methods). In contrast to XML bean
            definitions, there is no notion of bean definition inheritance, and inheritance
            hierarchies at the class level are irrelevant for metadata purposes.

            For details on web-specific scopes such as “request” or “session” in a Spring context, see Request,
            Session, Application, and WebSocket Scopes.

            When using certain non-singleton scopes, it may be necessary to generate proxies for the scoped
            objects. The reasoning is described in Scoped Beans as Dependencies. For this purpose, a scoped proxy attribute
            is available on the component-scan element. The three possible values are: no,
            interfaces, and targetClass. For example, the following configuration results in standard JDK
            dynamic proxies:
                @Configuration
                @ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
                public class AppConfig {
                  // ...
                }

            Providing Qualifier Metadata with Annotations
            The @Qualifier annotation is discussed in Fine-tuning Annotation-based Autowiring with Qualifiers.
            The examples in that section demonstrate the use of the @Qualifier annotation and custom qualifier
            annotations to provide fine-grained control when you resolve autowire candidates. Because those
            examples were based on XML bean definitions, the qualifier metadata was provided on the
            candidate bean definitions by using the qualifier or meta child elements of the bean element in the
            XML. When relying upon classpath scanning for auto-detection of components, you can provide the
            qualifier metadata with type-level annotations on the candidate class. The following three
            examples demonstrate this technique:
                @Component
                @Qualifier("Action")
                public class ActionMovieCatalog implements MovieCatalog {
                  // ...
                }

                @Component
                @Genre("Action")
                public class ActionMovieCatalog implements MovieCatalog {
                  // ...
                }

                @Component
                @Offline
                public class CachingMovieCatalog implements MovieCatalog {
                  // ...
                }

    !!!!    As with most annotation-based alternatives, keep in mind that the annotation
            metadata is bound to the class definition itself, while the use of XML allows for
            multiple beans of the same type to provide variations in their qualifier metadata,
            because that metadata is provided per-instance rather than per-class.

            Generating an Index of Candidate Components
    !!      While classpath scanning is very fast, it is possible to improve the startup performance of large
            applications by creating a static list of candidates at compilation time. In this mode, all modules that
            are targets of component scanning must use this mechanism.

            Your existing @ComponentScan or <context:component-scan/> directives must remain
            unchanged to request the context to scan candidates in certain packages. When
            the ApplicationContext detects such an index, it automatically uses it rather than
            scanning the classpath.
            To generate the index, add an additional dependency to each module that contains components that
            are targets for component scan directives. The following example shows how to do so with Maven:
                <dependency>
                  <groupId>org.springframework</groupId>
                  <artifactId>spring-context-indexer</artifactId>
                  <version>6.0.0</version>
                  <optional>true</optional>
                </dependency>

            The spring-context-indexer artifact generates a META-INF/spring.components file that is included in
            the jar file.

        2.1.11. Using JSR 330 Standard Annotations
    !!!!    Starting with Spring 3.0, Spring offers support for JSR-330 standard annotations (Dependency
            Injection). Those annotations are scanned in the same way as the Spring annotations. To use them,
            you need to have the relevant jars in your classpath

                <dependency>
                  <groupId>jakarta.inject</groupId>
                  <artifactId>jakarta.inject-api</artifactId>
                  <version>1</version>
                </dependency>

            Dependency Injection with @Inject and @Named
    !!!!    Instead of @Autowired, you can use @jakarta.inject.Inject as follows:
                  private MovieFinder movieFinder;
                  @Inject
                  public void setMovieFinder(MovieFinder movieFinder) {
                    this.movieFinder = movieFinder;
                  }

    !!!!    As with @Autowired, you can use @Inject at the field level, method level and constructor-argument
            level. Furthermore, you may declare your injection point as a Provider, allowing for on-demand
            access to beans of shorter scopes or lazy access to other beans through a Provider.get() call
                private Provider<MovieFinder> movieFinder;
                @Inject
                public void setMovieFinder(Provider<MovieFinder> movieFinder) {
                    this.movieFinder = movieFinder;
                }
                public void listMovies() {
                    this.movieFinder.get().findMovies(...);
                  // ...
                }

            If you would like to use a qualified name for the dependency that should be injected, you should
            use the @Named annotation, as the following example shows:
                @Inject
                public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
                  this.movieFinder = movieFinder;
                }

            As with @Autowired, @Inject can also be used with java.util.Optional or @Nullable. This is even
            more applicable here, since @Inject does not have a required attribute.

            @Named and @ManagedBean: Standard Equivalents to the @Component Annotation
    !!!     Instead of @Component, you can use @jakarta.inject.Named or jakarta.annotation.ManagedBean,

            It is very common to use @Component without specifying a name for the component. @Named can be
            used in a similar fashion
            When you use @Named or @ManagedBean, you can use component scanning in the exact same way as
            when you use Spring annotation

            In contrast to @Component, the JSR-330 @Named and the JSR-250 @ManagedBean
            annotations are not composable. You should use Spring’s stereotype model for
            building custom component annotations.
                Dan: see below other differences of Standard Annotations

    !!!!    Limitations of JSR-330 Standard Annotations
            Spring              jakarta.inject.*                jakarta.inject restrictions / comments
            @Autowired          @Inject                         @Inject has no 'required'
                                                                attribute. Can be used with Java
                                                                8’s Optional instead.
            @Component          @Named / @ManagedBean           JSR-330 does not provide a
                                                                composable model, only a way
                                                                to identify named components.
            @Scope("singleton") @Singleton                      The JSR-330 default scope is like
                                                                Spring’s prototype. However, in
                                                                order to keep it consistent with
                                                                Spring’s general defaults, a JSR330
                                                                bean declared in the Spring
                                                                container is a singleton by
                                                                default. In order to use a scope
                                                                other than singleton, you
                                                                should use Spring’s @Scope
                                                                annotation. jakarta.inject also
                                                                provides a jakarta.inject.Scope
                                                                annotation: however, this one is
                                                                only intended to be used for
                                                                creating custom annotations
            @Qualifier          @Qualifier / @Named             jakarta.inject.Qualifier is just
                                                                a meta-annotation for building
                                                                custom qualifiers. Concrete
                                                                String qualifiers (like Spring’s
                                                                @Qualifier with a value) can be
                                                                associated through
                                                                jakarta.inject.Named.
            @Value              -                               no equivalent
            @Lazy               -                               no equivalent
            ObjectFactory       Provider                        jakarta.inject.Provider is a
                                                                direct alternative to Spring’s
                                                                ObjectFactory, only with a
                                                                shorter get() method name. It
                                                                can also be used in combination
                                                                with Spring’s @Autowired or with
                                                                non-annotated constructors and
                                                                setter methods.


        2.1.12. Java-based Container Configuration
            This section covers how to use annotations in your Java code to configure the Spring container.

            Basic Concepts: @Bean and @Configuration
    !!!!!   The central artifacts in Spring’s new Java-configuration support are @Configuration-annotated
            classes and @Bean-annotated methods.
            The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new
            object to be managed by the Spring IoC container. For those familiar with Spring’s <beans/> XML
            configuration, the @Bean annotation plays the same role as the <bean/> element. You can use @Bean
            -annotated methods with any Spring @Component. However, they are most often used with
            @Configuration beans.

            Annotating a class with @Configuration indicates that its primary purpose is as a source of bean
            definitions. Furthermore, @Configuration classes let inter-bean dependencies be defined by calling
            other @Bean methods in the same class.

    !!!     Full @Configuration vs “lite” @Bean mode?
            When @Bean methods are declared within classes that are not annotated with @Configuration,
            they are referred to as being processed in a “lite” mode. Bean methods declared in a
            @Component or even in a plain old class are considered to be “lite”, with a different primary
            purpose of the containing class and a @Bean method being a sort of bonus there. For example,
            service components may expose management views to the container through an additional
            @Bean method on each applicable component class. In such scenarios, @Bean methods are a
            general-purpose factory method mechanism.
            Unlike full @Configuration, lite @Bean methods cannot declare inter-bean dependencies.
            Instead, they operate on their containing component’s internal state and, optionally, on
            arguments that they may declare. Such a @Bean method should therefore not invoke other
            @Bean methods. Each such method is literally only a factory method for a particular bean
            reference, without any special runtime semantics. The positive side-effect here is that no
            CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class
            design (that is, the containing class may be final and so forth).
    !!!!!   In common scenarios, @Bean methods are to be declared within @Configuration classes,
            ensuring that “full” mode is always used and that cross-method references therefore get
            redirected to the container’s lifecycle management. This prevents the same @Bean method
            from accidentally being invoked through a regular Java call, which helps to reduce subtle
            bugs that can be hard to track down when operating in “lite” mode.

            Instantiating the Spring Container by Using AnnotationConfigApplicationContext
            The following sections document Spring’s AnnotationConfigApplicationContext, introduced in Spring
            3.0. This versatile ApplicationContext implementation is capable of accepting not only
            @Configuration classes as input but also plain @Component classes and classes annotated with JSR-330
            metadata.

            When @Configuration classes are provided as input, the @Configuration class itself is registered as a
            bean definition and all declared @Bean methods within the class are also registered as bean
            definitions.
            When @Component and JSR-330 classes are provided, they are registered as bean definitions, and it is
            assumed that DI metadata such as @Autowired or @Inject are used within those classes where
            necessary

            Simple Construction
    !!      In much the same way that Spring XML files are used as input when instantiating a
            ClassPathXmlApplicationContext, you can use @Configuration classes as input when instantiating an
            AnnotationConfigApplicationContext. This allows for completely XML-free usage of the Spring
            container
                Dan: see my class MainContainerConfiguration as example

            As mentioned earlier, AnnotationConfigApplicationContext is not limited to working only with
            @Configuration classes. Any @Component or JSR-330 annotated class may be supplied as input to the
            constructor, as the following example shows:

    !!      Building the Container Programmatically by Using register(Class<?>…)
            You can instantiate an AnnotationConfigApplicationContext by using a no-arg constructor and then
            configure it by using the register() method. This approach is particularly useful when
            programmatically building an AnnotationConfigApplicationContext. T

    !!      Enabling Component Scanning with scan(String…)
            To enable component scanning, you can annotate your @Configuration class as follows:
                @Configuration
                @ComponentScan(basePackages = "com.acme") ①
                public class AppConfig {
                  // ...
                }

            AnnotationConfigApplicationContext exposes the scan(String…) method to allow for the same
            component-scanning functionality, as the following example shows

            Remember that @Configuration classes are meta-annotated with @Component, so they
            are candidates for component-scanning. In the preceding example, assuming that
            AppConfig is declared within the com.acme package (or any package underneath), it
            is picked up during the call to scan(). Upon refresh(), all its @Bean methods are
            processed and registered as bean definitions within the container.

            Support for Web Applications with AnnotationConfigWebApplicationContext
            A WebApplicationContext variant of AnnotationConfigApplicationContext is available with
            AnnotationConfigWebApplicationContext. You can use this implementation when configuring the
            Spring ContextLoaderListener servlet listener, Spring MVC DispatcherServlet, and so forth
                Dan : there is a web.xml example in the documentation for a typical Spring MVC web app

            Using the @Bean Annotation
    !!!     @Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation
            supports some of the attributes offered by <bean/>, such as:
                • init-method
                • destroy-method
                • autowiring
                • name.
            You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.

            Declaring a Bean
    !!!!    To declare a bean, you can annotate a method with the @Bean annotation. You use this method to
            register a bean definition within an ApplicationContext of the type specified as the method’s return
            value. By default, the bean name is the same as the method name. The following example shows a
            @Bean method declaration:
                @Configuration
                public class AppConfig {
                  @Bean
                  public TransferServiceImpl transferService() {
                  return new TransferServiceImpl();
                  }
                }
            Both declarations make a bean named transferService available in the ApplicationContext, bound
            to an object instance of type TransferServiceImpl.

    !!!     You can also use default methods to define beans. This allows composition of bean configurations
            by implementing interfaces with bean definitions on default methods
                Dan : see BaseConfig

            You can also declare your @Bean method with an interface (or base class) return type...example:
                @Configuration
                public class AppConfig {
                  @Bean
                  public TransferService transferService() {
                  return new TransferServiceImpl();
                  }
                }

            However, this limits the visibility for advance type prediction to the specified interface type
            (TransferService). Then, with the full type (TransferServiceImpl) known to the container only once
            the affected singleton bean has been instantiated. Non-lazy singleton beans get instantiated
            according to their declaration order, so you may see different type matching results depending on
            when another component tries to match by a non-declared type (such as @Autowired
            TransferServiceImpl, which resolves only once the transferService bean has been instantiated).
                Dan:...i don't quite understand this..

    !!!!!!  If you consistently refer to your types by a declared service interface, your @Bean
            return types may safely join that design decision. However, for components that
            implement several interfaces or for components potentially referred to by their
            implementation type, it is safer to declare the most specific return type possible (at
            least as specific as required by the injection points that refer to your bean).

            Bean Dependencies
            A @Bean-annotated method can have an arbitrary number of parameters that describe the
            dependencies required to build that bean. For instance, if our TransferService requires an
            AccountRepository, we can materialize that dependency with a method parameter

            Receiving Lifecycle Callbacks
            Any classes defined with the @Bean annotation support the regular lifecycle callbacks and can use
            the @PostConstruct and @PreDestroy annotations from JSR-250. See JSR-250 annotations for further details.
            The regular Spring lifecycle callbacks are fully supported as well. If a bean implements
            InitializingBean, DisposableBean, or Lifecycle, their respective methods are called by the container.

            By default, beans defined with Java configuration that have a public close or
            shutdown method are automatically enlisted with a destruction callback. If you
            have a public close or shutdown method and you do not wish for it to be called
            when the container shuts down, you can add @Bean(destroyMethod="") to your bean
            definition to disable the default (inferred) mode.

            Using the @Scope Annotation
            You can specify that your beans defined with the @Bean annotation should have a specific scope. You
            can use any of the standard scopes specified in the Bean Scopes section.
            The default scope is singleton, but you can override this with the @Scope annotation, as the
            following example shows:
                @Configuration
                public class MyConfiguration {
                  @Bean
                  @Scope("prototype")
                  public Encryptor encryptor() {
                  // ...
                  }
                }

            Customizing Bean Naming
            By default, configuration classes use a @Bean method’s name as the name of the resulting bean. This
            functionality can be overridden, however, with the name attribute

            Using the @Configuration annotation
    !!!     @Configuration is a class-level annotation indicating that an object is a source of bean definitions.
            @Configuration classes declare beans through @Bean-annotated methods. Calls to @Bean methods on
            @Configuration classes can also be used to define inter-bean dependencies. See Basic Concepts: @Bean
            and @Configuration for a general introduction.

            Injecting Inter-bean Dependencies
            When beans have dependencies on one another, expressing that dependency is as simple as having
            one bean method call another, as the following example shows:
                @Configuration
                public class AppConfig {
                  @Bean
                  public BeanOne beanOne() {
                    return new BeanOne(beanTwo());
                  }
                  @Bean
                  public BeanTwo beanTwo() {
                    return new BeanTwo();
                  }
                }

    !!!!!   In the preceding example, beanOne receives a reference to beanTwo through constructor injection.
            This method of declaring inter-bean dependencies works only when the @Bean
            method is declared within a @Configuration class. You cannot declare inter-bean
            dependencies by using plain @Component classes.

            Lookup Method Injection
            As noted earlier, lookup method injection is an advanced feature that you should use rarely. It is
            useful in cases where a singleton-scoped bean has a dependency on a prototype-scoped bean. Using
            Java for this type of configuration provides a natural means for implementing this pattern.
                Dan: the example is in the book...makes sense, did not add it as it is too detailed for now

            Further Information About How Java-based Configuration Works Internally
                Dan: see examples from package beanCalledTwice
            clientDao() has been called once in clientService1() and once in clientService2(). Since this
            method creates a new instance of ClientDaoImpl and returns it, you would normally expect to have
            two instances (one for each service). That definitely would be problematic: In Spring, instantiated
            beans have a singleton scope by default. This is where the magic comes in: All @Configuration
            classes are subclassed at startup-time with CGLIB. In the subclass, the child method checks the
            container first for any cached (scoped) beans before it calls the parent method and creates a new
            instance.

            The behavior could be different according to the scope of your bean. We are
            talking about singletons here.

    !!      Using the @Import Annotation
            Much as the <import/> element is used within Spring XML files to aid in modularizing
            configurations, the @Import annotation allows for loading @Bean definitions from another
            configuration class,

            Now, rather than needing to specify both ConfigA.class and ConfigB.class when instantiating the
            context, only ConfigB needs to be supplied explicitly
            This approach simplifies container instantiation, as only one class needs to be dealt with, rather
            than requiring you to remember a potentially large number of @Configuration classes during
            construction.

            Injecting Dependencies on Imported @Bean Definitions
            There is another way to achieve the same result. Remember that @Configuration classes are
            ultimately only another bean in the container: This means that they can take advantage of
            @Autowired and @Value injection and other features the same as any other bean

    !!!!!   Make sure that the dependencies you inject that way are of the simplest kind only.
            @Configuration classes are processed quite early during the initialization of the
            context, and forcing a dependency to be injected this way may lead to unexpected
            early initialization. Whenever possible, resort to parameter-based injection, as in
            the preceding example.
                Dan: so the example from package "importt" is good ! use that approach
            Also, be particularly careful with BeanPostProcessor and BeanFactoryPostProcessor
            definitions through @Bean. Those should usually be declared as static @Bean
            methods, not triggering the instantiation of their containing configuration class.
            Otherwise, @Autowired and @Value may not work on the configuration class itself,
            since it is possible to create it as a bean instance earlier than
            AutowiredAnnotationBeanPostProcessor.

    !!      If you want to influence the startup creation order of certain beans, consider
            declaring some of them as @Lazy (for creation on first access instead of on startup)
            or as @DependsOn certain other beans (making sure that specific other beans are
            created before the current bean, beyond what the latter’s direct dependencies imply).

            Conditionally Include @Configuration Classes or @Bean Methods
    !!!     It is often useful to conditionally enable or disable a complete @Configuration class or even
            individual @Bean methods, based on some arbitrary system state. One common example of this is to
            use the @Profile annotation to activate beans only when a specific profile has been enabled in the
            Spring Environment (see Bean Definition Profiles for details).

            The @Profile annotation is actually implemented by using a much more flexible annotation called
            @Conditional. The @Conditional annotation indicates specific
            org.springframework.context.annotation.Condition implementations that should be consulted
            before a @Bean is registered.

            XML-centric Use of @Configuration Classes
            It may be preferable to bootstrap the Spring container from XML and include @Configuration classes
            in an ad-hoc fashion. For example, in a large existing codebase that uses Spring XML, it is easier to
            create @Configuration classes on an as-needed basis and include them from the existing XML files.
            Later in this section, we cover the options for using @Configuration classes in this kind of “XMLcentric” situation.

            @Configuration Class-centric Use of XML with @ImportResource
            In applications where @Configuration classes are the primary mechanism for configuring the
            container, it is still likely necessary to use at least some XML. In these scenarios, you can use
            @ImportResource and define only as much XML as you need. Doing so achieves a “Java-centric”
            approach to configuring the container and keeps XML to a bare minimum. The following example
            (which includes a configuration class, an XML file that defines a bean, a properties file, and the main
            class) shows how to use the @ImportResource annotation to achieve “Java-centric” configuration that
            uses XML as needed

        2.1.13. Environment Abstraction
    !!!!    The Environment interface is an abstraction integrated in the container that models two key aspects
            of the application environment: profiles and properties.

    !!!!    A profile is a named, logical group of bean definitions to be registered with the container only if the
            given profile is active. Beans may be assigned to a profile whether defined in XML or with
            annotations. The role of the Environment object with relation to profiles is in determining which
            profiles (if any) are currently active, and which profiles (if any) should be active by default.

    !!!!    Properties play an important role in almost all applications and may originate from a variety of
            sources: properties files, JVM system properties, system environment variables, JNDI, servlet
            context parameters, ad-hoc Properties objects, Map objects, and so on. The role of the Environment
            object with relation to properties is to provide the user with a convenient service interface for
            configuring property sources and resolving properties from them

            Bean Definition Profiles
            Bean definition profiles provide a mechanism in the core container that allows for registration of
            different beans in different environments. The word, “environment,” can mean different things to
            different users, and this feature can help with many use cases:
                • Registering customized implementations of beans for customer A versus customer B
                deployments
                • Working against an in-memory datasource in development versus looking up that same
                datasource from JNDI when in QA or production.

            .....
            If we generalize the use case shown in the preceding example of environment-specific bean
            definitions, we end up with the need to register certain bean definitions in certain contexts but not
            in others. You could say that you want to register a certain profile of bean definitions in situation A
            and a different profile in situation B. We start by updating our configuration to reflect this need.

            Using @Profile
            The @Profile annotation lets you indicate that a component is eligible for registration when one or
            more specified profiles are active.
            Example:
                @Configuration
                @Profile("development")
                public class StandaloneDataConfig {
                  @Bean
                  public DataSource dataSource() {
                     return new EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript("classpath:com/bank/config/sql/schema.sql")
                        .addScript("classpath:com/bank/config/sql/test-data.sql")
                        .build();
                  }
                }

    !!      The profile string may contain a simple profile name (for example, production) or a profile
            expression. A profile expression allows for more complicated profile logic to be expressed (for
            example, production & us-east). The following operators are supported in profile expressions:
            • !: A logical “not” of the profile
            • &: A logical “and” of the profiles
            • |: A logical “or” of the profiles

            You cannot mix the & and | operators without using parentheses. For example,
            production & us-east | eu-central is not a valid expression. It must be expressed
            as production & (us-east | eu-central).

    !!      You can use @Profile as a meta-annotation for the purpose of creating a custom composed
            annotation. The following example defines a custom @Production annotation that you can use as a
            drop-in replacement for @Profile("production")
                @Target(ElementType.TYPE)
                @Retention(RetentionPolicy.RUNTIME)
                @Profile("production")
                public @interface Production {
                }

            If a @Configuration class is marked with @Profile, all of the @Bean methods and
            @Import annotations associated with that class are bypassed unless one or more of
            the specified profiles are active. If a @Component or @Configuration class is marked
            with @Profile({"p1", "p2"}), that class is not registered or processed unless
            profiles 'p1' or 'p2' have been activated. If a given profile is prefixed with the NOT
            operator (!), the annotated element is registered only if the profile is not active.
            For example, given @Profile({"p1", "!p2"}), registration will occur if profile 'p1' is
            active or if profile 'p2' is not active.

    !!!     @Profile can also be declared at the method level to include only one particular bean of a
            configuration class

            https://stackoverflow.com/questions/11869064/maven-profiles-or-spring-profiles

            With @Profile on @Bean methods, a special scenario may apply: In the case of
            overloaded @Bean methods of the same Java method name (analogous to
            constructor overloading), a @Profile condition needs to be consistently declared on
            all overloaded methods. If the conditions are inconsistent, only the condition on
            the first declaration among the overloaded methods matters. Therefore, @Profile
            can not be used to select an overloaded method with a particular argument
            signature over another. Resolution between all factory methods for the same bean
            follows Spring’s constructor resolution algorithm at creation time.
            If you want to define alternative beans with different profile conditions, use
            distinct Java method names that point to the same bean name by using the @Bean
            name attribute, as shown in the preceding example.

            Activating a Profile
            Now that we have updated our configuration, we still need to instruct Spring which profile is
            active. If we started our sample application right now, we would see a
            NoSuchBeanDefinitionException thrown, because the container could not find the Spring bean
            named dataSource.

            Activating a profile can be done in several ways, but the most straightforward is to do it
            programmatically against the Environment API which is available through an ApplicationContext.
                Dan: See MainProfile class
    !!!     In addition, you can also declaratively activate profiles through the spring.profiles.active
            property, which may be specified through system environment variables, JVM system properties,
            servlet context parameters in web.xml, or even as an entry in JNDI (see PropertySource Abstraction).

            Note that profiles are not an “either-or” proposition. You can activate multiple profiles at once.
            Programmatically, you can provide multiple profile names to the setActiveProfiles() method,
            which accepts String… varargs.

            Default Profile
            The default profile represents the profile that is enabled by default.
            If no profile is active, the dataSource is created. You can see this as a way to provide a default
            definition for one or more beans. If any profile is enabled, the default profile does not apply

            PropertySource Abstraction
            Spring’s Environment abstraction provides search operations over a configurable hierarchy of
            property sources
            In the preceding snippet, we see a high-level way of asking Spring whether the my-property
            property is defined for the current environment. To answer this question, the Environment object
            performs a search over a set of PropertySource objects. A PropertySource is a simple abstraction over
            any source of key-value pairs, and Spring’s StandardEnvironment is configured with two
            PropertySource objects — one representing the set of JVM system properties
            (System.getProperties()) and one representing the set of system environment variables
            (System.getenv()).

            These default property sources are present for StandardEnvironment, for use in
            standalone applications. StandardServletEnvironment is populated with additional
            default property sources including servlet config, servlet context parameters, and
            a JndiPropertySource if JNDI is available.

            Note that property values are not merged but rather completely overridden by a preceding entry.
            For a common StandardServletEnvironment, the full hierarchy is as follows, with the
            highest-precedence entries at the top:
                1. ServletConfig parameters (if applicable — for example, in case of a
                DispatcherServlet context)
                2. ServletContext parameters (web.xml context-param entries)
                3. JNDI environment variables (java:comp/env/ entries)
                4. JVM system properties (-D command-line arguments)
                5. JVM system environment (operating system environment variables)


        2.1.14. Registering a LoadTimeWeaver
            The LoadTimeWeaver is used by Spring to dynamically transform classes as they are loaded into the
            Java virtual machine (JVM).
            To enable load-time weaving, you can add the @EnableLoadTimeWeaving to one of your @Configuration
            classes

            Dan: this is too detailed for now, and there is not much info in the document about this
            concept/functionality

        2.1.15. Additional Capabilities of the ApplicationContext
            Many people use the ApplicationContext in a
            completely declarative fashion, not even creating it programmatically, but instead relying on
            support classes such as ContextLoader to automatically instantiate an ApplicationContext as part of
            the normal startup process of a Jakarta EE web application.

            To enhance BeanFactory functionality in a more framework-oriented style, the org.springframework.context
            package also provides the following functionality:
    !!!!        • Access to messages in i18n-style, through the MessageSource interface.
    !!!!        • Access to resources, such as URLs and files, through the ResourceLoader interface.
                • Event publication, namely to beans that implement the ApplicationListener interface, through
                the use of the ApplicationEventPublisher interface.
                • Loading of multiple (hierarchical) contexts, letting each be focused on one particular layer, such
                as the web layer of an application, through the HierarchicalBeanFactory interface.

            Internationalization using MessageSource
    !!!     The ApplicationContext interface extends an interface called MessageSource and, therefore, provides
            internationalization (“i18n”) functionality. Spring also provides the HierarchicalMessageSource
            interface, which can resolve messages hierarchically. Together, these interfaces provide the
            foundation upon which Spring effects message resolution.

            When an ApplicationContext is loaded, it automatically searches for a MessageSource bean defined in
            the context. The bean must have the name messageSource. If such a bean is found, all calls to the
            preceding methods are delegated to the message source. If no message source is found, the
            ApplicationContext attempts to find a parent containing a bean with the same name. If it does, it
            uses that bean as the MessageSource. If the ApplicationContext cannot find any source for messages,
            an empty DelegatingMessageSource is instantiated in order to be able to accept calls to the methods
            defined above.

            Because Spring’s MessageSource is based on Java’s ResourceBundle, it does not merge
            bundles with the same base name, but will only use the first bundle found.
            Subsequent message bundles with the same base name are ignored.

            As an alternative to ResourceBundleMessageSource, Spring provides a
            ReloadableResourceBundleMessageSource class. This variant supports the same
            bundle file format but is more flexible than the standard JDK based
            ResourceBundleMessageSource implementation. In particular, it allows for reading
            files from any Spring resource location (not only from the classpath) and supports
            hot reloading of bundle property files (while efficiently caching them in between).

            Standard and Custom Events
    !!!!    Event handling in the ApplicationContext is provided through the ApplicationEvent class and the
            ApplicationListener interface. If a bean that implements the ApplicationListener interface is
            deployed into the context, every time an ApplicationEvent gets published to the ApplicationContext,
            that bean is notified. Essentially, this is the standard Observer design pattern.

    !!      As of Spring 4.2, the event infrastructure has been significantly improved and
            offers an annotation-based model as well as the ability to publish any arbitrary
            event (that is, an object that does not necessarily extend from ApplicationEvent).
            When such an object is published, we wrap it in an event for you.

            The following table describes the standard events that Spring provides:
            Event                               Explanation
            ContextRefreshedEvent               Published when the ApplicationContext is initialized or refreshed
                                                (for example, by using the refresh() method on the
                                                ConfigurableApplicationContext interface). Here, “initialized” means
                                                that all beans are loaded, post-processor beans are detected and
                                                activated, singletons are pre-instantiated, and the
                                                ApplicationContext object is ready for use. As long as the context has
                                                not been closed, a refresh can be triggered multiple times, provided
                                                that the chosen ApplicationContext actually supports such “hot”
                                                refreshes. For example, XmlWebApplicationContext supports hot
                                                refreshes, but GenericApplicationContext does not.

            ContextStartedEvent                 Published when the ApplicationContext is started by using the
                                                start() method on the ConfigurableApplicationContext interface.
                                                Here, “started” means that all Lifecycle beans receive an explicit
                                                start signal. Typically, this signal is used to restart beans after an
                                                explicit stop, but it may also be used to start components that have
                                                not been configured for autostart (for example, components that
                                                have not already started on initialization).

            ContextStoppedEvent                 Published when the ApplicationContext is stopped by using the
                                                stop() method on the ConfigurableApplicationContext interface.
                                                Here, “stopped” means that all Lifecycle beans receive an explicit
                                                stop signal. A stopped context may be restarted through a start()
                                                call.

            ContextClosedEvent                  Published when the ApplicationContext is being closed by using the
                                                close() method on the ConfigurableApplicationContext interface or
                                                via a JVM shutdown hook. Here, "closed" means that all singleton
                                                beans will be destroyed. Once the context is closed, it reaches its end
                                                of life and cannot be refreshed or restarted.

            RequestHandledEvent                 A web-specific event telling all beans that an HTTP request has been
                                                serviced. This event is published after the request is complete. This
                                                event is only applicable to web applications that use Spring’s
                                                DispatcherServlet.
            ServletRequestHandledEvent          A subclass of RequestHandledEvent that adds Servlet-specific context
                                                information.

            You can also create and publish your own custom events. The following example shows a simple
            class that extends Spring’s ApplicationEvent base class:
                Dan: see "event" package

    !!!     To publish a custom ApplicationEvent, call the publishEvent() method on an
            ApplicationEventPublisher. Typically, this is done by creating a class that implements
            ApplicationEventPublisherAware and registering it as a Spring bean


            At configuration time, the Spring container detects that EmailService implements
            ApplicationEventPublisherAware and automatically calls setApplicationEventPublisher().
            In reality, the parameter passed in is the Spring container itself. You are interacting with
            the application context through its ApplicationEventPublisher interface.

    !!      To receive the custom ApplicationEvent, you can create a class that implements ApplicationListener
            and register it as a Spring bean.

            You can register as many event listeners as
    !!!!    you wish, but note that, by default, event listeners receive events synchronously. This means that
            the publishEvent() method blocks until all listeners have finished processing the event. One
            advantage of this synchronous and single-threaded approach is that, when a listener receives an
            event, it operates inside the transaction context of the publisher if a transaction context is available.
            If another strategy for event publication becomes necessary, see the javadoc for Spring’s
            ApplicationEventMulticaster interface and SimpleApplicationEventMulticaster implementation for
            configuration options

    !!!     Spring’s eventing mechanism is designed for simple communication between
            Spring beans within the same application context. However, for more
            sophisticated enterprise integration needs, the separately maintained Spring
            Integration project provides complete support for building lightweight, patternoriented, event-driven architectures that build upon the well-known Spring
            programming model.

            Annotation-based Event Listeners
            You can register an event listener on any method of a managed bean by using the @EventListener
            annotation.

            The method signature once again declares the event type to which it listens, but, this time, with a
            flexible name and without implementing a specific listener interface. The event type can also be
            narrowed through generics as long as the actual event type resolves your generic parameter in its
            implementation hierarchy.

    !!!!
            If your method should listen to several events or if you want to define it with no parameter at all,
            the event types can also be specified on the annotation itself.

            It is also possible to add additional runtime filtering by using the condition attribute of the
            annotation that defines a SpEL expression, which should match to actually invoke the method for a
            particular event.
            The following example shows how our notifier can be rewritten to be invoked only if the content
            attribute of the event is equal to my-event

            If you need to publish an event as the result of processing another event, you can change the
            method signature to return the event that should be published,
            The handleBlockedListEvent() method publishes a new ListUpdateEvent for every BlockedListEvent
            that it handles. If you need to publish several events, you can return a Collection or an array of
            events instead.

            Asynchronous Listeners
    !!!!    If you want a particular listener to process events asynchronously, you can reuse the regular @Async
            support.

            Be aware of the following limitations when using asynchronous events:
            • If an asynchronous event listener throws an Exception, it is not propagated to the caller. See
            AsyncUncaughtExceptionHandler for more details.
            • Asynchronous event listener methods cannot publish a subsequent event by returning a value.
            If you need to publish another event as the result of the processing, inject an
            ApplicationEventPublisher to publish the event manually.

            Ordering Listeners
    !!      If you need one listener to be invoked before another one, you can add the @Order annotation to the
            method declaration

            Generic Events
            You can also use generics to further define the structure of your event. Consider using an
            EntityCreatedEvent<T> where T is the type of the actual entity that got created. For example, you can
            create the following listener definition to receive only EntityCreatedEvent for a Person:
                @EventListener
                public void onPersonCreated(EntityCreatedEvent<Person> event) {
                  // ...
                }

            Convenient Access to Low-level Resources
            For optimal usage and understanding of application contexts, you should familiarize yourself with
            Spring’s Resource abstraction, as described in Resources.

             An application context is a ResourceLoader, which can be used to load Resource objects. A Resource is
             essentially a more feature rich version of the JDK java.net.URL class. In fact, the implementations of
             the Resource wrap an instance of java.net.URL, where appropriate. A Resource can obtain low-level
             resources from almost any location in a transparent fashion, including from the classpath, a
             filesystem location, anywhere describable with a standard URL, and some other variations
             If the resource location string is a simple path without any special prefixes, where those resources come
             from is specific and appropriate to the actual application context type.

             You can also expose properties of type Resource, to be used to access static resources.

    !!!!     Application Startup Tracking
             The ApplicationContext manages the lifecycle of Spring applications and provides a rich
             programming model around components. As a result, complex applications can have equally
             complex component graphs and startup phases.
             Tracking the application startup steps with specific metrics can help understand where time is
             being spent during the startup phase, but it can also be used as a way to better understand the
             context lifecycle as a whole.
             The AbstractApplicationContext (and its subclasses) is instrumented with an ApplicationStartup,
             which collects StartupStep data about various startup phases:
             • application context lifecycle (base packages scanning, config classes management)
             • beans lifecycle (instantiation, smart initialization, post processing)
             • application events processing

            Spring Framework ships with an implementation for tracking startup steps with Java Flight Recorder:
            FlightRecorderApplicationStartup. To use this variant, you must configure an instance of it to the
            ApplicationContext as soon as it’s been created.

     !!!!   ApplicationStartup is meant to be only used during application startup and for the
            core container; this is by no means a replacement for Java profilers or metrics
            libraries like Micrometer

            Deploying a Spring ApplicationContext as a Jakarta EE RAR File
            It is possible to deploy a Spring ApplicationContext as a RAR file, encapsulating the context and all
            of its required bean classes and library JARs in a Jakarta EE RAR deployment unit. This is the
            equivalent of bootstrapping a stand-alone ApplicationContext (only hosted in Jakarta EE
            environment) being able to access the Jakarta EE servers facilities. RAR deployment is a more
            natural alternative to a scenario of deploying a headless WAR file — in effect, a WAR file without
            any HTTP entry points that is used only for bootstrapping a Spring ApplicationContext in a Jakarta
            EE environment

            See the javadoc of the SpringContextResourceAdapter class for the configuration details involved in
            RAR deployment.
            For a simple deployment of a Spring ApplicationContext as a Jakarta EE RAR file:
                1. Package all application classes into a RAR file (which is a standard JAR file with a different file
                extension).
                2. Add all required library JARs into the root of the RAR archive.
                3. Add a META-INF/ra.xml deployment descriptor (as shown in the javadoc for
                SpringContextResourceAdapter) and the corresponding Spring XML bean definition file(s)
                (typically META-INF/applicationContext.xml).
                4. Drop the resulting RAR file into your application server’s deployment directory.


        2.1.16. The BeanFactory API
            The BeanFactory API provides the underlying basis for Spring’s IoC functionality

            BeanFactory and related interfaces (such as BeanFactoryAware, InitializingBean, DisposableBean) are
            important integration points for other framework components. By not requiring any annotations or
            even reflection, they allow for very efficient interaction between the container and its components.
            Application-level beans may use the same callback interfaces but typically prefer declarative
            dependency injection instead, either through annotations or through programmatic configuration.

            BeanFactory or ApplicationContext?
            This section explains the differences between the BeanFactory and ApplicationContext container
            levels and the implications on bootstrapping.

            You should use an ApplicationContext unless you have a good reason for not doing so, with
            GenericApplicationContext and its subclass AnnotationConfigApplicationContext as the common
            implementations for custom bootstrapping. These are the primary entry points to Spring’s core
            container for all common purposes: loading of configuration files, triggering a classpath scan,
            programmatically registering bean definitions and annotated classes, and (as of 5.0) registering
            functional bean definitions.

    !!!!    Because an ApplicationContext includes all the functionality of a BeanFactory, it is generally
            recommended over a plain BeanFactory, except for scenarios where full control over bean
            processing is needed


    2.2 Resources
        This chapter covers how Spring handles resources and how you can work with resources in Spring.
        It includes the following topics:
        • Introduction
        • The Resource Interface
        • Built-in Resource Implementations
        • The ResourceLoader Interface
        • The ResourcePatternResolver Interface
        • The ResourceLoaderAware Interface
        • Resources as Dependencies
        • Application Contexts and Resource Paths

        2.2.1. Introduction
            Java’s standard java.net.URL class and standard handlers for various URL prefixes, unfortunately,
            are not quite adequate enough for all access to low-level resources. For example, there is no
            standardized URL implementation that may be used to access a resource that needs to be obtained
            from the classpath or relative to a ServletContext. While it is possible to register new handlers for
            specialized URL prefixes (similar to existing handlers for prefixes such as http:), this is generally
            quite complicated, and the URL interface still lacks some desirable functionality, such as a method to
            check for the existence of the resource being pointed to.

        2.2.2. The Resource Interface
            Spring’s Resource interface located in the org.springframework.core.io. package is meant to be a
            more capable interface for abstracting access to low-level resources. The following listing provides
            an overview of the Resource interface.

            As the definition of the Resource interface shows, it extends the InputStreamSource interface.

            Some of the most important methods from the Resource interface are:
                • getInputStream(): Locates and opens the resource, returning an InputStream for reading from
                the resource. It is expected that each invocation returns a fresh InputStream. It is the
                responsibility of the caller to close the stream.
                • exists(): Returns a boolean indicating whether this resource actually exists in physical form.
                • isOpen(): Returns a boolean indicating whether this resource represents a handle with an open
                stream. If true, the InputStream cannot be read multiple times and must be read once only and
                then closed to avoid resource leaks. Returns false for all usual resource implementations, with
                the exception of InputStreamResource
                • getDescription(): Returns a description for this resource, to be used for error output when
                working with the resource. This is often the fully qualified file name or the actual URL of the
                resource.

            While the Resource interface is used a lot with Spring and by Spring, it is actually very convenient to
            use as a general utility class by itself in your own code, for access to resources, even when your
            code does not know or care about any other parts of Spring. While this couples your code to Spring,
            it really only couples it to this small set of utility classes, which serves as a more capable
            replacement for URL and can be considered equivalent to any other library you would use for this
            purpose.

        2.2.3. Built-in Resource Implementations
            Spring includes several built-in Resource implementations:
            • UrlResource
                UrlResource wraps a java.net.URL and can be used to access any object that is normally accessible
                with a URL, such as files, an HTTPS target, an FTP target, and others. All URLs have a standardized
                String representation, such that appropriate standardized prefixes are used to indicate one URL
                type from another. This includes file: for accessing filesystem paths, https: for accessing resources
                through the HTTPS protocol, ftp: for accessing resources through FTP, and others.
            • ClassPathResource
                This class represents a resource that should be obtained from the classpath. It uses either the
                thread context class loader, a given class loader, or a given class for loading resources.
            • FileSystemResource
                This is a Resource implementation for java.io.File handles. It also supports java.nio.file.Path
                handles, applying Spring’s standard String-based path transformations but performing all
                operations via the java.nio.file.Files API. For pure java.nio.path.Path based support use a
                PathResource instead. FileSystemResource supports resolution as a File and as a URL.
            • PathResource
                This is a Resource implementation for java.nio.file.Path handles, performing all operations and
                transformations via the Path API
            • ServletContextResource
                This is a Resource implementation for ServletContext resources that interprets relative paths within
                the relevant web application’s root directory
            • InputStreamResource
                An InputStreamResource is a Resource implementation for a given InputStream. It should be used only
                if no specific Resource implementation is applicable. In particular, prefer ByteArrayResource or any
                of the file-based Resource implementations where possible
            • ByteArrayResource
                This is a Resource implementation for a given byte array. It creates a ByteArrayInputStream for the
                given byte array.

        2.2.4. The ResourceLoader Interface
            The ResourceLoader interface is meant to be implemented by objects that can return (that is, load)
            Resource instances.
            All application contexts implement the ResourceLoader interface. Therefore, all application contexts
            may be used to obtain Resource instances.

!!!         When you call getResource() on a specific application context, and the location path specified
            doesn’t have a specific prefix, you get back a Resource type that is appropriate to that particular
            application context. For example, assume the following snippet of code was run against a
            ClassPathXmlApplicationContext instance:
                Resource template = ctx.getResource("some/resource/path/myTemplate.txt");
!!!         Against a ClassPathXmlApplicationContext, that code returns a ClassPathResource. If the same
            method were run against a FileSystemXmlApplicationContext instance, it would return a
            FileSystemResource. For a WebApplicationContext, it would return a ServletContextResource. It would
            similarly return appropriate objects for each context.

            On the other hand, you may also force ClassPathResource to be used, regardless of the application
            context type, by specifying the special classpath: prefix, as the following example shows:
                Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");

!!!         Similarly, you can force a UrlResource to be used by specifying any of the standard java.net.URL
            prefixes. The following examples use the file and https prefixes:
                Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");
                Resource template = ctx.getResource("https://myhost.com/resource/path/myTemplate.txt");

        2.2.5. The ResourcePatternResolver Interface
            The ResourcePatternResolver interface is an extension to the ResourceLoader interface which defines
            a strategy for resolving a location pattern (for example, an Ant-style path pattern) into Resource
            objects.

        2.2.6. The ResourceLoaderAware Interface
            The ResourceLoaderAware interface is a special callback interface which identifies components that
            expect to be provided a ResourceLoader reference

!!!         Since an ApplicationContext is a ResourceLoader, the bean could also implement the
            ApplicationContextAware interface and use the supplied application context directly to load
            resources. However, in general, it is better to use the specialized ResourceLoader interface if that is
            all you need. The code would be coupled only to the resource loading interface (which can be
            considered a utility interface) and not to the whole Spring ApplicationContext interface

            For more flexibility (including the ability to autowire fields and multiple parameter methods), consider
            using the annotation-based autowiring features. In that case, the ResourceLoader is autowired into a
            field, constructor argument, or method parameter that expects the ResourceLoader type as long as
            the field, constructor, or method in question carries the @Autowired annotation

        2.2.7. Resources as Dependencies
!!          If the bean itself is going to determine and supply the resource path through some sort of dynamic
            process, it probably makes sense for the bean to use the ResourceLoader or ResourcePatternResolver
            interface to load resources. For example, consider the loading of a template of some sort, where the
            specific resource that is needed depends on the role of the user. If the resources are static, it makes
            sense to eliminate the use of the ResourceLoader interface (or ResourcePatternResolver interface)
            completely, have the bean expose the Resource properties it needs, and expect them to be injected
            into it.

        2.2.8. Application Contexts and Resource Paths
            The classpath*: Prefix
            When constructing an XML-based application context, a location string may use the special
            classpath*: prefix, as the following example shows:
                ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");

            This special prefix specifies that all classpath resources that match the given name must be
            obtained (internally, this essentially happens through a call to ClassLoader.getResources(…)) and
            then merged to form the final application context definition


    2.3. Validation, Data Binding, and Type Conversion
!!      There are pros and cons for considering validation as business logic, and Spring offers a design for
        validation (and data binding) that does not exclude either one of them. Specifically, validation
        should not be tied to the web tier and should be easy to localize, and it should be possible to plug in
        any available validator. Considering these concerns, Spring provides a Validator contract that is
        both basic and eminently usable in every layer of an application

!!      Data binding is useful for letting user input be dynamically bound to the domain model of an
        application (or whatever objects you use to process user input). Spring provides the aptly named
        DataBinder to do exactly that. The Validator and the DataBinder make up the validation package,
        which is primarily used in but not limited to the web layer.

        The BeanWrapper is a fundamental concept in the Spring Framework and is used in a lot of places.
        However, you probably do not need to use the BeanWrapper directly. Because this is reference
        documentation, however, we felt that some explanation might be in order. We explain the
        BeanWrapper in this chapter, since, if you are going to use it at all, you are most likely do so when
        trying to bind data to objects.

        2.3.1. Validation by Using Spring’s Validator Interface
            The Validator interface works by using an Errors object so that, while validating, validators can
            report validation failures to the Errors object.

            The static rejectIfEmpty(..) method on the ValidationUtils class is used to reject the name property
            if it is null or the empty string.

!!          If you want your CustomerValidator to reuse the logic contained within the
            AddressValidator class without resorting to copy-and-paste, you can dependency-inject or
            instantiate an AddressValidator within your CustomerValidato

        2.3.2. Resolving Codes to Error Messages
            This section covers outputting messages that correspond to
            validation errors. In the example shown in the preceding section, we rejected the name and age
            fields. If we want to output the error messages by using a MessageSource, we can do so using the
            error code we provide when rejecting the field ('name' and 'age' in this case). When you call (either
            directly, or indirectly, by using, for example, the ValidationUtils class) rejectValue or one of the
            other reject methods from the Errors interface, the underlying implementation not only registers
            the code you passed in but also registers a number of additional error codes.

            By default, the DefaultMessageCodesResolver is used, which (for example) not only registers a message
            with the code you gave but also registers messages that include the field name you passed to the reject
            method. So, if you reject a field by using rejectValue("age", "too.darn.old"), apart from the
            too.darn.old code, Spring also registers too.darn.old.age and too.darn.old.age.int (the first
            includes the field name and the second includes the type of the field). This is done as a convenience
            to aid developers when targeting error messages.

        2.3.3. Bean Manipulation and the BeanWrapper
!!!         One quite important class in the beans package is the BeanWrapper interface and its corresponding
            implementation (BeanWrapperImpl). As quoted from the javadoc, the BeanWrapper offers functionality
            to set and get property values (individually or in bulk), get property descriptors, and query
            properties to determine if they are readable or writable. Also, the BeanWrapper offers support for
            nested properties, enabling the setting of properties on sub-properties to an unlimited depth. The
            BeanWrapper also supports the ability to add standard JavaBeans PropertyChangeListeners and
            VetoableChangeListeners, without the need for supporting code in the target class. Last but not least,
            the BeanWrapper provides support for setting indexed properties. The BeanWrapper usually is not used
            by application code directly but is used by the DataBinder and the BeanFactory.
            The way the BeanWrapper works is partly indicated by its name: it wraps a bean to perform actions
            on that bean, such as setting and retrieving properties.

            (This next section is not vitally important to you if you do not plan to work with the BeanWrapper
            directly. If you use only the DataBinder and the BeanFactory and their default implementations, you
            should skip ahead to the section on PropertyEditors.)

            Built-in PropertyEditor Implementations
            Spring uses the concept of a PropertyEditor to effect the conversion between an Object and a String.
            It can be handy to represent properties in a different way than the object itself. For example, a Date
            can be represented in a human readable way (as the String: '2007-14-09'), while we can still
            convert the human readable form back to the original date (or, even better, convert any date
            entered in a human readable form back to Date objects). This behavior can be achieved by
            registering custom editors of type java.beans.PropertyEditor. Registering custom editors on a
            BeanWrapper or, alternatively, in a specific IoC container (as mentioned in the previous chapter),
            gives it the knowledge of how to convert properties to the desired type.

            A couple of examples where property editing is used in Spring:
                • Parsing HTTP request parameters in Spring’s MVC framework is done by using all kinds of
                PropertyEditor implementations that you can manually bind in all subclasses of the
                CommandController.

            Spring has a number of built-in PropertyEditor implementations to make life easy. They are all
            located in the org.springframework.beans.propertyeditors package. Most, (but not all, as indicated in
            the following table) are, by default, registered by BeanWrapperImpl. Where the property editor is
            configurable in some fashion, you can still register your own variant to override the default one.

            Class                               Explanation
            ByteArrayPropertyEditor             Editor for byte arrays. Converts strings to their corresponding byte
                                                representations. Registered by default by BeanWrapperImpl.
            ClassEditor                         Parses Strings that represent classes to actual classes and vice-versa.
                                                When a class is not found, an IllegalArgumentException is thrown. By
                                                default, registered by BeanWrapperImpl.
            CustomBooleanEditor                 Customizable property editor for Boolean properties. By default,
                                                registered by BeanWrapperImpl but can be overridden by registering a
                                                custom instance of it as a custom editor
            CustomNumberEditor                  Customizable property editor for any Number subclass, such as
                                                Integer, Long, Float, or Double. By default, registered by
                                                BeanWrapperImpl but can be overridden by registering a custom
                                                instance of it as a custom editor.
            FileEditor                          Resolves strings to java.io.File objects. By default, registered by
                                                BeanWrapperImpl.
            PropertiesEditor                    Can convert strings (formatted with the format defined in the
                                                javadoc of the java.util.Properties class) to Properties objects. By
                                                default, registered by BeanWrapperImpl

            If there is a need to register other custom PropertyEditors, several mechanisms are available. The
            most manual approach, which is not normally convenient or recommended, is to use the
            registerCustomEditor() method of the ConfigurableBeanFactory interface, assuming you have a
            BeanFactory reference. Another (slightly more convenient) mechanism is to use a special bean
            factory post-processor called CustomEditorConfigurer. Although you can use bean factory postprocessors with
            BeanFactory implementations, the CustomEditorConfigurer has a nested property
            setup, so we strongly recommend that you use it with the ApplicationContext, where you can deploy
            it in similar fashion to any other bean and where it can be automatically detected and applied.

                Dan: too detailed for now..see in the docs for more info

        2.3.4. Spring Type Conversion
            Spring 3 introduced a core.convert package that provides a general type conversion system. The
            system defines an SPI to implement type conversion logic and an API to perform type conversions
            at runtime. Within a Spring container, you can use this system as an alternative to PropertyEditor
            implementations to convert externalized bean property value strings to the required property
            types. You can also use the public API anywhere in your application where type conversion is
            needed.

            Converter SPI
            To create your own converter, implement the org.springframework.core.convert.converter.Converter interface
            and parameterize S as the type you are converting from and T as the type you are converting to

            For each call to convert(S), the source argument is guaranteed to not be null. Your Converter may
            throw any unchecked exception if conversion fails. Specifically, it should throw an
            IllegalArgumentException to report an invalid source value. Take care to ensure that your Converter
            implementation is thread-safe.

            Using ConverterFactory
            When you need to centralize the conversion logic for an entire class hierarchy (for example, when
            converting from String to Enum objects), you can implement ConverterFactory

            Using GenericConverter
            When you require a sophisticated Converter implementation, consider using the GenericConverter
            interface. With a more flexible but less strongly typed signature than Converter, a GenericConverter
            supports converting between multiple source and target types. In addition, a GenericConverter
            makes available source and target field context that you can use when you implement your
            conversion logic.

            A good example of a GenericConverter is a converter that converts between a Java array and a
            collection. Such an ArrayToCollectionConverter introspects the field that declares the target
            collection type to resolve the collection’s element type. This lets each element in the source array be
            converted to the collection element type before the collection is set on the target field.

!!!         Because GenericConverter is a more complex SPI interface, you should use it only
            when you need it. Favor Converter or ConverterFactory for basic type conversion needs.

            Using ConditionalGenericConverter
            Sometimes, you want a Converter to run only if a specific condition holds true. For example, you
            might want to run a Converter only if a specific annotation is present on the target field, or you
            might want to run a Converter only if a specific method (such as a static valueOf method) is defined
            on the target class.

            A good example of a ConditionalGenericConverter is an IdToEntityConverter that converts between a
            persistent entity identifier and an entity reference. Such an IdToEntityConverter might match only
            if the target entity type declares a static finder method (for example, findAccount(Long)). You might
            perform such a finder method check in the implementation of matches(TypeDescriptor,
            TypeDescriptor).

            The ConversionService API
            ConversionService defines a unified API for executing type conversion logic at runtime. Converters
            are often run behind the following facade interface:ConversionService

            Configuring a ConversionService
            A ConversionService is a stateless object designed to be instantiated at application startup and then
            shared between multiple threads. In a Spring application, you typically configure a
            ConversionService instance for each Spring container (or ApplicationContext). Spring picks up that
            ConversionService and uses it whenever a type conversion needs to be performed by the
            framework. You can also inject this ConversionService into any of your beans and invoke it directly.
            If no ConversionService is registered with Spring, the original PropertyEditor-based
            system is used.

        2.3.5. Spring Field Formatting
            It provides a unified ConversionService API as well as a strongly typed Converter SPI for implementing
            conversion logic from one type to another. A Spring container uses this system to bind bean
            property values. In addition, both the Spring Expression Language (SpEL) and DataBinder use this
            system to bind field values.

            In general, you can use the Converter SPI when you need to implement general-purpose type
            conversion logic — for example, for converting between a java.util.Date and a Long. You can use
            the Formatter SPI when you work in a client environment (such as a web application) and need to
            parse and print localized field values. The ConversionService provides a unified type conversion API
            for both SPIs.

            To create your own Formatter, implement the Formatter interface shown earlier.

            The format subpackages provide several Formatter implementations as a convenience. The number
            package provides NumberStyleFormatter, CurrencyStyleFormatter, and PercentStyleFormatter to
            format Number objects that use a java.text.NumberFormat. The datetime package provides a
            DateFormatter to format java.util.Date objects with a java.text.DateFormat

            Annotation-driven Formatting
            Field formatting can be configured by field type or annotation. To bind an annotation to a
            Formatter, implement AnnotationFormatterFactory.

            To create an implementation:
                1. Parameterize A to be the field annotationType with which you wish to associate formatting
                logic — for example org.springframework.format.annotation.DateTimeFormat.
                2. Have getFieldTypes() return the types of fields on which the annotation can be used.
                3. Have getPrinter() return a Printer to print the value of an annotated field.
                4. Have getParser() return a Parser to parse a clientValue for an annotated field.
            The following example AnnotationFormatterFactory implementation binds the @NumberFormat
            annotation to a formatter to let a number style or pattern be specified
                (Dan: too detailed for now...still a nice way to format values)

        2.3.6. Configuring a Global Date and Time Format
            By default, date and time fields not annotated with @DateTimeFormat are converted from strings by
            using the DateFormat.SHORT style. If you prefer, you can change this by defining your own global
            format.
                (Dan: too detailed for now..see in the book if you ever need this)

        2.3.7. Java Bean Validation
            Overview of Bean Validation
            Bean Validation provides a common way of validation through constraint declaration and metadata
            for Java applications. To use it, you annotate domain model properties with declarative validation
            constraints which are then enforced by the runtime. There are built-in constraints, and you can
            also define your own custom constraints

                public class PersonForm {
                  @NotNull
                  @Size(max=64)
                  private String name;

                  @Min(0)
                  private int age;
                }

            A Bean Validation validator then validates instances of this class based on the declared constraints.
            See Bean Validation for general information about the API. See the Hibernate Validator
            documentation for specific constraints. To learn how to set up a bean validation provider as a
            Spring bean, keep reading.

            The following example shows a custom @Constraint declaration followed by an associated
            ConstraintValidator implementation that uses Spring for dependency injection:
                Dan: nice but too detailed for now

    2.4. Spring Expression Language (SpEL)
!!!     The Spring Expression Language (“SpEL” for short) is a powerful expression language that supports
        querying and manipulating an object graph at runtime. The language syntax is similar to Unified EL
        but offers additional features, most notably method invocation and basic string templating
        functionality.

        the Spring Expression Language was created to provide the Spring community with
        a single well supported expression language that can be used across all the products in the Spring

        This chapter covers the features of the expression language, its API, and its language syntax. In
        several places, Inventor and Society classes are used as the target objects for expression evaluation.
        These class declarations and the data used to populate them are listed at the end of the chapter.

        The expression language supports the following functionality:
            • Literal expressions
            • Boolean and relational operators
            • Regular expressions
            • Class expressions
            • Accessing properties, arrays, lists, and maps
            • Method invocation
            • Relational operators
            • Assignment
            • Calling constructors
            • Bean references
            • Array construction
            • Inline lists
            • Inline maps
            • Ternary operator
            • Variables
            • User-defined functions
            • Collection projection
            • Collection selection
            • Templated expressions

        2.4.1. Evaluation
            The ExpressionParser interface is responsible for parsing an expression string. In the preceding
            example, the expression string is a string literal denoted by the surrounding single quotation
            marks. The Expression interface is responsible for evaluating the previously defined expression
            string. Two exceptions that can be thrown, ParseException and EvaluationException, when calling
            parser.parseExpression and exp.getValue, respectively.

            SpEL supports a wide range of features, such as calling methods, accessing properties, and calling
            constructors.

            SpEL also supports nested properties by using the standard dot notation (such as prop1.prop2.prop3)
            and also the corresponding setting of property values. Public fields may also be accessed.

            The more common usage of SpEL is to provide an expression string that is evaluated against a
            specific object instance (called the root object).

            Understanding EvaluationContext
            The EvaluationContext interface is used when evaluating an expression to resolve properties,
            methods, or fields and to help perform type conversion. Spring provides two implementations.
            • SimpleEvaluationContext: Exposes a subset of essential SpEL language features and
            configuration options, for categories of expressions that do not require the full extent of the
            SpEL language syntax and should be meaningfully restricted. Examples include but are not
            limited to data binding expressions and property-based filters.
            • StandardEvaluationContext: Exposes the full set of SpEL language features and configuration
            options. You can use it to specify a default root object and to configure every available
            evaluation-related strategy.

            Type Conversion
            By default, SpEL uses the conversion service available in Spring core
            (org.springframework.core.convert.ConversionService). This conversion service comes with many
            built-in converters for common conversions but is also fully extensible so that you can add custom
            conversions between types. Additionally, it is generics-aware

            Parser Configuration
            It is possible to configure the SpEL expression parser by using a parser configuration object
            (org.springframework.expression.spel.SpelParserConfiguration). The configuration object controls
            the behavior of some of the expression components. For example, if you index into an array or
            collection and the element at the specified index is null, SpEL can automatically create the element.
            This is useful when using expressions made up of a chain of property references

            SpEL Compilation
            Spring Framework 4.1 includes a basic expression compiler. Expressions are usually interpreted,
            which provides a lot of dynamic flexibility during evaluation but does not provide optimum
            performance. For occasional expression usage, this is fine, but, when used by other components
            such as Spring Integration, performance can be very important, and there is no real need for the
            dynamism

            The SpEL compiler is intended to address this need. During evaluation, the compiler generates a
            Java class that embodies the expression behavior at runtime and uses that class to achieve much
            faster expression evaluation.

            Consider the following basic expression:
                someArray[0].someProperty.someOtherProperty < 0.1
            Because the preceding expression involves array access, some property de-referencing, and
            numeric operations, the performance gain can be very noticeable. In an example micro benchmark
            run of 50000 iterations, it took 75ms to evaluate by using the interpreter and only 3ms using the
            compiled version of the expression.

            Compiler Configuration
            The compiler is not turned on by default, but you can turn it on in either of two different ways. You
            can turn it on by using the parser configuration process (discussed earlier) or by using a Spring
            property when SpEL usage is embedded inside another component.
                Dan: this is getting too detailed for now..

        2.4.2. Expressions in Bean Definitions
            You can use SpEL expressions with XML-based or annotation-based configuration metadata for
            defining BeanDefinition instances. In both cases, the syntax to define the expression is of the form
            #{ <expression string> }.

            All beans in the application context are available as predefined variables with their common bean
            name. This includes standard context beans such as environment (of type
            org.springframework.core.env.Environment) as well as systemProperties and systemEnvironment (of
            type Map<String, Object>) for access to the runtime environment.

            Annotation Configuration
            To specify a default value, you can place the @Value annotation on fields, methods, and method or
            constructor parameters.

        2.4.3. Language Reference
            This section describes how the Spring Expression Language works. It covers the following topics:
                Dan: too detailed for now..

            Methods
            You can invoke methods by using typical Java programming syntax. You can also invoke methods
            on literals. Variable arguments are also supported.

            The #this and #root Variables
            The #this variable is always defined and refers to the current evaluation object (against which
            unqualified references are resolved). The #root variable is always defined and refers to the root
            context object. Although #this may vary as components of an expression are evaluated, #root
            always refers to the root

            Dan: too detailed for now..

    2.5. Aspect Oriented Programming with Spring
!!!     Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by
        providing another way of thinking about program structure. The key unit of modularity in OOP is
        the class, whereas in AOP the unit of modularity is the aspect. Aspects enable the modularization of
        concerns (such as transaction management) that cut across multiple types and objects. (Such
        concerns are often termed “crosscutting” concerns in AOP literature.)
        One of the key components of Spring is the AOP framework. While the Spring IoC container does
        not depend on AOP (meaning you do not need to use AOP if you don’t want to), AOP complements
        Spring IoC to provide a very capable middleware solution.

        Spring provides simple and powerful ways of writing custom aspects by using either a
        schema-based approach or the @AspectJ annotation style.

        AOP is used in the Spring Framework to:
            • Provide declarative enterprise services. The most important such service is declarative
            transaction management.
            • Let users implement custom aspects, complementing their use of OOP with AOP.

        If you are interested only in generic declarative services or other pre-packaged
        declarative middleware services such as pooling, you do not need to work directly
        with Spring AOP, and can skip most of this chapter.

Dan: this entire chapter is important !!!!
!!!!!   2.5.1. AOP Concepts
            Let us begin by defining some central AOP concepts and terminology. These terms are not Spring specific.
            Unfortunately, AOP terminology is not particularly intuitive. However, it would be even
            more confusing if Spring used its own terminology.

            • Aspect: A modularization of a concern that cuts across multiple classes. Transaction
            management is a good example of a crosscutting concern in enterprise Java applications. In
            Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or
            regular classes annotated with the @Aspect annotation (the @AspectJ style).
            • Join point: A point during the execution of a program, such as the execution of a method or the
            handling of an exception. In Spring AOP, a join point always represents a method execution.
            • Advice: Action taken by an aspect at a particular join point. Different types of advice include
            “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP
            frameworks, including Spring, model an advice as an interceptor and maintain a chain of
            interceptors around the join point.
            • Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression
            and runs at any join point matched by the pointcut (for example, the execution of a method
            with a certain name). The concept of join points as matched by pointcut expressions is central to
            AOP, and Spring uses the AspectJ pointcut expression language by default.
            • Introduction: Declaring additional methods or fields on behalf of a type. Spring AOP lets you
            introduce new interfaces (and a corresponding implementation) to any advised object. For
            example, you could use an introduction to make a bean implement an IsModified interface, to
            simplify caching. (An introduction is known as an inter-type declaration in the AspectJ
            community.)
            • Target object: An object being advised by one or more aspects. Also referred to as the “advised
            object”. Since Spring AOP is implemented by using runtime proxies, this object is always a
            proxied object.
            • AOP proxy: An object created by the AOP framework in order to implement the aspect contracts
            (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic
            proxy or a CGLIB proxy.
            • Weaving: linking aspects with other application types or objects to create an advised object. This
            can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime.
            Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.

            Spring AOP includes the following types of advice:
            • Before advice: Advice that runs before a join point but that does not have the ability to prevent
            execution flow proceeding to the join point (unless it throws an exception).
            • After returning advice: Advice to be run after a join point completes normally (for example, if a
            method returns without throwing an exception).
            • After throwing advice: Advice to be run if a method exits by throwing an exception.
            • After (finally) advice: Advice to be run regardless of the means by which a join point exits
            (normal or exceptional return).
            • Around advice: Advice that surrounds a join point such as a method invocation. This is the most
            powerful kind of advice. Around advice can perform custom behavior before and after the
            method invocation. It is also responsible for choosing whether to proceed to the join point or to
            shortcut the advised method execution by returning its own return value or throwing an
            exception

            Around advice is the most general kind of advice. Since Spring AOP, like AspectJ, provides a full
            range of advice types, we recommend that you use the least powerful advice type that can
            implement the required behavior. For example, if you need only to update a cache with the return
            value of a method, you are better off implementing an after returning advice than an around
            advice, although an around advice can accomplish the same thing. Using the most specific advice
            type provides a simpler programming model with less potential for errors.

            The concept of join points matched by pointcuts is the key to AOP, which distinguishes it from older
            technologies offering only interception. Pointcuts enable advice to be targeted independently of the
            object-oriented hierarchy...For example, you can apply an around advice providing declarative
             transaction management to a set of methods that span multiple objects (such as all business
             operations in the service layer).

        2.5.2. Spring AOP Capabilities and Goals
            Spring AOP is implemented in pure Java. There is no need for a special compilation process. Spring
            AOP does not need to control the class loader hierarchy and is thus suitable for use in a servlet
            container or application server

!!!!        Spring AOP’s approach to AOP differs from that of most other AOP frameworks. The aim is not to
            provide the most complete AOP implementation (although Spring AOP is quite capable). Rather, the
            aim is to provide a close integration between AOP implementation and Spring IoC, to help solve
            common problems in enterprise applications

            Thus, for example, the Spring Framework’s AOP functionality is normally used in conjunction with
            the Spring IoC container. Aspects are configured by using normal bean definition syntax (although
            this allows powerful “auto-proxying” capabilities). This is a crucial difference from other AOP
            implementations. You cannot do some things easily or efficiently with Spring AOP, such as advise
            very fine-grained objects (typically, domain objects). AspectJ is the best choice in such cases.
            However, our experience is that Spring AOP provides an excellent solution to most problems in
            enterprise Java applications that are amenable to AOP.

            Spring AOP never strives to compete with AspectJ to provide a comprehensive AOP solution. We
            believe that both proxy-based frameworks such as Spring AOP and full-blown frameworks such as
            AspectJ are valuable and that they are complementary, rather than in competition. Spring
            seamlessly integrates Spring AOP and IoC with AspectJ, to enable all uses of AOP within a consistent
            Spring-based application architecture.

            One of the central tenets of the Spring Framework is that of non-invasiveness. This
            is the idea that you should not be forced to introduce framework-specific classes
            and interfaces into your business or domain model. However, in some places, the
            Spring Framework does give you the option to introduce Spring Frameworkspecific dependencies into your
            codebase. The rationale in giving you such options
            is because, in certain scenarios, it might be just plain easier to read or code some
            specific piece of functionality in such a way. However, the Spring Framework
            (almost) always offers you the choice: You have the freedom to make an informed
            decision as to which option best suits your particular use case or scenario

            One such choice that is relevant to this chapter is that of which AOP framework
            (and which AOP style) to choose. You have the choice of AspectJ, Spring AOP, or
            both. You also have the choice of either the @AspectJ annotation-style approach or
            the Spring XML configuration-style approach

        2.5.3. AOP Proxies
            Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any
            interface (or set of interfaces) to be proxied.
            Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. By
            default, CGLIB is used if a business object does not implement an interface. As it is good practice to
            program to interfaces rather than classes, business classes normally implement one or more
            business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where
            you need to advise a method that is not declared on an interface

        2.5.4. @AspectJ support
!!!         @AspectJ refers to a style of declaring aspects as regular Java classes annotated with annotations.
            The @AspectJ style was introduced by the AspectJ project as part of the AspectJ 5 release. Spring
            interprets the same annotations as AspectJ 5, using a library supplied by AspectJ for pointcut
            parsing and matching. The AOP runtime is still pure Spring AOP, though, and there is no
            dependency on the AspectJ compiler or weaver.

            Enabling @AspectJ Support
                To use @AspectJ aspects in a Spring configuration, you need to enable Spring support for
                configuring Spring AOP based on @AspectJ aspects and auto-proxying beans based on whether or
                not they are advised by those aspects. By auto-proxying, we mean that, if Spring determines that a
                bean is advised by one or more aspects, it automatically generates a proxy for that bean to intercept
                method invocations and ensures that advice is run as needed.

!!!!            The @AspectJ support can be enabled with XML- or Java-style configuration. In either case, you also
                need to ensure that AspectJ’s aspectjweaver.jar library is on the classpath of your application
                (version 1.8 or later). This library is available in the lib directory of an AspectJ distribution or from
                the Maven Central repository.

                To enable @AspectJ support with Java @Configuration, add the @EnableAspectJAutoProxy annotation

!!!!        Declaring an Aspect
                With @AspectJ support enabled, any bean defined in your application context with a class that is an
                @AspectJ aspect (has the @Aspect annotation) is automatically detected by Spring and used to
                configure Spring AOP.

                Aspects (classes annotated with @Aspect) can have methods and fields, the same as any other class.
                They can also contain pointcut, advice, and introduction (inter-type) declarations.

!!!!            You can register aspect classes as regular beans in your Spring XML configuration,
                via @Bean methods in @Configuration classes, or have Spring autodetect them
                through classpath scanning — the same as any other Spring-managed bean.
                However, note that the @Aspect annotation is not sufficient for autodetection in the
                classpath. For that purpose, you need to add a separate @Component annotation (or,
                alternatively, a custom stereotype annotation that qualifies, as per the rules of
                Spring’s component scanner).

!!!!!           In Spring AOP, aspects themselves cannot be the targets of advice from other
                aspects. The @Aspect annotation on a class marks it as an aspect and, hence,
                excludes it from auto-proxying.

            Declaring a Pointcut
!!!             Pointcuts determine join points of interest and thus enable us to control when advice runs. Spring
                AOP only supports method execution join points for Spring beans, so you can think of a pointcut as
                matching the execution of methods on Spring beans. A pointcut declaration has two parts: a
                signature comprising a name and any parameters and a pointcut expression that determines
                exactly which method executions we are interested in. In the @AspectJ annotation-style of AOP, a
                pointcut signature is provided by a regular method definition, and the pointcut expression is
                indicated by using the @Pointcut annotation (the method serving as the pointcut signature must
                have a void return type).

!!!             An example may help make this distinction between a pointcut signature and a pointcut expression
                clear. The following example defines a pointcut named anyOldTransfer that matches the execution
                of any method named "transfer":

                    @Pointcut("execution(* transfer(..))") // the pointcut expression
                    private void anyOldTransfer() {} // the pointcut signature

                The pointcut expression that forms the value of the @Pointcut annotation is a regular AspectJ
                pointcut expression. For a full discussion of AspectJ’s pointcut language, see the AspectJ
                Programming Guide (and, for extensions, the AspectJ 5 Developer’s Notebook) or one of the books
                on AspectJ

                Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut
                expressions:
                • execution: For matching method execution join points. This is the primary pointcut designator
                to use when working with Spring AOP.
                • within: Limits matching to join points within certain types (the execution of a method declared
                within a matching type when using Spring AOP).
                • this: Limits matching to join points (the execution of methods when using Spring AOP) where
                the bean reference (Spring AOP proxy) is an instance of the given type.
                • target: Limits matching to join points (the execution of methods when using Spring AOP) where
                the target object (application object being proxied) is an instance of the given type.
                • args: Limits matching to join points (the execution of methods when using Spring AOP) where
                the arguments are instances of the given types.
                • @target: Limits matching to join points (the execution of methods when using Spring AOP)
                where the class of the executing object has an annotation of the given type.
                • @args: Limits matching to join points (the execution of methods when using Spring AOP) where
                the runtime type of the actual arguments passed have annotations of the given types.
                • @within: Limits matching to join points within types that have the given annotation (the
                execution of methods declared in types with the given annotation when using Spring AOP).
                • @annotation: Limits matching to join points where the subject of the join point (the method
                being run in Spring AOP) has the given annotation.

!!!!            Because Spring AOP limits matching to only method execution join points, the preceding discussion
                of the pointcut designators gives a narrower definition than you can find in the AspectJ
                programming guide. In addition, AspectJ itself has type-based semantics and, at an execution join
                point, both this and target refer to the same object: the object executing the method. Spring AOP is
                a proxy-based system and differentiates between the proxy object itself (which is bound to this)
                and the target object behind the proxy (which is bound to target).

!!!             Due to the proxy-based nature of Spring’s AOP framework, calls within the target
                object are, by definition, not intercepted. For JDK proxies, only public interface
                method calls on the proxy can be intercepted. With CGLIB, public and protected
                method calls on the proxy are intercepted (and even package-visible methods, if
                necessary). However, common interactions through proxies should always be
                designed through public signatures.

                If your interception needs include method calls or even constructors within the
                target class, consider the use of Spring-driven native AspectJ weaving instead of
                Spring’s proxy-based AOP framework. This constitutes a different mode of AOP
                usage with different characteristics, so be sure to make yourself familiar with
                weaving before making a decision.

                Spring AOP also supports an additional pointcut designator named bean. This pointcut designator lets you
                limit the matching of join points to a particular named Spring bean or to a set of named Spring beans
                (when using wildcards). The bean PCD has the following form:
                    bean(idOrNameOfBean)
                        Dan: i assume this refers to something like   @Pointcut("bean(idOrNameOfBean)")

    !!!         The bean PCD is supported only in Spring AOP and not in native AspectJ weaving. It
                is a Spring-specific extension to the standard PCDs that AspectJ defines and is,
                therefore, not available for aspects declared in the @Aspect model.

                The bean PCD operates at the instance level (building on the Spring bean name
                concept) rather than at the type level only (to which weaving-based AOP is
                limited). Instance-based pointcut designators are a special capability of Spring’s
                proxy-based AOP framework and its close integration with the Spring bean factory,
                where it is natural and straightforward to identify specific beans by name.

            Combining Pointcut Expressions
                @Pointcut("execution(public * *(..))")
                private void anyPublicOperation() {} ①

                @Pointcut("within(com.xyz.myapp.trading..*)")
                private void inTrading() {} ②

                @Pointcut("anyPublicOperation() && inTrading()")
                private void tradingOperation() {} ③

                ① anyPublicOperation matches if a method execution join point represents the execution of any
                public method.
                ② inTrading matches if a method execution is in the trading module.
                ③ tradingOperation matches if a method execution represents any public method in the trading
                module.

    !!!!        It is a best practice to build more complex pointcut expressions out of smaller named components,
                as shown earlier. When referring to pointcuts by name, normal Java visibility rules apply (you can
                see private pointcuts in the same type, protected pointcuts in the hierarchy, public pointcuts
                anywhere, and so on). Visibility does not affect pointcut matching

            Sharing Common Pointcut Definitions
                When working with enterprise applications, developers often want to refer to modules of the
                application and particular sets of operations from within several aspects. We recommend defining
                a CommonPointcuts aspect that captures common pointcut expressions for this purpose.


            Examples
!!              execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?namepattern(param-pattern)throws-pattern?)

                All parts except the returning type pattern (ret-type-pattern in the preceding snippet),
                                 the name pattern,
                                 and the parameters pattern
                are optional.

!!              The returning type pattern determines what the return type of the method must be in order for a join
                point to be matched. * is most frequently used as the returning type pattern. It matches any return
                type. A fully-qualified type name matches only when the method returns the given type.

                The name pattern matches the method name. You can use the * wildcard as all or part of a name pattern.

                The parameters pattern is slightly more
                complex: () matches a method that takes no parameters, whereas (..) matches any number (zero
                or more) of parameters. The (*) pattern matches a method that takes one parameter of any type.
                (*,String) matches a method that takes two parameters. The first can be of any type, while the
                second must be a String. Consult the Language Semantics section of the AspectJ Programming
                Guide for more information

                The following examples show some common pointcut expressions:
                    • The execution of any public method:
                      execution(public * *(..))
                    • The execution of any method with a name that begins with set:
                      execution(* set*(..))
                    • The execution of any method defined by the AccountService interface:
                      execution(* com.xyz.service.AccountService.*(..))
                    • The execution of any method defined in the service package:
                      execution(* com.xyz.service.*.*(..))
                    • Any join point (method execution only in Spring AOP) within the service package:
                      within(com.xyz.service.*)

                Dan: then things get too detailed...and when one needs to write/define such an expression he an go back
                to the document

            Declaring Advice
                Advice is associated with a pointcut expression and runs before, after, or around method
                executions matched by the pointcut

                You can declare before advice in an aspect by using the @Before annotation

                After returning advice runs when a matched method execution returns normally. You can declare it
                by using the @AfterReturning annotation

                After throwing advice runs when a matched method execution exits by throwing an exception. You
                can declare it by using the @AfterThrowing annotation,

                Often, you want the advice to run only when exceptions of a given type are thrown, and you also
                often need access to the thrown exception in the advice body. You can use the throwing attribute to
                both restrict matching (if desired — use Throwable as the exception type otherwise) and bind the
                thrown exception to an advice parameter

                After (finally) advice runs when a matched method execution exits. It is declared by using the
                @After annotation. After advice must be prepared to handle both normal and exception return
                conditions. It is typically used for releasing resources and similar purposes

                The last kind of advice is around advice. Around advice runs "around" a matched method’s
                execution. It has the opportunity to do work both before and after the method runs and to
                determine when, how, and even if the method actually gets to run at all. Around advice is often
                used if you need to share state before and after a method execution in a thread-safe manner – for
                example, starting and stopping a timer.

!!!             Always use the least powerful form of advice that meets your requirements.
!!!             For example, do not use around advice if before advice is sufficient for your needs.

            Passing Parameters to Advice
                We have already seen how to bind the returned value or exception value (using after returning and
                after throwing advice). To make argument values available to the advice body, you can use the
                binding form of args. If you use a parameter name in place of a type name in an args expression,
                the value of the corresponding argument is passed as the parameter value when the advice is
                invoked. An example should make this clearer. Suppose you want to advise the execution of DAO
                operations that take an Account object as the first parameter, and you need access to the account in
                the advice body. You could write the following:

                    @Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")
                    public void validateAccount(Account account) {
                      // ...
                    }

                The args(account,..) part of the pointcut expression serves two purposes. First, it restricts
                matching to only those method executions where the method takes at least one parameter, and the
                argument passed to that parameter is an instance of Account. Second, it makes the actual Account
                object available to the advice through the account parameter.

            Advice Ordering
                What happens when multiple pieces of advice all want to run at the same join point? Spring AOP
                follows the same precedence rules as AspectJ to determine the order of advice execution. The
                highest precedence advice runs first "on the way in" (so, given two pieces of before advice, the one
                with highest precedence runs first). "On the way out" from a join point, the highest precedence
                advice runs last (so, given two pieces of after advice, the one with the highest precedence will run
                second).

!!!             When two pieces of advice defined in different aspects both need to run at the same join point,
                unless you specify otherwise, the order of execution is undefined. You can control the order of
                execution by specifying precedence. This is done in the normal Spring way by either implementing
                the org.springframework.core.Ordered interface in the aspect class or annotating it with the @Order
                annotation. Given two aspects, the aspect returning the lower value from Ordered.getOrder() (or the
                annotation value) has the higher precedence.

                As of Spring Framework 5.2.7, advice methods defined in the same @Aspect class
                that need to run at the same join point are assigned precedence based on their
                advice type in the following order, from highest to lowest precedence: @Around,
                @Before, @After, @AfterReturning, @AfterThrowing. Note, however, that an @After
                advice method will effectively be invoked after any @AfterReturning or
                @AfterThrowing advice methods in the same aspect, following AspectJ’s "after
                finally advice" semantics for @After.

            Aspect Instantiation Models

                By default, there is a single instance of each aspect within the application context. AspectJ calls this
                the singleton instantiation model. It is possible to define aspects with alternate lifecycles. Spring
                supports AspectJ’s perthis and pertarget instantiation models; percflow, percflowbelow, and
                pertypewithin are not currently supported.

                In the preceding example, the effect of the perthis clause is that one aspect instance is created for
                each unique service object that performs a business service (each unique object bound to this at
                join points matched by the pointcut expression). The aspect instance is created the first time that a
                method is invoked on the service object. The aspect goes out of scope when the service object goes
                out of scope. Before the aspect instance is created, none of the advice within it runs. As soon as the
                aspect instance has been created, the advice declared within it runs at matched join points, but only
                when the service object is the one with which this aspect is associated.

                This is an advanced topic. If you are just starting out with AOP, you can safely skip
                it until later.

                    Dan: i guess i can listen to them :)

            An AOP Example
                Now that you have seen how all the constituent parts work, we can put them together to do
                something useful.
                The execution of business services can sometimes fail due to concurrency issues (for example, a
                deadlock loser). If the operation is retried, it is likely to succeed on the next try. For business
                services where it is appropriate to retry in such conditions (idempotent operations that do not need
                to go back to the user for conflict resolution), we want to transparently retry the operation to avoid
                the client seeing a PessimisticLockingFailureException. This is a requirement that clearly cuts
                across multiple services in the service layer and, hence, is ideal for implementing through an
                aspect.
                Because we want to retry the operation, we need to use around advice so that we can call proceed
                multiple times


        2.5.5. Schema-based AOP Support
            If you prefer an XML-based format, Spring also offers support for defining aspects using the aop
            namespace tags. The exact same pointcut expressions and advice kinds as when using the @AspectJ

            style are supported. Hence, in this section we focus on that syntax and refer the reader to the
            discussion in the previous section (@AspectJ support) for an understanding of writing pointcut
            expressions and the binding of advice parameters.

            Dan: i moved faster with this, because it is the same thing but using XML configuration...

            Around Advice
                The last kind of advice is around advice. Around advice runs "around" a matched method’s
                execution. It has the opportunity to do work both before and after the method runs and to
                determine when, how, and even if the method actually gets to run at all. Around advice is often
                used if you need to share state before and after a method execution in a thread-safe manner – for
                example, starting and stopping a timer

        2.5.6. Choosing which AOP Declaration Style to Use
!!!         Once you have decided that an aspect is the best approach for implementing a given requirement,
            how do you decide between using Spring AOP or AspectJ and between the Aspect language (code)
            style, the @AspectJ annotation style, or the Spring XML style? These decisions are influenced by a
            number of factors including application requirements, development tools, and team familiarity
            with AOP.

            Spring AOP or Full AspectJ?
!!!!            Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ, as there is no
                requirement to introduce the AspectJ compiler / weaver into your development and build
                processes. If you only need to advise the execution of operations on Spring beans, Spring AOP is the
                right choice. If you need to advise objects not managed by the Spring container (such as domain
                objects, typically), you need to use AspectJ. You also need to use AspectJ if you wish to advise join
                points other than simple method executions (for example, field get or set join points and so on)

            @AspectJ or XML for Spring AOP?
                If you have chosen to use Spring AOP, you have a choice of @AspectJ or XML style. There are
                various tradeoffs to consider.
                The XML style may be most familiar to existing Spring users, and it is backed by genuine POJOs.
                When using AOP as a tool to configure enterprise services, XML can be a good choice (a good test is
                whether you consider the pointcut expression to be a part of your configuration that you might
                want to change independently). With the XML style, it is arguably clearer from your configuration
                which aspects are present in the system

                The XML style has two disadvantages. First, it does not fully encapsulate the implementation of the
                 requirement it addresses in a single place. The DRY principle says that there should be a single,
                 unambiguous, authoritative representation of any piece of knowledge within a system. When using
                 the XML style, the knowledge of how a requirement is implemented is split across the declaration
                 of the backing bean class and the XML in the configuration file. When you use the @AspectJ style,
                 this information is encapsulated in a single module: the aspect. Secondly, the XML style is slightly
                 more limited in what it can express than the @AspectJ stylE

                The @AspectJ style supports additional instantiation models and richer pointcut composition. It has
                the advantage of keeping the aspect as a modular unit. It also has the advantage that the @AspectJ
                aspects can be understood (and thus consumed) both by Spring AOP and by AspectJ. So, if you later
                decide you need the capabilities of AspectJ to implement additional requirements, you can easily
                migrate to a classic AspectJ setup. On balance, the Spring team prefers the @AspectJ style for
                custom aspects beyond simple configuration of enterprise services.

        2.5.8. Proxying Mechanisms
            Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object.
            JDK dynamic proxies are built into the JDK, whereas CGLIB is a common open-source class
            definition library (repackaged into spring-core).
            If the target object to be proxied implements at least one interface, a JDK dynamic proxy is used. All
            of the interfaces implemented by the target type are proxied. If the target object does not
            implement any interfaces, a CGLIB proxy is created.
            If you want to force the use of CGLIB proxying (for example, to proxy every method defined for the
            target object, not only those implemented by its interfaces), you can do so. However, you should
            consider the following issues:
            • With CGLIB, final methods cannot be advised, as they cannot be overridden in runtimegenerated subclasses.

            Understanding AOP Proxies
                Spring AOP is proxy-based. It is vitally important that you grasp the semantics of what that last
                statement actually means before you write your own aspects or use any of the Spring AOP-based
                aspects supplied with the Spring Framework.

                Dan: there is a nice diagram in the book of a normal call...and a call made to a proxy...you can think of the
                proxy as another class that extends the target class, overrides the public methods, and adds some extra
                functionality/advice

                public class SimplePojo implements Pojo {
                  public void foo() {
                  // this next method invocation is a direct call on the 'this' reference
                  this.bar();
                  }
                  public void bar() {
                  // some logic...
                  }
                }

                public class Main {
                  public static void main(String[] args) {
                  Pojo pojo = new SimplePojo();
                  // this is a direct method call on the 'pojo' reference
                  pojo.foo();
                  }
                }

!!!!!           The key thing to understand here is that the client code inside the main(..) method of the Main class
                has a reference to the proxy. This means that method calls on that object reference are calls on the
                proxy. As a result, the proxy can delegate to all of the interceptors (advice) that are relevant to that
                particular method call. However, once the call has finally reached the target object (the SimplePojo
                reference in this case), any method calls that it may make on itself, such as this.bar() or this.foo(),
                are going to be invoked against the this reference, and not the proxy. This has important
                implications. It means that self-invocation is not going to result in the advice associated with a
                method invocation getting a chance to run.

                Okay, so what is to be done about this? The best approach (the term "best" is used loosely here) is to
                refactor your code such that the self-invocation does not happen. This does entail some work on
                your part, but it is the best, least-invasive approach.

                public class SimplePojo implements Pojo {
                  public void foo() {
                  // this works, but... gah!
                  ((Pojo) AopContext.currentProxy()).bar();
                  }
                  public void bar() {
                  // some logic...
                  }
                }

                This totally couples your code to Spring AOP, and it makes the class itself aware of the fact that it is
                being used in an AOP context, which flies in the face of AOP. It also requires some additional
                configuration when the proxy is being created (see in book)

!!!!            Finally, it must be noted that AspectJ does not have this self-invocation issue because it is not a
                proxy-based AOP framework.

        2.5.10. Using AspectJ with Spring Applications
            Everything we have covered so far in this chapter is pure Spring AOP. In this section, we look at
            how you can use the AspectJ compiler or weaver instead of or in addition to Spring AOP if your
            needs go beyond the facilities offered by Spring AOP alone.

            Dan: too detailed for now

            Other Spring aspects for AspectJ
                In addition to the @Configurable aspect, spring-aspects.jar contains an AspectJ aspect that you can
                use to drive Spring’s transaction management for types and methods annotated with the
                @Transactional annotation. This is primarily intended for users who want to use the Spring
                Framework’s transaction support outside of the Spring container.
                The aspect that interprets @Transactional annotations is the AnnotationTransactionAspect. When you
                use this aspect, you must annotate the implementation class (or methods within that class or both),
                not the interface (if any) that the class implements.

!!!!!!          AspectJ follows Java’s rule that annotations on interfaces are not inherited.

                A @Transactional annotation on a class specifies the default transaction semantics for the execution
                of any public operation in the class.
                A @Transactional annotation on a method within the class overrides the default transaction
                semantics given by the class annotation (if present). Methods of any visibility may be annotated,
                including private methods. Annotating non-public methods directly is the only way to get
                transaction demarcation for the execution of such methods

                A First Example
                    Assume that you are an application developer who has been tasked with diagnosing the cause of
                    some performance problems in a system. Rather than break out a profiling tool, we are going to
                    switch on a simple profiling aspect that lets us quickly get some performance metrics. We can then
                    apply a finer-grained profiling tool to that specific area immediately afterwards.


    2.6. Spring AOP APIs
        The previous chapter described the Spring’s support for AOP with @AspectJ and schema-based
        aspect definitions. In this chapter, we discuss the lower-level Spring AOP APIs. For common
        applications, we recommend the use of Spring AOP with AspectJ pointcuts as described in the
        previous chapter.

        2.6.2. Advice API in Spring
            Dan: too detailed for now... will come back to this when i actually need it.

        2.6.3. The Advisor API in Spring
             Dan: too detailed for now... will come back to this when i actually need it.

        2.6.4. Using the ProxyFactoryBean to Create AOP Proxies
             Dan: too detailed for now... will come back to this when i actually need it.

        Dan: this entire chapter is too detailed for now...will come back to it when needed


    2.7. Null-safety
        Although Java does not let you express null-safety with its type system, the Spring Framework now
        provides the following annotations in the org.springframework.lang package to let you declare
        nullability of APIs and fields:
        • @Nullable: Annotation to indicate that a specific parameter, return value, or field can be null.
        • @NonNull: Annotation to indicate that a specific parameter, return value, or field cannot be null
        (not needed on parameters / return values and fields where @NonNullApi and @NonNullFields
        apply, respectively).
        • @NonNullApi: Annotation at the package level that declares non-null as the default semantics for
        parameters and return values.
        • @NonNullFields: Annotation at the package level that declares non-null as the default semantics
        for fields.

        Nullability of types used inside method bodies is outside of the scope of this feature.
        Other common libraries such as Reactor and Spring Data provide null-safe APIs
        that use a similar nullability arrangement, delivering a consistent overall
        experience for Spring application developers.

        In addition to providing an explicit declaration for Spring Framework API nullability, these
        annotations can be used by an IDE (such as IDEA or Eclipse) to provide useful warnings related to
        null-safety in order to avoid NullPointerException at runtime.


    2.8. Data Buffers and Codecs
        Dan: chapter is too detailed for now


    2.9. Logging
        Since Spring Framework 5.0, Spring comes with its own Commons Logging bridge implemented in
        the spring-jcl module. The implementation checks for the presence of the Log4j 2.x API and the
        SLF4J 1.7 API in the classpath and uses the first one of those found as the logging implementation,
        falling back to the Java platform’s core logging facilities (also known as JUL or java.util.logging) if
        neither Log4j 2.x nor SLF4J is available

!!!     For logging needs within application code, prefer direct use of Log4j 2.x, SLF4J, or JUL ( Java platform’s core
        logging facilities (also known as JUL or java.util.logging)).

        A Log implementation may be retrieved via org.apache.commons.logging.LogFactory as in the
        following example.
            Java
            public class MyBean {
              private final Log log = LogFactory.getLog(getClass());
              // ...
            }


    2.10. Ahead of Time Optimizations
        2.10.1. Introduction to Ahead of Time Optimizations
        Spring’s support for AOT optimizations is meant to inspect an ApplicationContext at build time and
        apply decisions and discovery logic that usually happens at runtime. Doing so allows building an
        application startup arrangement that is more straightforward and focused on a fixed set of features
        based mainly on the classpath and the Environment.

        Applying such optimizations early implies the following restrictions:
        • The classpath is fixed and fully defined at build time.
        • The beans defined in your application cannot change at runtime, meaning:
            ◦ @Profile, in particular profile-specific configuration needs to be chosen at build time.
            ◦ Environment properties that impact the presence of a bean (@Conditional) are only
            considered at build time.
        When these restrictions are in place, it becomes possible to perform ahead-of-time processing at
        build time and generate additional assets. A Spring AOT processed application typically generates:
        • Java source code
        • Bytecode (usually for dynamic proxies)
        • RuntimeHints for the use of reflection, resource loading, serialization, and JDK proxies.

!!!     At the moment, AOT is focused on allowing Spring applications to be deployed as
        native images using GraalVM. We intend to offer more JVM-based use cases in
        future generations.

        Dan: this is also something I don't need right now..


========================================================================================================================
Chapter 3. Testing

    This chapter covers Spring’s support for integration testing and best practices for unit testing. The
    Spring team advocates test-driven development (TDD). The Spring team has found that the correct
    use of inversion of control (IoC) certainly does make both unit and integration testing easier (in that
    the presence of setter methods and appropriate constructors on classes makes them easier to wire
    together in a test without having to set up service locator registries and similar structures).


    3.1. Introduction to Spring Testing
        Testing is an integral part of enterprise software development. This chapter focuses on the value
        added by the IoC principle to unit testing and on the benefits of the Spring Framework’s support for
        integration testing


    3.2. Unit Testing
!!!     Dependency injection should make your code less dependent on the container than it would be
        with traditional J2EE / Java EE development. The POJOs that make up your application should be
        testable in JUnit or TestNG tests, with objects instantiated by using the new operator, without Spring
        or any other container. You can use mock objects (in conjunction with other valuable testing
        techniques) to test your code in isolation. If you follow the architecture recommendations for
        Spring, the resulting clean layering and componentization of your codebase facilitate easier unit
        testing. For example, you can test service layer objects by stubbing or mocking DAO or repository
        interfaces, without needing to access persistent data while running unit tests.

        True unit tests typically run extremely quickly, as there is no runtime infrastructure to set up.
        Emphasizing true unit tests as part of your development methodology can boost your productivity.
        You may not need this section of the testing chapter to help you write effective unit tests for your
        IoC-based applications. For certain unit testing scenarios, however, the Spring Framework provides
        mock objects and testing support classes, which are described in this chapter.

        3.2.1. Mock Objects
            Spring includes a number of packages dedicated to mocking:
            • Environment
            • JNDI
            • Servlet API
            • Spring Web Reactive

            Environment
                The org.springframework.mock.env package contains mock implementations of the Environment and
                PropertySource abstractions (see Bean Definition Profiles and PropertySource Abstraction).
                MockEnvironment and MockPropertySource are useful for developing out-of-container tests for code
                that depends on environment-specific properties

            Servlet API
                The org.springframework.mock.web package contains a comprehensive set of Servlet API mock
                objects that are useful for testing web contexts, controllers, and filters. These mock objects are
                targeted at usage with Spring’s Web MVC framework and are generally more convenient to use
                than dynamic mock objects (such as EasyMock) or alternative Servlet API mock objects (such as
                MockObjects).

        3.2.2. Unit Testing Support Classes
            Spring includes a number of classes that can help with unit testing. They fall into two categories:
            • General Testing Utilities
            • Spring MVC Testing Utilities

            General Testing Utilities
!!              The org.springframework.test.util package contains several general purpose utilities for use in unit
                and integration testing.
                AopTestUtils is a collection of AOP-related utility methods. You can use these methods to obtain a
                reference to the underlying target object hidden behind one or more Spring proxies. For example, if
                you have configured a bean as a dynamic mock by using a library such as EasyMock or Mockito,
                and the mock is wrapped in a Spring proxy, you may need direct access to the underlying mock to
                configure expectations on it and perform verifications. For Spring’s core AOP utilities, see AopUtils
                and AopProxyUtils.

!!              ReflectionTestUtils is a collection of reflection-based utility methods. You can use these methods in
                testing scenarios where you need to change the value of a constant, set a non-public field, invoke a
                non-public setter method, or invoke a non-public configuration or lifecycle callback method when
                testing application code for use cases such as the following:
                    • ORM frameworks (such as JPA and Hibernate) that condone private or protected field access as
                    opposed to public setter methods for properties in a domain entity.
                    • Spring’s support for annotations (such as @Autowired, @Inject, and @Resource), that provide
                    dependency injection for private or protected fields, setter methods, and configuration methods.
                    • Use of annotations such as @PostConstruct and @PreDestroy for lifecycle callback methods.

            Spring MVC Testing Utilities
                The org.springframework.test.web package contains ModelAndViewAssert, which you can use in
                combination with JUnit, TestNG, or any other testing framework for unit tests that deal with Spring
                MVC ModelAndView objects

                To unit test your Spring MVC Controller classes as POJOs, use ModelAndViewAssert
                combined with MockHttpServletRequest, MockHttpSession, and so on from Spring’s
                Servlet API mocks.

                For thorough integration testing of your Spring MVC and REST Controller classes in conjunction with your
                WebApplicationContext configuration for Spring MVC, use the Spring MVC Test Framework instead.

    3.3. Integration Testing
        This section (most of the rest of this chapter) covers integration testing for Spring applications

        3.3.1. Overview
            It is important to be able to perform some integration testing without requiring deployment to your
            application server or connecting to other enterprise infrastructure. Doing so lets you test things
            such as:
            • The correct wiring of your Spring IoC container contexts.
            • Data access using JDBC or an ORM tool. This can include such things as the correctness of SQL
            statements, Hibernate queries, JPA entity mappings, and so forth.

!!!!!       the org.springframework.test package, which contains valuable classes for integration testing with a
            Spring container. This testing does not rely on an application server or other deployment environment. Such
            tests are slower to run than unit tests but much faster than the equivalent Selenium tests or remote tests
            that rely on deployment to an application server.

            Unit and integration testing support is provided in the form of the annotation-driven Spring
            TestContext Framework. The TestContext framework is agnostic of the actual testing framework in
            use, which allows instrumentation of tests in various environments, including JUnit, TestNG, and
            others.

        3.3.2. Goals of Integration Testing
            Spring’s integration testing support has the following primary goals:
            • To manage Spring IoC container caching between tests.
            • To provide Dependency Injection of test fixture instances.
            • To provide transaction management appropriate to integration testing.
            • To supply Spring-specific base classes that assist developers in writing integration tests.
            The next few sections describe each goal and provide links to implementation and configuration
            details.

            Context Management and Caching
!!!             The Spring TestContext Framework provides consistent loading of Spring ApplicationContext
                instances and WebApplicationContext instances as well as caching of those contexts. Support for the
                caching of loaded contexts is important, because startup time can become an issue — not because of
                the overhead of Spring itself, but because the objects instantiated by the Spring container take time
                to instantiate. For example, a project with 50 to 100 Hibernate mapping files might take 10 to 20
                seconds to load the mapping files, and incurring that cost before running every test in every test
                fixture leads to slower overall test runs that reduce developer productivity.

!!!              By default, once loaded, the configured ApplicationContext is reused for each test. Thus, the setup
                cost is incurred only once per test suite, and subsequent test execution is much faster. In this
                context, the term “test suite” means all tests run in the same JVM — for example, all tests run from
                an Ant, Maven, or Gradle build for a given project or module. In the unlikely case that a test
                corrupts the application context and requires reloading (for example, by modifying a bean
                definition or the state of an application object) the TestContext framework can be configured to
                reload the configuration and rebuild the application context before executing the next test.

            Dependency Injection of Test Fixtures
                When the TestContext framework loads your application context, it can optionally configure
                instances of your test classes by using Dependency Injection. This provides a convenient
                mechanism for setting up test fixtures by using preconfigured beans from your application context.
                A strong benefit here is that you can reuse application contexts across various testing scenarios (for
                example, for configuring Spring-managed object graphs, transactional proxies, DataSource
                instances, and others), thus avoiding the need to duplicate complex test fixture setup for individual
                test cases.

            Transaction Management
                One common issue in tests that access a real database is their effect on the state of the persistence
                store. Even when you use a development database, changes to the state may affect future tests. Also,
                many operations — such as inserting or modifying persistent data — cannot be performed (or
                verified) outside of a transaction.
!!!             The TestContext framework addresses this issue. By default, the framework creates and rolls back a
                transaction for each test. You can write code that can assume the existence of a transaction.
                In addition, if a test method deletes the contents of selected
                tables while running within the transaction managed for the test, the transaction rolls back by
                default, and the database returns to its state prior to execution of the test.

                If you want a transaction to commit (unusual, but occasionally useful when you want a particular
                test to populate or modify the database), you can tell the TestContext framework to cause the
                transaction to commit instead of roll back by using the @Commit annotation.

!!!!        Support Classes for Integration Testing
                The Spring TestContext Framework provides several abstract support classes that simplify the
                writing of integration tests. These base test classes provide well-defined hooks into the testing
                framework as well as convenient instance variables and methods, which let you access:
                • The ApplicationContext, for performing explicit bean lookups or testing the state of the context
                as a whole.
                • A JdbcTemplate, for executing SQL statements to query the database. You can use such queries to
                confirm database state both before and after execution of database-related application code,
                and Spring ensures that such queries run in the scope of the same transaction as the application
                code.
                In addition, you may want to create your own custom, application-wide superclass with instance
                variables and methods specific to your project.

            3.3.3. JDBC Testing Support
                The org.springframework.test.jdbc package contains JdbcTestUtils, which is a collection of JDBCrelated utility
                functions intended to simplify standard database testing scenarios. Specifically,
                JdbcTestUtils provides the following static utility methods.
                    • countRowsInTable(..): Counts the number of rows in the given table.
                    • countRowsInTableWhere(..): Counts the number of rows in the given table by using the provided
                    WHERE clause.
                    • deleteFromTables(..): Deletes all rows from the specified tables.
                    • deleteFromTableWhere(..): Deletes rows from the given table by using the provided WHERE clause.
                    • dropTables(..): Drops the specified tables.

    !!!         The spring-jdbc module provides support for configuring and launching an
                embedded database, which you can use in integration tests that interact with a
                database. For details, see Embedded Database Support and Testing Data Access
                Logic with an Embedded Database.

            3.3.4. Annotations
                This section covers annotations that you can use when you test Spring applications. It includes the
                following topics:
                • Spring Testing Annotations
                • Standard Annotation Support
                • Spring JUnit 4 Testing Annotations
                • Spring JUnit Jupiter Testing Annotations
                • Meta-Annotation Support for Testing

                Spring Testing Annotations
                The Spring Framework provides the following set of Spring-specific annotations that you can use in
                your unit and integration tests in conjunction with the TestContext framework. See the
                corresponding javadoc for further information, including default attribute values, attribute aliases,
                and other details.
                Spring’s testing annotations include the following:
                • @BootstrapWith
                    is a class-level annotation that you can use to configure how the Spring TestContext
                    Framework is bootstrapped. Specifically, you can use @BootstrapWith to specify a custom
                    TestContextBootstrapper. See the section on bootstrapping the TestContext framework for further
                    details.
                • @ContextConfiguration
                    defines class-level metadata that is used to determine how to load and
                    configure an ApplicationContext for integration tests. Specifically, @ContextConfiguration declares
                    the application context resource locations or the component classes used to load the context.
                    Resource locations are typically XML configuration files or Groovy scripts located in the classpath,
                    while component classes are typically @Configuration classes. However, resource locations can also
                    refer to files and scripts in the file system, and component classes can be @Component classes,
                    @Service classes, and so on.
                • @WebAppConfiguration
                    is a class-level annotation that you can use to declare that the
                    ApplicationContext loaded for an integration test should be a WebApplicationContext. The mere
                    presence of @WebAppConfiguration on a test class ensures that a WebApplicationContext is loaded for
                    the test, using the default value of "file:src/main/webapp" for the path to the root of the web
                    application (that is, the resource base path). The resource base path is used behind the scenes to
                    create a MockServletContext, which serves as the ServletContext for the test’s WebApplicationContext.
                    Note that @WebAppConfiguration must be used in conjunction with @ContextConfiguration, either
                    within a single test class or within a test class hierarchy
                • @ContextHierarchy
                • @ActiveProfiles
                    is a class-level annotation that is used to declare which bean definition profiles
                    should be active when loading an ApplicationContext for an integration test.
                • @TestPropertySource
                    is a class-level annotation that you can use to configure the locations of
                    properties files and inlined properties to be added to the set of PropertySources in the Environment
                    for an ApplicationContext loaded for an integration test.
                • @DynamicPropertySource
                • @DirtiesContext
                    indicates that the underlying Spring ApplicationContext has been dirtied during the
                    execution of a test (that is, the test modified or corrupted it in some manner — for example, by
                    changing the state of a singleton bean) and should be closed. When an application context is
                    marked as dirty, it is removed from the testing framework’s cache and closed. As a consequence,
                    the underlying Spring container is rebuilt for any subsequent test that requires a context with the
                    same configuration metadata.
                    You can use @DirtiesContext as both a class-level and a method-level annotation within the same
                    class or class hierarchy.
                • @TestExecutionListeners
                    is used to register listeners for a particular test class, its subclasses, and its
                    nested classes. If you wish to register a listener globally, you should register it via the automatic
                    discovery mechanism described in TestExecutionListener Configuration.
                • @RecordApplicationEvents
                    is a class-level annotation that is used to instruct the Spring TestContext
                    Framework to record all application events that are published in the ApplicationContext during the
                    execution of a single test.
                    The recorded events can be accessed via the ApplicationEvents API within tests.
                • @Commit
                    indicates that the transaction for a transactional test method should be committed after the
                    test method has completed. You can use @Commit as a direct replacement for @Rollback(false) to
                    more explicitly convey the intent of the code. Analogous to @Rollback, @Commit can also be declared
                    as a class-level or method-level annotation.
                • @Rollback
                    indicates whether the transaction for a transactional test method should be rolled back
                    after the test method has completed. If true, the transaction is rolled back. Otherwise, the
                    transaction is committed (see also @Commit). Rollback for integration tests in the Spring TestContext
                    Framework defaults to true even if @Rollback is not explicitly declared.
                • @BeforeTransaction
                     indicates that the annotated void method should be run before a transaction is
                    started, for test methods that have been configured to run within a transaction by using Spring’s
                    @Transactional annotation. @BeforeTransaction methods are not required to be public and may be
                    declared on Java 8-based interface default methods.
                • @AfterTransaction
                • @Sql
                    is used to annotate a test class or test method to configure SQL scripts to be run against a given
                    database during integration tests. The following example shows how to use it:
                        @Test
                        @Sql({"/test-schema.sql", "/test-user-data.sql"})
                        void userTest() {
                          // run code that relies on the test schema and test data
                        }
                • @SqlConfig
                • @SqlMergeMode
                     is used to annotate a test class or test method to configure whether method-level @Sql
                    declarations are merged with class-level @Sql declarations. If @SqlMergeMode is not declared on a test
                    class or test method, the OVERRIDE merge mode will be used by default. With the OVERRIDE mode,
                    method-level @Sql declarations will effectively override class-level @Sql declarations
                • @SqlGroup
                     is a container annotation that aggregates several @Sql annotations. You can use @SqlGroup
                    natively to declare several nested @Sql annotations, or you can use it in conjunction with Java 8’s
                    support for repeatable annotations, where @Sql can be declared several times on the same class or
                    method, implicitly generating this container annotation.

                Standard Annotation Support
                The following annotations are supported with standard semantics for all configurations of the
                Spring TestContext Framework. Note that these annotations are not specific to tests and can be used
                anywhere in the Spring Framework.
                • @Autowired
                • @Qualifier
                • @Value
                • @Resource (jakarta.annotation) if JSR-250 is present
                • @ManagedBean (jakarta.annotation) if JSR-250 is present
                • @Inject (jakarta.inject) if JSR-330 is present
                • @Named (jakarta.inject) if JSR-330 is present
                • @PersistenceContext (jakarta.persistence) if JPA is present
                • @PersistenceUnit (jakarta.persistence) if JPA is present
                • @Transactional (org.springframework.transaction.annotation) with limited attribute support

                Spring JUnit 4 Testing Annotations
                The following annotations are supported only when used in conjunction with the SpringRunner,
                Spring’s JUnit 4 rules, or Spring’s JUnit 4 support classes:
                • @IfProfileValue
                    indicates that the annotated test is enabled for a specific testing environment. If the
                    configured ProfileValueSource returns a matching value for the provided name, the test is enabled.
                    Otherwise, the test is disabled and, effectively, ignored
                        @IfProfileValue(name="java.vendor", value="Oracle Corporation")
                        @Test
                        public void testProcessWhichRunsOnlyOnOracleJvm() {
                          // some logic that should run only on Java VMs from Oracle Corporation
                        }
                • @ProfileValueSourceConfiguration
                • @Timed
                    indicates that the annotated test method must finish execution in a specified time period (in
                    milliseconds). If the text execution time exceeds the specified time period, the test fails.
                    The time period includes running the test method itself, any repetitions of the test (see @Repeat), as
                    well as any setting up or tearing down of the test fixture.
                • @Repeat
                    indicates that the annotated test method must be run repeatedly. The number of times that
                    the test method is to be run is specified in the annotation.

                Spring JUnit Jupiter Testing Annotations
                The following annotations are supported when used in conjunction with the SpringExtension and
                JUnit Jupiter (that is, the programming model in JUnit 5):
                • @SpringJUnitConfig
                • @SpringJUnitWebConfig
                • @TestConstructor
                • @NestedTestConfiguration
                • @EnabledIf
                     is used to signal that the annotated JUnit Jupiter test class or test method is enabled and
                    should be run if the supplied expression evaluates to true. Specifically, if the expression evaluates to
                    Boolean.TRUE or a String equal to true (ignoring case), the test is enabled. When applied at the class
                    level, all test methods within that class are automatically enabled by default as well.
                • @DisabledIf

                Meta-Annotation Support for Testing
!!!             You can use most test-related annotations as meta-annotations to create custom composed
                annotations and reduce configuration duplication across a test suite.
                    Dan: see in the book what annotations one can use to create custom annotations

            3.3.5. Spring TestContext Framework
                The Spring TestContext Framework (located in the org.springframework.test.context package)
                provides generic, annotation-driven unit and integration testing support that is agnostic of the
                testing framework in use. The TestContext framework also places a great deal of importance on
                convention over configuration, with reasonable defaults that you can override through annotation based
                configuration.

                In addition to generic testing infrastructure, the TestContext framework provides explicit support
                for JUnit 4, JUnit Jupiter (AKA JUnit 5), and TestNG. For JUnit 4 and TestNG, Spring provides abstract
                support classes

                If you are interested only in using the framework and are not interested in extending it with your own
                custom listeners or custom loaders, feel free to go directly to the configuration (context
                management, dependency injection, transaction management), support classes, and annotation
                support sections.
                    Dan: the extending part is too detailed now..not going to go inside that now

                Context Management
                    Each TestContext provides context management and caching support for the test instance for which
                    it is responsible. Test instances do not automatically receive access to the configured
                    ApplicationContext. However, if a test class implements the ApplicationContextAware interface, a
                    reference to the ApplicationContext is supplied to the test instance. Note that
                    AbstractJUnit4SpringContextTests and AbstractTestNGSpringContextTests implement
                    ApplicationContextAware and, therefore, provide access to the ApplicationContext automatically.

                Context Configuration with Component Classes
                    To load an ApplicationContext for your tests by using component classes (see Java-based container
                    configuration), you can annotate your test class with @ContextConfiguration and configure the
                    classes attribute with an array that contains references to component classes. The following
                    example shows how to do so:

                        @ExtendWith(SpringExtension.class)
                        // ApplicationContext will be loaded from AppConfig and TestConfig
                        @ContextConfiguration(classes = {AppConfig.class, TestConfig.class})
                        class MyTest {
                          // class body...
                        }

                    The term “component class” can refer to any of the following:
                        • A class annotated with @Configuration.
                        • A component (that is, a class annotated with @Component, @Service, @Repository,
                        or other stereotype annotations).
                        • A JSR-330 compliant class that is annotated with jakarta.inject annotations.
                        • Any class that contains @Bean-methods.
                        • Any other class that is intended to be registered as a Spring component (i.e., a
                        Spring bean in the ApplicationContext), potentially taking advantage of
                        automatic autowiring of a single constructor without the use of Spring
                        annotations.

                Context Configuration with Environment Profiles
                    The Spring Framework has first-class support for the notion of environments and profiles (AKA
                    "bean definition profiles"), and integration tests can be configured to activate particular bean
                    definition profiles for various testing scenarios. This is achieved by annotating a test class with the
                    @ActiveProfiles annotation and supplying a list of profiles that should be activated when loading
                    the ApplicationContext for the test.

                Context Configuration with Test Property Sources
                    The Spring Framework has first-class support for the notion of an environment with a hierarchy of
                    property sources, and you can configure integration tests with test-specific property sources. In
                    contrast to the @PropertySource annotation used on @Configuration classes, you can declare the
                    @TestPropertySource annotation on a test class to declare resource locations for test properties files
                    or inlined properties. These test property sources are added to the set of PropertySources in the
                    Environment for the ApplicationContext loaded for the annotated integration test.

                Working with Web Mocks
                    To provide comprehensive web testing support, the TestContext framework has a
                    ServletTestExecutionListener that is enabled by default. When testing against a
                    WebApplicationContext, this TestExecutionListener sets up default thread-local state by using Spring
                    Web’s RequestContextHolder before each test method and creates a MockHttpServletRequest, a
                    MockHttpServletResponse, and a ServletWebRequest based on the base resource path configured with
                    @WebAppConfiguration. ServletTestExecutionListener also ensures that the MockHttpServletResponse
                    and ServletWebRequest can be injected into the test instance, and, once the test is complete, it cleans
                    up thread-local state.

                Testing Request- and Session-scoped Beans
                    Spring has supported Request- and session-scoped beans since the early years, and you can test
                    your request-scoped and session-scoped beans by following these steps:
                        • Ensure that a WebApplicationContext is loaded for your test by annotating your test class with
                        @WebAppConfiguration.
                        • Inject the mock request or session into your test instance and prepare your test fixture as
                        appropriate.
                        • Invoke your web component that you retrieved from the configured WebApplicationContext
                        (with dependency injection).
                        • Perform assertions against the mocks.

                Transaction Management
                    In the TestContext framework, transactions are managed by the
                    TransactionalTestExecutionListener, which is configured by default, even if you do not explicitly
                    declare @TestExecutionListeners on your test class. To enable support for transactions, however,
                    you must configure a PlatformTransactionManager bean in the ApplicationContext that is loaded with
                    @ContextConfiguration semantics (further details are provided later). In addition, you must declare
                    Spring’s @Transactional annotation either at the class or the method level for your tests.

                Enabling and Disabling Transactions
             !!!    Annotating a test method with @Transactional causes the test to be run within a transaction that is,
                    by default, automatically rolled back after completion of the test. If a test class is annotated with
                    @Transactional, each test method within that class hierarchy runs within a transaction. Test
                    methods that are not annotated with @Transactional (at the class or method level) are not run
                    within a transaction. Note that @Transactional is not supported on test lifecycle methods — for
                    example, methods annotated with JUnit Jupiter’s @BeforeAll, @BeforeEach, etc. Furthermore, tests
                    that are annotated with @Transactional but have the propagation attribute set to NOT_SUPPORTED or
                    NEVER are not run within a transaction.

                    Transaction Rollback and Commit Behavior
                        By default, test transactions will be automatically rolled back after completion of the test; however,
                        transactional commit and rollback behavior can be configured declaratively via the @Commit and
                        @Rollback annotations. See the corresponding entries in the annotation support section for further
                        details.

                Executing SQL Scripts
                    When writing integration tests against a relational database, it is often beneficial to run SQL scripts
                    to modify the database schema or insert test data into tables. The spring-jdbc module provides
                    support for initializing an embedded or existing database by executing SQL scripts when the Spring
                    ApplicationContext is loaded. See Embedded database support and Testing data access logic with an
                    embedded database for details.
                    Although it is very useful to initialize a database for testing once when the ApplicationContext is
                    loaded, sometimes it is essential to be able to modify the database during integration tests. The
                    following sections explain how to run SQL scripts programmatically and declaratively during
                    integration tests.

                    Executing SQL scripts programmatically
                        Spring provides the following options for executing SQL scripts programmatically within
                        integration test methods.
                        • org.springframework.jdbc.datasource.init.ScriptUtils
                        • org.springframework.jdbc.datasource.init.ResourceDatabasePopulator
                        • org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests
                        • org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests
                        ScriptUtils provides a collection of static utility methods for working with SQL scripts and is
                        mainly intended for internal use within the framework. However, if you require full control over
                        how SQL scripts are parsed and run, ScriptUtils may suit your needs better than some of the other
                        alternatives described later. See the javadoc for individual methods in ScriptUtils for further
                        details.

                        ResourceDatabasePopulator provides an object-based API for programmatically populating,
                        initializing, or cleaning up a database by using SQL scripts defined in external resources.
                        ResourceDatabasePopulator provides options for configuring the character encoding, statement
                        separator, comment delimiters, and error handling flags used when parsing and running the
                        scripts. Each of the configuration options has a reasonable default value

                    Executing SQL scripts declaratively with @Sql
                        In addition to the aforementioned mechanisms for running SQL scripts programmatically, you can
                        declaratively configure SQL scripts in the Spring TestContext Framework. Specifically, you can
                        declare the @Sql annotation on a test class or test method to configure individual SQL statements or
                        the resource paths to SQL scripts that should be run against a given database before or after an
                        integration test method. Support for @Sql is provided by the SqlScriptsTestExecutionListener, which
                        is enabled by default

                        Path Resource Semantics
                        Each path is interpreted as a Spring Resource. A plain path (for example, "schema.sql") is treated as
                        a classpath resource that is relative to the package in which the test class is defined. A path starting
                        with a slash is treated as an absolute classpath resource (for example, "/org/example/schema.sql"). A
                        path that references a URL (for example, a path prefixed with classpath:, file:, http:) is loaded by
                        using the specified resource protocol.
                            @SpringJUnitConfig
                            @Sql("/test-schema.sql")
                            class DatabaseTests {
                              @Test
                              void emptySchemaTest() {
                              // run code that uses the test schema without any test data
                              }
                              @Test
                              @Sql({"/test-schema.sql", "/test-user-data.sql"})
                              void userTest() {
                              // run code that uses the test schema and test data
                              }
                            }

                Parallel Test Execution
                    Spring Framework 5.0 introduced basic support for executing tests in parallel within a single JVM
                    when using the Spring TestContext Framework. In general, this means that most test classes or test
                    methods can be run in parallel without any changes to test code or configuration.

                    Keep in mind that the introduction of concurrency into your test suite can result in unexpected side
                    effects, strange runtime behavior, and tests that fail intermittently or seemingly randomly. The
                    Spring Team therefore provides the following general guidelines for when not to run tests in
                    parallel.

                Constructor Injection
                    If a specific parameter in a constructor for a JUnit Jupiter test class is of type ApplicationContext (or
                    a sub-type thereof) or is annotated or meta-annotated with @Autowired, @Qualifier, or @Value, Spring
                    injects the value for that specific parameter with the corresponding bean or value from the test’s
                    ApplicationContext.

                Method Injection
                    If a parameter in a JUnit Jupiter test method or test lifecycle callback method is of type
                    ApplicationContext (or a sub-type thereof) or is annotated or meta-annotated with @Autowired,
                    @Qualifier, or @Value, Spring injects the value for that specific parameter with the corresponding
                    bean from the test’s ApplicationContext.

            3.3.6. WebTestClient
                WebTestClient is an HTTP client designed for testing server applications. It wraps Spring’s WebClient
                and uses it to perform requests but exposes a testing facade for verifying responses. WebTestClient
                can be used to perform end-to-end HTTP tests. It can also be used to test Spring MVC and Spring
                WebFlux applications without a running server via mock server request and response objects.

                Writing Tests
                    WebTestClient provides an API identical to WebClient up to the point of performing a request by
                    using exchange(). See the WebClient documentation for examples on how to prepare a request with
                    any content including form data, multipart data, and more

            3.3.7. MockMvc
               The Spring MVC Test framework, also known as MockMvc, provides support for testing Spring MVC
               applications. It performs full Spring MVC request handling but via mock request and response
               objects instead of a running server.

               MockMvc can be used on its own to perform requests and verify responses. It can also be used
               through the WebTestClient where MockMvc is plugged in as the server to handle requests with. The
               advantage of WebTestClient is the option to work with higher level objects instead of raw data as
               well as the ability to switch to full, end-to-end HTTP tests against a live server and use the same test
               API.

               MockMvc is a server side test framework that lets you verify most of the functionality of a Spring
               MVC application using lightweight and targeted tests. You can use it on its own to perform requests
               and to verify responses, or you can also use it through the WebTestClient API with MockMvc
               plugged in as the server to handle requests with.

                MockMvc vs End-to-End Tests
                    MockMVc is built on Servlet API mock implementations from the spring-test module and does not
                    rely on a running container. Therefore, there are some differences when compared to full end-toend integration tests with an actual client and a live server running.
                    The easiest way to think about this is by starting with a blank MockHttpServletRequest. Whatever
                    you add to it is what the request becomes. Things that may catch you by surprise are that there is
                    no context path by default; no jsessionid cookie; no forwarding, error, or async dispatches; and,
                    therefore, no actual JSP rendering. Instead, “forwarded” and “redirected” URLs are saved in the
                    MockHttpServletResponse and can be asserted with expectations.
                    This means that, if you use JSPs, you can verify the JSP page to which the request was forwarded,
                    but no HTML is rendered. In other words, the JSP is not invoked. Note, however, that all other
                    rendering technologies that do not rely on forwarding, such as Thymeleaf and Freemarker, render
                    HTML to the response body as expected. The same is true for rendering JSON, XML, and other
                    formats through @ResponseBody methods.

                HtmlUnit Integration
                    Spring provides integration between MockMvc and HtmlUnit. This simplifies performing end-toend
                    testing when using HTML-based views. This integration lets you:
                    • Easily test HTML pages by using tools such as HtmlUnit, WebDriver, and Geb without the need
                    to deploy to a Servlet container.
                    • Test JavaScript within pages.
                    • Optionally, test using mock services to speed up testing.
                    • Share logic between in-container end-to-end tests and out-of-container integration tests.

                    MockMvc works with templating technologies that do not rely on a Servlet
                    Container (for example, Thymeleaf, FreeMarker, and others), but it does not work
                    with JSPs, since they rely on the Servlet container.

                HtmlUnit Integration Options
                    You have a number of options when you want to integrate MockMvc with HtmlUnit:
                    • MockMvc and HtmlUnit: Use this option if you want to use the raw HtmlUnit libraries.
                    • MockMvc and WebDriver: Use this option to ease development and reuse code between
                    integration and end-to-end testing.
                    • MockMvc and Geb: Use this option if you want to use Groovy for testing, ease development, and
                    reuse code between integration and end-to-end testing.


========================================================================================================================
Chapter 4. Data Access

    This part of the reference documentation is concerned with data access and the interaction
    between the data access layer and the business or service layer.
    Spring’s comprehensive transaction management support is covered in some detail, followed by
    thorough coverage of the various data access frameworks and technologies with which the Spring
    Framework integrates.

    4.1. Transaction Management
        Comprehensive transaction support is among the most compelling reasons to use the Spring
        Framework. The Spring Framework provides a consistent abstraction for transaction management
        that delivers the following benefits:
            • A consistent programming model across different transaction APIs, such as Java Transaction
            API (JTA), JDBC, Hibernate, and the Java Persistence API (JPA).
            • Support for declarative transaction management.
            • A simpler API for programmatic transaction management than complex transaction APIs, such
            as JTA.
            • Excellent integration with Spring’s data access abstractions

        4.1.1. Advantages of the Spring Framework’s Transaction Support Model
            Traditionally, EE application developers have had two choices for transaction management: global
            or local transactions, both of which have profound limitations. Global and local transaction
            management is reviewed in the next two sections, followed by a discussion of how the Spring
            Framework’s transaction management support addresses the limitations of the global and local
            transaction models.

            Global Transactions
                Global transactions let you work with multiple transactional resources, typically relational
                databases and message queues. The application server manages global transactions through the
                JTA, which is a cumbersome API (partly due to its exception model). Furthermore, a JTA
                UserTransaction normally needs to be sourced from JNDI, meaning that you also need to use JNDI in
                order to use JTA. The use of global transactions limits any potential reuse of application code, as JTA
                is normally only available in an application server environment.

                Previously, the preferred way to use global transactions was through EJB CMT (Container Managed
                Transaction). CMT is a form of declarative transaction management (as distinguished from
                programmatic transaction management). EJB CMT removes the need for transaction-related JNDI
                lookups, although the use of EJB itself necessitates the use of JNDI. It removes most but not all of the
                need to write Java code to control transactions. The significant downside is that CMT is tied to JTA
                and an application server environment. Also, it is only available if one chooses to implement
                business logic in EJBs (or at least behind a transactional EJB facade). The negatives of EJB in general
                are so great that this is not an attractive proposition, especially in the face of compelling
                alternatives for declarative transaction management.

            Local Transactions
                Local transactions are resource-specific, such as a transaction associated with a JDBC connection.
                Local transactions may be easier to use but have a significant disadvantage: They cannot work
                across multiple transactional resources. For example, code that manages transactions by using a
                JDBC connection cannot run within a global JTA transaction. Because the application server is not
                involved in transaction management, it cannot help ensure correctness across multiple resources.
                (It is worth noting that most applications use a single transaction resource.) Another downside is
                that local transactions are invasive to the programming model.

            Spring Framework’s Consistent Programming Model
!!              Spring resolves the disadvantages of global and local transactions. It lets application developers use
                a consistent programming model in any environment. You write your code once, and it can benefit
                from different transaction management strategies in different environments. The Spring
                Framework provides both declarative and programmatic transaction management. Most users
                prefer declarative transaction management, which we recommend in most cases.
                With programmatic transaction management, developers work with the Spring Framework
                transaction abstraction, which can run over any underlying transaction infrastructure. With the
                preferred declarative model, developers typically write little or no code related to transaction
                management and, hence, do not depend on the Spring Framework transaction API or any other
                transaction API.

            Do you need an application server for transaction management?
                The Spring Framework’s transaction management support changes traditional rules as to
                when an enterprise Java application requires an application server.
                In particular, you do not need an application server purely for declarative transactions
                through EJBs. In fact, even if your application server has powerful JTA capabilities, you may
                decide that the Spring Framework’s declarative transactions offer more power and a more
                productive programming model than EJB CMT.
                Typically, you need an application server’s JTA capability only if your application needs to
                handle transactions across multiple resources, which is not a requirement for many
                applications. Many high-end applications use a single, highly scalable database (such as
                Oracle RAC) instead. Stand-alone transaction managers (such as Atomikos Transactions and
                JOTM) are other options. Of course, you may need other application server capabilities, such
                as Java Message Service (JMS) and Jakarta EE Connector Architecture (JCA).
                The Spring Framework gives you the choice of when to scale your application to a fully
                loaded application server. Gone are the days when the only alternative to using EJB CMT or
                JTA was to write code with local transactions (such as those on JDBC connections) and face a
                hefty rework if you need that code to run within global, container-managed transactions.
                With the Spring Framework, only some of the bean definitions in your configuration file need
                to change (rather than your code).

        4.1.2. Understanding the Spring Framework Transaction Abstraction
            The key to the Spring transaction abstraction is the notion of a transaction strategy. A transaction
            strategy is defined by a TransactionManager, specifically the
            org.springframework.transaction.PlatformTransactionManager interface for imperative transaction
            management and the org.springframework.transaction.ReactiveTransactionManager interface for
            reactive transaction management.

            This is primarily a service provider interface (SPI), although you can use it programmatically from
            your application code. Because PlatformTransactionManager is an interface, it can be easily mocked
            or stubbed as necessary. It is not tied to a lookup strategy, such as JNDI. PlatformTransactionManager
            implementations are defined like any other object (or bean) in the Spring Framework IoC
            container. This benefit alone makes Spring Framework transactions a worthwhile abstraction, even
            when you work with JTA. You can test transactional code much more easily than if it used JTA directly.

            Again, in keeping with Spring’s philosophy, the TransactionException that can be thrown by any of
            the PlatformTransactionManager interface’s methods is unchecked (that is, it extends the
            java.lang.RuntimeException class). Transaction infrastructure failures are almost invariably fatal. In
            rare cases where application code can actually recover from a transaction failure, the application
            developer can still choose to catch and handle TransactionException. The salient point is that
            developers are not forced to do so.

            The getTransaction(..) method returns a TransactionStatus object, depending on a
            TransactionDefinition parameter. The returned TransactionStatus might represent a new
            transaction or can represent an existing transaction, if a matching transaction exists in the current
            call stack. The implication in this latter case is that, as with Jakarta EE transaction contexts, a
            TransactionStatus is associated with a thread of execution.

            The TransactionDefinition interface specifies:
                • Propagation: Typically, all code within a transaction scope runs in that transaction. However,
                you can specify the behavior if a transactional method is run when a transaction context
                already exists. For example, code can continue running in the existing transaction (the common
                case), or the existing transaction can be suspended and a new transaction created. Spring offers
                all of the transaction propagation options familiar from EJB CMT. To read about the semantics of
                transaction propagation in Spring, see Transaction Propagation.
                • Isolation: The degree to which this transaction is isolated from the work of other transactions.
                For example, can this transaction see uncommitted writes from other transactions?
                • Timeout: How long this transaction runs before timing out and being automatically rolled back
                by the underlying transaction infrastructure.
                • Read-only status: You can use a read-only transaction when your code reads but does not
                modify data. Read-only transactions can be a useful optimization in some cases, such as when
                you use Hibernate.

            These settings reflect standard transactional concepts. If necessary, refer to resources that discuss
            transaction isolation levels and other core transaction concepts. Understanding these concepts is
            essential to using the Spring Framework or any transaction management solution.

            The TransactionStatus interface provides a simple way for transactional code to control transaction
            execution and query transaction status. The concepts should be familiar, as they are common to all
            transaction APIs.

!!!         Regardless of whether you opt for declarative or programmatic transaction management in Spring,
            defining the correct TransactionManager implementation is absolutely essential. You typically define
            this implementation through dependency injection.
            TransactionManager implementations normally require knowledge of the environment in which
            they work: JDBC, JTA, Hibernate, and so on. The following examples show how you can define a
            local PlatformTransactionManager implementation (in this case, with plain JDBC.)

!!!!!!      In all Spring transaction setups, application code does not need to change. You can change how
            transactions are managed merely by changing configuration, even if that change means moving
            from local to global transactions or vice versa.

        4.1.3. Synchronizing Resources with Transactions
            This section describes how the application code (directly or indirectly, by using a persistence
            API such as JDBC, Hibernate, or JPA) ensures that these resources are created, reused, and cleaned
            up properly. The section also discusses how transaction synchronization is (optionally) triggered
            through the relevant TransactionManager.

            High-level Synchronization Approach
                The preferred approach is to use Spring’s highest-level template-based persistence integration APIs
                or to use native ORM APIs with transaction-aware factory beans or proxies for managing the native
                resource factories. These transaction-aware solutions internally handle resource creation and
                reuse, cleanup, optional transaction synchronization of the resources, and exception mapping.
                Thus, user data access code does not have to address these tasks but can focus purely on nonboilerplate
                persistence logic. Generally, you use the native ORM API or take a template approach for
                JDBC access by using the JdbcTemplate. These solutions are detailed in subsequent sections of this
                reference documentation.

            Low-level Synchronization Approach
                Classes such as DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), SessionFactoryUtils
                (for Hibernate), and so on exist at a lower level. When you want the application code to deal
                directly with the resource types of the native persistence APIs, you use these classes to ensure that
                proper Spring Framework-managed instances are obtained, transactions are (optionally)
                synchronized, and exceptions that occur in the process are properly mapped to a consistent API.

                For example, in the case of JDBC, instead of the traditional JDBC approach of calling the
                getConnection() method on the DataSource, you can instead use Spring’s
                org.springframework.jdbc.datasource.DataSourceUtils class, as follows:
                    Connection conn = DataSourceUtils.getConnection(dataSource);
                If an existing transaction already has a connection synchronized (linked) to it, that instance is
                returned. Otherwise, the method call triggers the creation of a new connection, which is
                (optionally) synchronized to any existing transaction and made available for subsequent reuse in
                that same transaction.

                This approach also works without Spring transaction management (transaction synchronization is
                optional), so you can use it whether or not you use Spring for transaction management

!!!!            Of course, once you have used Spring’s JDBC support, JPA support, or Hibernate support, you
                generally prefer not to use DataSourceUtils or the other helper classes, because you are much
                happier working through the Spring abstraction than directly with the relevant APIs. For example,
                if you use the Spring JdbcTemplate or jdbc.object package to simplify your use of JDBC, correct
                connection retrieval occurs behind the scenes and you need not write any special code.

        4.1.4. Declarative Transaction Management
            Most Spring Framework users choose declarative transaction management. This
            option has the least impact on application code and, hence, is most consistent with
            the ideals of a non-invasive lightweight container.

            The Spring Framework’s declarative transaction management is made possible with Spring aspect oriented
            programming (AOP). However, as the transactional aspects code comes with the Spring
            Framework distribution and may be used in a boilerplate fashion, AOP concepts do not generally
            have to be understood to make effective use of this code.

            The Spring Framework’s declarative transaction management is similar to EJB CMT, in that you can
            specify transaction behavior (or lack of it) down to the individual method level. You can make a
            setRollbackOnly() call within a transaction context, if necessary. The differences between the two
            types of transaction management are:
                • Unlike EJB CMT, which is tied to JTA, the Spring Framework’s declarative transaction
                management works in any environment. It can work with JTA transactions or local transactions
                by using JDBC, JPA, or Hibernate by adjusting the configuration files.
                • You can apply the Spring Framework declarative transaction management to any class, not
                merely special classes such as EJBs.
                • The Spring Framework offers declarative rollback rules, a feature with no EJB equivalent. Both
                programmatic and declarative support for rollback rules is provided.
                • The Spring Framework lets you customize transactional behavior by using AOP. For example,
                you can insert custom behavior in the case of transaction rollback. You can also add arbitrary
                advice, along with transactional advice. With EJB CMT, you cannot influence the container’s
                transaction management, except with setRollbackOnly().
                • The Spring Framework does not support propagation of transaction contexts across remote
                calls, as high-end application servers do. If you need this feature, we recommend that you use
                EJB. However, consider carefully before using such a feature, because, normally, one does not
                want transactions to span remote calls.

!!!         The concept of rollback rules is important. They let you specify which exceptions (and throwables)
            should cause automatic rollback. You can specify this declaratively, in configuration, not in Java
            code. So, although you can still call setRollbackOnly() on the TransactionStatus object to roll back
            the current transaction back, most often you can specify a rule that MyApplicationException must
            always result in rollback. The significant advantage to this option is that business objects do not
            depend on the transaction infrastructure. For example, they typically do not need to import Spring
            transaction APIs or other Spring APIs.

            Understanding the Spring Framework’s Declarative Transaction Implementation
                It is not sufficient merely to tell you to annotate your classes with the @Transactional annotation,
                add @EnableTransactionManagement to your configuration, and expect you to understand how it all
                works. To provide a deeper understanding, this section explains the inner workings of the Spring
                Framework’s declarative transaction infrastructure in the context of transaction-related issues.

!!!!            The most important concepts to grasp with regard to the Spring Framework’s declarative
                transaction support are that this support is enabled via AOP proxies and that the transactional
                advice is driven by metadata (currently XML- or annotation-based). The combination of AOP with
                transactional metadata yields an AOP proxy that uses a TransactionInterceptor in conjunction with
                an appropriate TransactionManager implementation to drive transactions around method
                invocations.

!!!!            @Transactional commonly works with thread-bound transactions managed by
                PlatformTransactionManager, exposing a transaction to all data access operations
                within the current execution thread. Note: This does not propagate to newly
                started threads within the method.

!!!!                Dan: nice pic added called "Transactions - calling a method on a transactional proxy" in pictures folder
                        below is just a schetch of that pic

                    caller =>   AOP proxy                   => Transaction advisor                                                      => Custom advisor                                                    =>  Target Method
                        (caller called proxy not target)    (transaction created on the way in, commited or rolled back on way out)     (custom interceptors may run before or after transaction advisor)   (where business logic is done)
                           <=     < ============            < ============                                                            < ============                                                        < ============
                    (back to called)

            Example of Declarative Transaction Implementation
                Consider the following interface and its attendant implementation. This example uses Foo and Bar
                classes as placeholders so that you can concentrate on the transaction usage without focusing on a
                particular domain model. For the purposes of this example, the fact that the DefaultFooService class
                throws UnsupportedOperationException instances in the body of each implemented method is good.

                Assume that the first two methods of the FooService interface, getFoo(String) and getFoo(String,
                String), must run in the context of a transaction with read-only semantics and that the other
                methods, insertFoo(Foo) and updateFoo(Foo), must run in the context of a transaction with readwrite
                semantics. The following configuration is explained in detail in the next few paragraphs:
                    Dan: example is in notes, the configuration is done with xml

                Examine the preceding configuration. It assumes that you want to make a service object, the
                fooService bean, transactional. The transaction semantics to apply are encapsulated in the
                <tx:advice/> definition. The <tx:advice/> definition reads as "all methods starting with get are to
                run in the context of a read-only transaction, and all other methods are to run with the default
                transaction semantics". The transaction-manager attribute of the <tx:advice/> tag is set to the name
                of the TransactionManager bean that is going to drive the transactions (in this case, the txManager
                bean).

                The <aop:config/> definition ensures that the transactional advice defined by the txAdvice bean
                runs at the appropriate points in the program. First, you define a pointcut that matches the
                execution of any operation defined in the FooService interface (fooServiceOperation). Then you
                associate the pointcut with the txAdvice by using an advisor. The result indicates that, at the
                execution of a fooServiceOperation, the advice defined by txAdvice is run
                The expression defined within the <aop:pointcut/> element is an AspectJ pointcut expression. See
                the AOP section for more details on pointcut expressions in Spring.

!!!!            A common requirement is to make an entire service layer transactional. The best way to do this is
                to change the pointcut expression to match any operation in your service layer. The following
                example shows how to do so:
                    <aop:config>
                      <aop:pointcut id="fooServiceMethods" expression="execution(*
                    x.y.service.*.*(..))"/>
                      <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
                    </aop:config>
                In the preceding example, it is assumed that all your service interfaces are defined
                in the x.y.service package. See the AOP section for more details.

!!!             The configuration shown earlier is used to create a transactional proxy around the object that is
                created from the fooService bean definition. The proxy is configured with the transactional advice
                so that, when an appropriate method is invoked on the proxy, a transaction is started, suspended,
                marked as read-only, and so on, depending on the transaction configuration associated with that method.

            Rolling Back a Declarative Transaction
                The previous section outlined the basics of how to specify transactional settings for classes,
                typically service layer classes, declaratively in your application. This section describes how you can
                control the rollback of transactions in a simple, declarative fashion in XML configuration. For
                details on controlling rollback semantics declaratively with the @Transactional annotation, see
                @Transactional Settings.

!!!             The recommended way to indicate to the Spring Framework’s transaction infrastructure that a
                transaction’s work is to be rolled back is to throw an Exception from code that is currently
                executing in the context of a transaction. The Spring Framework’s transaction infrastructure code
                catches any unhandled Exception as it bubbles up the call stack and makes a determination
                whether to mark the transaction for rollback.

!!!!            In its default configuration, the Spring Framework’s transaction infrastructure code marks a
                transaction for rollback only in the case of runtime, unchecked exceptions. That is, when the
                thrown exception is an instance or subclass of RuntimeException. (Error instances also, by default,
                result in a rollback). Checked exceptions that are thrown from a transactional method do not result
                in rollback in the default configuration.

                You can configure exactly which Exception types mark a transaction for rollback, including checked
                exceptions by specifying rollback rules.

                Rollback rules determine if a transaction should be rolled back when a given
                exception is thrown, and the rules are based on exception types or exception
                patterns.
!!!             Rollback rules may be configured in XML via the rollback-for and no-rollback-for
                attributes, which allow rules to be defined as patterns. When using @Transactional,
                rollback rules may be configured via the rollbackFor/noRollbackFor and
                rollbackForClassName/noRollbackForClassName attributes, which allow rules to be
                defined based on exception types or patterns, respectively.

                If you do not want a transaction rolled back when an exception is thrown, you can also specify 'no
                rollback' rules. The following example tells the Spring Framework’s transaction infrastructure to
                commit the attendant transaction even in the face of an unhandled InstrumentNotFoundException

                You can also indicate a required rollback programmatically. Although simple, this process is quite
                invasive and tightly couples your code to the Spring Framework’s transaction infrastructure. The
                following example shows how to programmatically indicate a required rollback:

                    public void resolvePosition() {
                      try {
                        // some business logic...
                      } catch (NoProductInStockException ex) {
                        // trigger rollback programmatically
                        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
                      }
                    }

                You are strongly encouraged to use the declarative approach to rollback, if at all possible.
                Programmatic rollback is available should you absolutely need it, but its usage flies in the face of
                achieving a clean POJO-based architecture.

                Configuring Different Transactional Semantics for Different Beans
                Consider the scenario where you have a number of service layer objects, and you want to apply a
                totally different transactional configuration to each of them. You can do so by defining distinct
                <aop:advisor/> elements with differing pointcut and advice-ref attribute values.

                The default <tx:advice/> settings are:
                    • The propagation setting is REQUIRED.
                    • The isolation level is DEFAULT.
                    • The transaction is read-write.
                    • The transaction timeout defaults to the default timeout of the underlying transaction system or
                    none if timeouts are not supported.
                    • Any RuntimeException triggers rollback, and any checked Exception does not.

            Using @Transactional
                In addition to the XML-based declarative approach to transaction configuration, you can use an
                annotation-based approach. Declaring transaction semantics directly in the Java source code puts
                the declarations much closer to the affected code. There is not much danger of undue coupling,
                because code that is meant to be used transactionally is almost always deployed that way anyway

                The ease-of-use afforded by the use of the @Transactional annotation is best illustrated with an
                example, which is explained in the text that follows. Consider the following class definition:
                    // the service class that we want to make transactional
                    @Transactional
                    public class DefaultFooService implements FooService {
                      @Override
                      public Foo getFoo(String fooName) {
                        // ...
                      }
                      @Override
                      public Foo getFoo(String fooName, String barName) {
                        // ...
                      }
                      @Override
                      public void insertFoo(Foo foo) {
                        // ...
                      }
                      @Override
                      public void updateFoo(Foo foo) {
                        // ...
                      }
                    }

!!!!!           Used at the class level as above, the annotation indicates a default for all methods of the declaring
                class (as well as its subclasses). Alternatively, each method can be annotated individually. See
                Method visibility and @Transactional for further details on which methods Spring considers
                transactional. Note that a class-level annotation does not apply to ancestor classes up the class
                hierarchy; in such a scenario, inherited methods need to be locally redeclared in order to
                participate in a subclass-level annotation.

!!              When a POJO class such as the one above is defined as a bean in a Spring context, you can make the
                bean instance transactional through an @EnableTransactionManagement annotation in a
                @Configuration class.

!!              When you use transactional proxies with Spring’s standard configuration, you
                should apply the @Transactional annotation only to methods with public visibility.
                If you do annotate protected, private, or package-visible methods with the
                @Transactional annotation, no error is raised, but the annotated method does not
                exhibit the configured transactional settings

                You can apply the @Transactional annotation to an interface definition, a method on an interface, a
                class definition, or a method on a class. However, the mere presence of the @Transactional
                annotation is not enough to activate the transactional behavior. The @Transactional annotation is
                merely metadata that can be consumed by some runtime infrastructure that is @Transactional
                -aware and that can use the metadata to configure the appropriate beans with transactional behavior.

!!!!            The Spring team recommends that you annotate only concrete classes (and
                methods of concrete classes) with the @Transactional annotation, as opposed to
                annotating interfaces. You certainly can place the @Transactional annotation on an
                interface (or an interface method), but this works only as you would expect it to if
                you use interface-based proxies. The fact that Java annotations are not inherited
                from interfaces means that, if you use class-based proxies (proxy-targetclass="true") or the weaving-based
                aspect (mode="aspectj"), the transaction
                settings are not recognized by the proxying and weaving infrastructure, and the
                object is not wrapped in a transactional proxy.

!!!!            In proxy mode (which is the default), only external method calls coming in
                through the proxy are intercepted. This means that self-invocation (in effect, a
                method within the target object calling another method of the target object) does
                not lead to an actual transaction at runtime even if the invoked method is marked
                with @Transactional. Also, the proxy must be fully initialized to provide the
                expected behavior, so you should not rely on this feature in your initialization
                code — for example, in a @PostConstruct method.

                Consider using AspectJ mode (see the mode attribute in the following table) if you expect selfinvocations
                to be wrapped with transactions as well. In this case, there is no proxy in the first place.
                Instead, the target class is woven (that is, its byte code is modified) to support @Transactional
                runtime behavior on any kind of method.

                The default advice mode for processing @Transactional annotations is proxy, which
                allows for interception of calls through the proxy only. Local calls within the same
                class cannot get intercepted that way. For a more advanced mode of interception,
                consider switching to aspectj mode in combination with compile-time or load-time weaving.

                @EnableTransactionManagement and <tx:annotation-driven/> look for @Transactional
                only on beans in the same application context in which they are defined. This
                means that, if you put annotation-driven configuration in a WebApplicationContext
                for a DispatcherServlet, it checks for @Transactional beans only in your controllers
                and not in your services. See MVC for more information.

                The most derived location takes precedence when evaluating the transactional settings for a
                method. In the case of the following example, the DefaultFooService class is annotated at the class
                level with the settings for a read-only transaction, but the @Transactional annotation on the
                updateFoo(Foo) method in the same class takes precedence over the transactional settings defined at
                the class level.

                    @Transactional(readOnly = true)
                    public class DefaultFooService implements FooService {
                      public Foo getFoo(String fooName) {
                        // ...
                      }
                      // these settings have precedence for this method
                      @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
                      public void updateFoo(Foo foo) {
                        // ...
                      }
                    }

            @Transactional Settings
                The @Transactional annotation is metadata that specifies that an interface, class, or method must
                have transactional semantics (for example, "start a brand new read-only transaction when this
                method is invoked, suspending any existing transaction"). The default @Transactional settings are as
                follows:
                    • The propagation setting is PROPAGATION_REQUIRED.
                    • The isolation level is ISOLATION_DEFAULT.
                    • The transaction is read-write.
                    • The transaction timeout defaults to the default timeout of the underlying transaction system, or
                    to none if timeouts are not supported.
                    • Any RuntimeException or Error triggers rollback, and any checked Exception does not.
                You can change these default settings. The following table summarizes the various properties of the
                @Transactional annotation

                Currently, you cannot have explicit control over the name of a transaction, where 'name' means the
                transaction name that appears in a transaction monitor, if applicable (for example, WebLogic’s
                transaction monitor), and in logging output. For declarative transactions, the transaction name is
                always the fully-qualified class name + . + the method name of the transactionally advised class.
                For example, if the handlePayment(..) method of the BusinessService class started a transaction, the
                name of the transaction would be: com.example.BusinessService.handlePayment.

            Multiple Transaction Managers with @Transactional
                Most Spring applications need only a single transaction manager, but there may be situations
                where you want multiple independent transaction managers in a single application. You can use
                the value or transactionManager attribute of the @Transactional annotation to optionally specify the
                identity of the TransactionManager to be used. This can either be the bean name or the qualifier
                value of the transaction manager bean.

            Custom Composed Annotations
                If you find you repeatedly use the same attributes with @Transactional on many different methods,
                Spring’s meta-annotation support lets you define custom composed annotations for your specific
                use cases. For example, consider the following annotation definitions:

                    @Target({ElementType.METHOD, ElementType.TYPE})
                    @Retention(RetentionPolicy.RUNTIME)
                    @Transactional(transactionManager = "order", label = "causal-consistency")
                    public @interface OrderTx {
                    }

                    @Target({ElementType.METHOD, ElementType.TYPE})
                    @Retention(RetentionPolicy.RUNTIME)
                    @Transactional(transactionManager = "account", label = "retryable")
                    public @interface AccountTx {
                    }
                In the preceding example, we used the syntax to define the transaction manager qualifier and
                transactional labels, but we could also have included propagation behavior, rollback rules,
                timeouts, and other features.

            Transaction Propagation
                This section describes some semantics of transaction propagation in Spring. Note that this section is
                not a proper introduction to transaction propagation. Rather, it details some of the semantics
                regarding transaction propagation in Spring.
                In Spring-managed transactions, be aware of the difference between physical and logical
                transactions, and how the propagation setting applies to this difference.

                PROPAGATION_REQUIRED enforces a physical transaction, either locally for the current scope if no
                    transaction exists yet or participating in an existing 'outer' transaction defined for a larger scope.
                    This is a fine default in common call stack arrangements within the same thread (for example, a
                    service facade that delegates to several repository methods where all the underlying resources
                    have to participate in the service-level transaction).
                    By default, a participating transaction joins the characteristics of the outer scope,
                    silently ignoring the local isolation level, timeout value, or read-only flag (if any).

                    When the propagation setting is PROPAGATION_REQUIRED, a logical transaction scope is created for
                    each method upon which the setting is applied. Each such logical transaction scope can determine
                    rollback-only status individually, with an outer transaction scope being logically independent from
                    the inner transaction scope. In the case of standard PROPAGATION_REQUIRED behavior, all these scopes
                    are mapped to the same physical transaction. So a rollback-only marker set in the inner transaction
                    scope does affect the outer transaction’s chance to actually commit.

                PROPAGATION_REQUIRES_NEW, in contrast to PROPAGATION_REQUIRED, always uses an independent physical
                    transaction for each affected transaction scope, never participating in an existing transaction for an
                    outer scope. In such an arrangement, the underlying resource transactions are different and,
                    hence, can commit or roll back independently, with an outer transaction not affected by an inner
                    transaction’s rollback status and with an inner transaction’s locks released immediately after its
                    completion. Such an independent inner transaction can also declare its own isolation level, timeout,
                    and read-only settings and not inherit an outer transaction’s characteristics.

                PROPAGATION_NESTED uses a single physical transaction with multiple savepoints that it can roll back
                    to. Such partial rollbacks let an inner transaction scope trigger a rollback for its scope, with the
                    outer transaction being able to continue the physical transaction despite some operations having
                    been rolled back. This setting is typically mapped onto JDBC savepoints, so it works only with JDBC
                    resource transactions. See Spring’s DataSourceTransactionManager.

        4.1.5. Programmatic Transaction Management
            The Spring Framework provides two means of programmatic transaction management, by using:
                • The TransactionTemplate or TransactionalOperator.
                • A TransactionManager implementation directly.
            The Spring team generally recommends the TransactionTemplate for programmatic transaction
            management in imperative flows and TransactionalOperator for reactive code. The second
            approach is similar to using the JTA UserTransaction API, although exception handling is less
            cumbersome

            Using the TransactionTemplate
                The TransactionTemplate adopts the same approach as other Spring templates, such as the
                JdbcTemplate. It uses a callback approach (to free application code from having to do the boilerplate
                acquisition and release transactional resources) and results in code that is intention driven, in that
                your code focuses solely on what you want to do.

                As the examples that follow show, using the TransactionTemplate absolutely
                couples you to Spring’s transaction infrastructure and APIs. Whether or not
                programmatic transaction management is suitable for your development needs is
                a decision that you have to make yourself.

                If there is no return value, you can use the convenient TransactionCallbackWithoutResult class with
                an anonymous class
                Code within the callback can roll the transaction back by calling the setRollbackOnly() method on
                the supplied TransactionStatus object

            Specifying Transaction Settings
                You can specify transaction settings (such as the propagation mode, the isolation level, the timeout,
                and so forth) on the TransactionTemplate either programmatically or in configuration. By default,
                TransactionTemplate instances have the default transactional settings.

                Finally, instances of the TransactionTemplate class are thread-safe, in that instances do not maintain
                any conversational state. TransactionTemplate instances do, however, maintain configuration state.
                So, while a number of classes may share a single instance of a TransactionTemplate, if a class needs
                to use a TransactionTemplate with different settings (for example, a different isolation level), you
                need to create two distinct TransactionTemplate instances.

            Using the TransactionalOperator
                The TransactionalOperator follows an operator design that is similar to other reactive operators. It
                uses a callback approach (to free application code from having to do the boilerplate acquisition and
                release transactional resources) and results in code that is intention driven, in that your code
                focuses solely on what you want to do.

                As the examples that follow show, using the TransactionalOperator absolutely
                couples you to Spring’s transaction infrastructure and APIs. Whether or not
                programmatic transaction management is suitable for your development needs is
                a decision that you have to make yourself.

            Using the TransactionManager
                The following sections explain programmatic usage of imperative and reactive transaction managers.

                For imperative transactions, you can use a
                org.springframework.transaction.PlatformTransactionManager directly to manage your transaction.
                To do so, pass the implementation of the PlatformTransactionManager you use to your bean through
                a bean reference. Then, by using the TransactionDefinition and TransactionStatus objects, you can
                initiate transactions, roll back, and commit.

        4.1.6. Choosing Between Programmatic and Declarative Transaction Management
!!!         Programmatic transaction management is usually a good idea only if you have a small number of
            transactional operations. For example, if you have a web application that requires transactions only
            for certain update operations, you may not want to set up transactional proxies by using Spring or
            any other technology. In this case, using the TransactionTemplate may be a good approach. Being
            able to set the transaction name explicitly is also something that can be done only by using the
            programmatic approach to transaction management.
            On the other hand, if your application has numerous transactional operations, declarative
            transaction management is usually worthwhile. It keeps transaction management out of business
            logic and is not difficult to configure. When using the Spring Framework, rather than EJB CMT, the
            configuration cost of declarative transaction management is greatly reduced.

        4.1.7. Transaction-bound Events
            As of Spring 4.2, the listener of an event can be bound to a phase of the transaction. The typical
            example is to handle the event when the transaction has completed successfully. Doing so lets
            events be used with more flexibility when the outcome of the current transaction actually matters
            to the listener.
            You can register a regular event listener by using the @EventListener annotation. If you need to bind
            it to the transaction, use @TransactionalEventListener. When you do so, the listener is bound to the
            commit phase of the transaction by default.
            The next example shows this concept. Assume that a component publishes an order-created event
            and that we want to define a listener that should only handle that event once the transaction in
            which it has been published has committed successfully. The following example sets up such an
            event listener:

                @Component
                public class MyComponent {
                  @TransactionalEventListener
                  public void handleOrderCreatedEvent(CreationEvent<Order> creationEvent) {
                  // ...
                  }
                }
            The @TransactionalEventListener annotation exposes a phase attribute that lets you customize the
            phase of the transaction to which the listener should be bound. The valid phases are BEFORE_COMMIT,
            AFTER_COMMIT (default), AFTER_ROLLBACK, as well as AFTER_COMPLETION which aggregates the transaction
            completion (be it a commit or a rollback).

        4.1.8. Application server-specific integration
            Spring’s transaction abstraction is generally application server-agnostic. Additionally, Spring’s
            JtaTransactionManager class (which can optionally perform a JNDI lookup for the JTA
            UserTransaction and TransactionManager objects) autodetects the location for the latter object, which
            varies by application server. Having access to the JTA TransactionManager allows for enhanced
            transaction semantics — in particular, supporting transaction suspension. See the
            JtaTransactionManager javadoc for details.
            Spring’s JtaTransactionManager is the standard choice to run on Jakarta EE application servers and
            is known to work on all common servers. Advanced functionality, such as transaction suspension,
            works on many servers as well (including GlassFish, JBoss and Geronimo) without any special
            configuration required. However, for fully supported transaction suspension and further advanced
            integration, Spring includes special adapters for WebLogic Server and WebSphere


    4.2. DAO Support
!!!     The Data Access Object (DAO) support in Spring is aimed at making it easy to work with data access
        technologies (such as JDBC, Hibernate, or JPA) in a consistent way. This lets you switch between the
        aforementioned persistence technologies fairly easily, and it also lets you code without worrying
        about catching exceptions that are specific to each technology

        4.2.1. Consistent Exception Hierarchy
!!!         Spring provides a convenient translation from technology-specific exceptions, such as SQLException
            to its own exception class hierarchy, which has DataAccessException as the root exception. These
            exceptions wrap the original exception so that there is never any risk that you might lose any
            information about what might have gone wrong

            In addition to JDBC exceptions, Spring can also wrap JPA- and Hibernate-specific exceptions,
            converting them to a set of focused runtime exceptions. This lets you handle most non-recoverable
            persistence exceptions in only the appropriate layers, without having annoying boilerplate catch and-throw
            blocks and exception declarations in your DAOs

        4.2.2. Annotations Used to Configure DAO or Repository Classes
            The best way to guarantee that your Data Access Objects (DAOs) or repositories provide exception
            translation is to use the @Repository annotation. This annotation also lets the component scanning
            support find and configure your DAOs and repositories without having to provide XML
            configuration entries for them. The following example shows how to use the @Repository annotation:

                @Repository
                public class SomeMovieFinder implements MovieFinder {
                  // ...
                }

!!!!!       Any DAO or repository implementation needs access to a persistence resource, depending on the
            persistence technology used. For example, a JDBC-based repository needs access to a JDBC
            DataSource, and a JPA-based repository needs access to an EntityManager. The easiest way to
            accomplish this is to have this resource dependency injected by using one of the @Autowired,
            @Inject, @Resource or @PersistenceContext annotations. The following example works for a JPA repository:

                @Repository
                public class JpaMovieFinder implements MovieFinder {
                  @PersistenceContext
                  private EntityManager entityManager;
                  // ...
                }

!!!         If you use the classic Hibernate APIs, you can inject SessionFactory, as the following example shows:
                @Repository
                public class HibernateMovieFinder implements MovieFinder {
                  private SessionFactory sessionFactory;
                  @Autowired
                  public void setSessionFactory(SessionFactory sessionFactory) {
                    this.sessionFactory = sessionFactory;
                  }
                  // ...
                }

!!!         The last example we show here is for typical JDBC support. You could have the DataSource injected
            into an initialization method or a constructor, where you would create a JdbcTemplate and other
            data access support classes (such as SimpleJdbcCall and others) by using this DataSource. The
            following example autowires a DataSource:

                @Repository
                public class JdbcMovieFinder implements MovieFinder {
                  private JdbcTemplate jdbcTemplate;
                  @Autowired
                  public void init(DataSource dataSource) {
                    this.jdbcTemplate = new JdbcTemplate(dataSource);
                  }
                  // ...
                }

    4.3. Data Access with JDBC
        The value provided by the Spring Framework JDBC abstraction is perhaps best shown by the
        sequence of actions outlined in the following table below. The table shows which actions Spring
        takes care of and which actions are your responsibility.

        Table 20. Spring JDBC - who does what?
        Action                                                      Spring                      You
        Define connection parameters.                                                           X
        Open the connection.                                        X
        Specify the SQL statement.                                                               X
        Declare parameters and provide parameter values                                        X
        Prepare and run the statement.                              X
        Set up the loop to iterate through the results (if any).    X
        Do the work for each iteration.                                                         X
        Process any exception.                                       X
        Handle transactions.                                         X
        Close the connection, the statement, and the resultset.      X
        The Spring Framework takes care of all the low-level details that can make JDBC such a tedious API.

        4.3.1. Choosing an Approach for JDBC Database Access
            You can choose among several approaches to form the basis for your JDBC database access. In
            addition to three flavors of JdbcTemplate, a new SimpleJdbcInsert and SimpleJdbcCall approach
            optimizes database metadata, and the RDBMS Object style takes a more object-oriented approach
            Once you start using one of these approaches, you can still mix
            and match to include a feature from a different approach. All approaches require a JDBC 2.0-
            compliant driver, and some advanced features require a JDBC 3.0 driver

                • JdbcTemplate is the classic and most popular Spring JDBC approach. This “lowest-level” approach
                and all others use a JdbcTemplate under the covers.
                • NamedParameterJdbcTemplate wraps a JdbcTemplate to provide named parameters instead of the
                traditional JDBC ? placeholders. This approach provides better documentation and ease of use
                when you have multiple parameters for an SQL statement.
                • SimpleJdbcInsert and SimpleJdbcCall optimize database metadata to limit the amount of
                necessary configuration. This approach simplifies coding so that you need to provide only the
                name of the table or procedure and provide a map of parameters matching the column names.
                This works only if the database provides adequate metadata. If the database does not provide
                this metadata, you have to provide explicit configuration of the parameters.
                • RDBMS objects — including MappingSqlQuery, SqlUpdate, and StoredProcedure — require you to
                create reusable and thread-safe objects during initialization of your data-access layer. This
                approach is modeled after JDO Query, wherein you define your query string, declare
                parameters, and compile the query. Once you do that, execute(…), update(…), and
                findObject(…) methods can be called multiple times with various parameter values.

        4.3.3. Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling
!!!         Using JdbcTemplate
                JdbcTemplate is the central class in the JDBC core package. It handles the creation and release of
                resources, which helps you avoid common errors, such as forgetting to close the connection. It
                performs the basic tasks of the core JDBC workflow (such as statement creation and execution),
                leaving application code to provide SQL and extract results. The JdbcTemplate class:
                • Runs SQL queries
                • Updates statements and stored procedure calls
                • Performs iteration over ResultSet instances and extraction of returned parameter values.
                • Catches JDBC exceptions and translates them to the generic, more informative, exception
                hierarchy defined in the org.springframework.dao package.

                You can use JdbcTemplate within a DAO implementation through direct instantiation with a
                DataSource reference, or you can configure it in a Spring IoC container and give it to DAOs as a bean
                reference.
                The DataSource should always be configured as a bean in the Spring IoC container.
                In the first case the bean is given to the service directly; in the second case it is
                given to the prepared template.

                The following sections provide some examples of JdbcTemplate usage. These examples are not an
                exhaustive list of all of the functionality exposed by the JdbcTemplate. See the attendant javadoc for
                that.

                int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class);
                int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject("select count(*) from t_actor where first_name = ?", Integer.class, "Joe");
                String lastName = this.jdbcTemplate.queryForObject("select last_name from t_actor where id = ?", String.class, 1212L);
                Actor actor = jdbcTemplate.queryForObject(
                  "select first_name, last_name from t_actor where id = ?",
                  (resultSet, rowNum) -> {
                      Actor newActor = new Actor();
                      newActor.setFirstName(resultSet.getString("first_name"));
                      newActor.setLastName(resultSet.getString("last_name"));
                      return newActor;
                  },
                  1212L);

                List<Actor> actors = this.jdbcTemplate.query(
                  "select first_name, last_name from t_actor",
                  (resultSet, rowNum) -> {
                      Actor actor = new Actor();
                      actor.setFirstName(resultSet.getString("first_name"));
                      actor.setLastName(resultSet.getString("last_name"));
                      return actor;
                  });

                If the last two snippets of code actually existed in the same application, it would make sense to
                remove the duplication present in the two RowMapper lambda expressions and extract them out into
                a single field that could then be referenced by DAO methods as needed. For example, it may be
                better to write the preceding code snippet as follows:
                    private final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> {
                      Actor actor = new Actor();
                      actor.setFirstName(resultSet.getString("first_name"));
                      actor.setLastName(resultSet.getString("last_name"));
                      return actor;
                    };
                    public List<Actor> findAllActors() {
                      return this.jdbcTemplate.query("select first_name, last_name from t_actor", actorRowMapper);
                    }

                You can use the update(..) method to perform insert, update, and delete operations. Parameter
                values are usually provided as variable arguments or, alternatively, as an object array

                this.jdbcTemplate.update("insert into t_actor (first_name, last_name) values (?, ?)", "Leonor", "Watling");
                this.jdbcTemplate.update("update t_actor set last_name = ? where id = ?", "Banjo", 5276L);
                this.jdbcTemplate.update("delete from t_actor where id = ?", Long.valueOf(actorId));

                You can use the execute(..) method to run any arbitrary SQL. Consequently, the method is often
                used for DDL statements. It is heavily overloaded with variants that take callback interfaces,
                binding variable arrays, and so on. The following example creates a table:

                this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
                The following example invokes a stored procedure:
                this.jdbcTemplate.update("call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",Long.valueOf(unionId));

            JdbcTemplate Best Practices
!!!             Instances of the JdbcTemplate class are thread-safe, once configured. This is important because it
                means that you can configure a single instance of a JdbcTemplate and then safely inject this shared
                reference into multiple DAOs (or repositories). The JdbcTemplate is stateful, in that it maintains a
                reference to a DataSource, but this state is not conversational state.

                A common practice when using the JdbcTemplate class (and the associated
                NamedParameterJdbcTemplate class) is to configure a DataSource in your Spring configuration file and
                then dependency-inject that shared DataSource bean into your DAO classes. The JdbcTemplate is
                created in the setter for the DataSource. This leads to DAOs that resemble the following:

                    public class JdbcCorporateEventDao implements CorporateEventDao {
                      private JdbcTemplate jdbcTemplate;
                      public void setDataSource(DataSource dataSource) {
                        this.jdbcTemplate = new JdbcTemplate(dataSource);
                      }
                      // JDBC-backed implementations of the methods on the CorporateEventDao follow...
                    }

                    Dan: the coresponding XML configuration is in the official pdf

                An alternative to explicit configuration is to use component-scanning and annotation support for
                dependency injection. In this case, you can annotate the class with @Repository (which makes it a
                candidate for component-scanning) and annotate the DataSource setter method with @Autowired. The
                following example shows how to do so:

                    @Repository
                    public class JdbcCorporateEventDao implements CorporateEventDao {
                      private JdbcTemplate jdbcTemplate;
                      @Autowired
                      public void setDataSource(DataSource dataSource) {
                        this.jdbcTemplate = new JdbcTemplate(dataSource);
                      }
                      // JDBC-backed implementations of the methods on the CorporateEventDao follow...
                    }

            Using NamedParameterJdbcTemplate
                The NamedParameterJdbcTemplate class adds support for programming JDBC statements by using
                named parameters, as opposed to programming JDBC statements using only classic placeholder (
                '?') arguments. The NamedParameterJdbcTemplate class wraps a JdbcTemplate and delegates to the
                wrapped JdbcTemplate to do much of its work. This section describes only those areas of the
                NamedParameterJdbcTemplate class that differ from the JdbcTemplate itself — namely, programming
                JDBC statements by using named parameters.

            Using SQLExceptionTranslator
                SQLExceptionTranslator is an interface to be implemented by classes that can translate between
                SQLExceptions and Spring’s own org.springframework.dao.DataAccessException, which is agnostic in
                regard to data access strategy. Implementations can be generic (for example, using SQLState codes
                for JDBC) or proprietary (for example, using Oracle error codes) for greater precision.

                To use this custom translator, you must pass
                it to the JdbcTemplate through the method setExceptionTranslator, and you must use this
                JdbcTemplate for all of the data access processing where this translator is needed.

            Running Queries
                Some query methods return a single value. To retrieve a count or a specific value from one row, use
                queryForObject(..). The latter converts the returned JDBC Type to the Java class that is passed in as
                an argument. If the type conversion is invalid, an InvalidDataAccessApiUsageException is thrown.

                In addition to the single result query methods, several methods return a list with an entry for each
                row that the query returned. The most generic method is queryForList(..), which returns a List
                where each element is a Map containing one entry for each column, using the column name as the key.

        4.3.4. Controlling Database Connections
            Using DataSource
!!              Spring obtains a connection to the database through a DataSource. A DataSource is part of the JDBC
                specification and is a generalized connection factory. It lets a container or a framework hide
                connection pooling and transaction management issues from the application code. As a developer,
                you need not know details about how to connect to the database. That is the responsibility of the
                administrator who sets up the datasource. You most likely fill both roles as you develop and test
                code, but you do not necessarily have to know how the production data source is configured.
                When you use Spring’s JDBC layer, you can obtain a data source from JNDI, or you can configure
                your own with a connection pool implementation provided by a third party. Traditional choices are
                Apache Commons DBCP and C3P0 with bean-style DataSource classes; for a modern JDBC connection
                pool, consider HikariCP with its builder-style API instead.

                You should use the DriverManagerDataSource and SimpleDriverDataSource classes (as
                included in the Spring distribution) only for testing purposes! Those variants do
                not provide pooling and perform poorly when multiple requests for a connection
                are made.

            Using DataSourceUtils
                The DataSourceUtils class is a convenient and powerful helper class that provides static methods to
                obtain connections from JNDI and close connections if necessary. I

        4.3.5. JDBC Batch Operations
            Most JDBC drivers provide improved performance if you batch multiple calls to the same prepared
            statement. By grouping updates into batches, you limit the number of round trips to the database.

            Basic Batch Operations with JdbcTemplate
                You accomplish JdbcTemplate batch processing by implementing two methods of a special interface,
                BatchPreparedStatementSetter, and passing that implementation in as the second parameter in your
                batchUpdate method call. You can use the getBatchSize method to provide the size of the current
                batch. You can use the setValues method to set the values for the parameters of the prepared
                statement. This method is called the number of times that you specified in the getBatchSize call. The
                following example updates the t_actor table based on entries in a list, and the entire list is used as
                the batch:
                    public class JdbcActorDao implements ActorDao {
                      private JdbcTemplate jdbcTemplate;
                      public void setDataSource(DataSource dataSource) {
                        this.jdbcTemplate = new JdbcTemplate(dataSource);
                      }
                      public int[] batchUpdate(final List<Actor> actors) {
                          return this.jdbcTemplate.batchUpdate(
                            "update t_actor set first_name = ?, last_name = ? where id = ?",
                                new BatchPreparedStatementSetter() {
                                    public void setValues(PreparedStatement ps, int i) throws SQLException {
                                      Actor actor = actors.get(i);
                                      ps.setString(1, actor.getFirstName());
                                      ps.setString(2, actor.getLastName());
                                      ps.setLong(3, actor.getId().longValue());
                                      }
                                      public int getBatchSize() {
                                      return actors.size();
                                      }
                                });
                      }
                      // ... additional methods
                    }

        4.3.6. Simplifying JDBC Operations with the SimpleJdbc Classes
            The SimpleJdbcInsert and SimpleJdbcCall classes provide a simplified configuration by taking
            advantage of database metadata that can be retrieved through the JDBC driver. This means that you
            have less to configure up front, although you can override or turn off the metadata processing if
            you prefer to provide all the details in your code.

            Inserting Data by Using SimpleJdbcInsert
                We start by looking at the SimpleJdbcInsert class with the minimal amount of configuration options.
                You should instantiate the SimpleJdbcInsert in the data access layer’s initialization method. For this
                example, the initializing method is the setDataSource method. You do not need to subclass the
                SimpleJdbcInsert class. Instead, you can create a new instance and set the table name by using the
                withTableName method. Configuration methods for this class follow the fluid style that returns the
                instance of the SimpleJdbcInsert, which lets you chain all configuration methods.

                    public class JdbcActorDao implements ActorDao {
                      private SimpleJdbcInsert insertActor;

                      public void setDataSource(DataSource dataSource) {
                        this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor");
                      }

                      public void add(Actor actor) {
                          Map<String, Object> parameters = new HashMap<String, Object>(3);
                          parameters.put("id", actor.getId());
                          parameters.put("first_name", actor.getFirstName());
                          parameters.put("last_name", actor.getLastName());
                          insertActor.execute(parameters);
                      }
                      // ... additional methods
                    }

!!!!            The execute method used here takes a plain java.util.Map as its only parameter. The important
                thing to note here is that the keys used for the Map must match the column names of the table, as
                defined in the database. This is because we read the metadata to construct the actual insert
                statement.

            Specifying Columns for a SimpleJdbcInsert
                You can limit the columns for an insert by specifying a list of column names with the usingColumns
                method

            Using SqlParameterSource to Provide Parameter Values
                Using a Map to provide parameter values works fine, but it is not the most convenient class to use.
                Spring provides a couple of implementations of the SqlParameterSource interface that you can use
                instead. The first one is BeanPropertySqlParameterSource, which is a very convenient class if you
                have a JavaBean-compliant class that contains your values. It uses the corresponding getter method
                to extract the parameter values. The following example shows how to use
                BeanPropertySqlParameterSource:
                    public class JdbcActorDao implements ActorDao {
                      private SimpleJdbcInsert insertActor;
                      public void setDataSource(DataSource dataSource) {
                        this.insertActor = new SimpleJdbcInsert(dataSource)
                            .withTableName("t_actor")
                            .usingGeneratedKeyColumns("id");
                      }
                      public void add(Actor actor) {
                        SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
                        Number newId = insertActor.executeAndReturnKey(parameters);
                        actor.setId(newId.longValue());
                      }
                      // ... additional methods
                    }

            Calling a Stored Procedure with SimpleJdbcCall
                The SimpleJdbcCall class uses metadata in the database to look up names of in and out parameters
                so that you do not have to explicitly declare them

            Calling a Stored Function by Using SimpleJdbcCall
                You can call a stored function in almost the same way as you call a stored procedure, except that
                you provide a function name rather than a procedure name. You use the withFunctionName method
                as part of the configuration to indicate that you want to make a call to a function, and the
                corresponding string for a function call is generated

        4.3.7. Modeling JDBC Operations as Java Objects
            The org.springframework.jdbc.object package contains classes that let you access the database in a
            more object-oriented manner. As an example, you can run queries and get the results back as a list
            that contains business objects with the relational column data mapped to the properties of the
            business object. You can also run stored procedures and run update, delete, and insert statements

            Many Spring developers believe that the various RDBMS operation classes
            described below (with the exception of the StoredProcedure class) can often be
            replaced with straight JdbcTemplate calls. Often, it is simpler to write a DAO method
            that calls a method on a JdbcTemplate directly (as opposed to encapsulating a query
            as a full-blown class).
            However, if you are getting measurable value from using the RDBMS operation
            classes, you should continue to use these classes.

            Understanding SqlQuery
                SqlQuery is a reusable, thread-safe class that encapsulates an SQL query. Subclasses must implement
                the newRowMapper(..) method to provide a RowMapper instance that can create one object per row
                obtained from iterating over the ResultSet that is created during the execution of the query. The
                SqlQuery class is rarely used directly, because the MappingSqlQuery subclass provides a much more
                convenient implementation for mapping rows to Java classes

            Using SqlUpdate
                The SqlUpdate class encapsulates an SQL update. As with a query, an update object is reusable, and,
                as with all RdbmsOperation classes, an update can have parameters and is defined in SQL. This class
                provides a number of update(..) methods analogous to the execute(..) methods of query objects.
                The SqlUpdate class is concrete. It can be subclassed — for example, to add a custom update method

            Using StoredProcedure
                The StoredProcedure class is an abstract superclass for object abstractions of RDBMS stored
                procedures.
                The inherited sql property is the name of the stored procedure in the RDBMS.
                To define a parameter for the StoredProcedure class, you can use an SqlParameter or one of its
                subclasses.

        4.3.8. Common Problems with Parameter and Data Value Handling
            You can provide SQL type information in several ways:
                • Many update and query methods of the JdbcTemplate take an additional parameter in the form
                of an int array. This array is used to indicate the SQL type of the corresponding parameter by
                using constant values from the java.sql.Types class. Provide one entry for each parameter.
                • You can use the SqlParameterValue class to wrap the parameter value that needs this additional
                information. To do so, create a new instance for each value and pass in the SQL type and the
                parameter value in the constructor. You can also provide an optional scale parameter for
                numeric values.

            You can store images, other binary data, and large chunks of text in the database. These large
            objects are called BLOBs (Binary Large OBject) for binary data and CLOBs (Character Large OBject)
            for character data. In Spring, you can handle these large objects by using the JdbcTemplate directly
            and also when using the higher abstractions provided by RDBMS Objects and the SimpleJdbc classes.
            All of these approaches use an implementation of the LobHandler interface for the actual
            management of the LOB (Large OBject) data

            The SQL standard allows for selecting rows based on an expression that includes a variable list of
            values. A typical example would be select * from T_ACTOR where id in (1, 2, 3). This variable list
            is not directly supported for prepared statements by the JDBC standard. You cannot declare a
            variable number of placeholders. You need a number of variations with the desired number of
            placeholders prepared, or you need to generate the SQL string dynamically once you know how
            many placeholders are required. The named parameter support provided in the
            NamedParameterJdbcTemplate and JdbcTemplate takes the latter approach. You can pass in the values
            as a java.util.List of primitive objects. This list is used to insert the required placeholders and
            pass in the values during statement execution

        4.3.9. Embedded Database Support
            The org.springframework.jdbc.datasource.embedded package provides support for embedded Java
            database engines. Support for HSQL, H2, and Derby is provided natively. You can also use an
            extensible API to plug in new embedded database types and DataSource implementations.

            Why Use an Embedded Database?
            An embedded database can be useful during the development phase of a project because of its
            lightweight nature. Benefits include ease of configuration, quick startup time, testability, and the
            ability to rapidly evolve your SQL during development.

            Testing Data Access Logic with an Embedded Database
            Embedded databases provide a lightweight way to test data access code. The next example is a data
            access integration test template that uses an embedded database. Using such a template can be
            useful for one-offs when the embedded database does not need to be reused across test classes.
            However, if you wish to create an embedded database that is shared within a test suite, consider
            using the Spring TestContext Framework and configuring the embedded database as a bean in the
            Spring ApplicationContext as described in Creating an Embedded Database by Using Spring XML
            and Creating an Embedded Database Programmatically. The following listing shows the test
            template:

        4.3.10. Initializing a DataSource
            The org.springframework.jdbc.datasource.init package provides support for initializing an existing
            DataSource. The embedded database support provides one option for creating and initializing a
            DataSource for an application. However, you may sometimes need to initialize an instance that runs
            on a server somewhere.

            Initializing a Database by Using Spring XML
                If you want to initialize a database and you can provide a reference to a DataSource bean, you can
                use the initialize-database tag in the spring-jdbc namespace:
                    <jdbc:initialize-database data-source="dataSource">
                      <jdbc:script location="classpath:com/foo/sql/db-schema.sql"/>
                      <jdbc:script location="classpath:com/foo/sql/db-test-data.sql"/>
                    </jdbc:initialize-database>
                The preceding example runs the two specified scripts against the database. The first script creates a
                schema, and the second populates tables with a test data set.

                The default behavior of the database initializer is to unconditionally run the provided scripts. This
                may not always be what you want — for instance, if you run the scripts against a database that
                already has test data in it. The likelihood of accidentally deleting data is reduced by following the
                common pattern (shown earlier) of creating the tables first and then inserting the data. The first
                step fails if the tables already exist.
                However, to gain more control over the creation and deletion of existing data, the XML namespace
                provides a few additional options. The first is a flag to switch the initialization on and off. You can
                set this according to the environment (such as pulling a boolean value from system properties or
                from an environment bean).

                The second option to control what happens with existing data is to be more tolerant of failures. To
                this end, you can control the ability of the initializer to ignore certain errors in the SQL it runs from
                the scripts


    4.4. Data Access with R2DBC
        R2DBC ("Reactive Relational Database Connectivity") is a community-driven specification effort to
        standardize access to SQL databases using reactive patterns.

        Using DatabaseClient
            DatabaseClient is the central class in the R2DBC core package. It handles the creation and release of
            resources, which helps to avoid common errors, such as forgetting to close the connection. It
            performs the basic tasks of the core R2DBC workflow (such as statement creation and execution),
            leaving application code to provide SQL and extract results. The DatabaseClient class:
            • Runs SQL queries
            • Update statements and stored procedure calls
            • Performs iteration over Result instances
            • Catches R2DBC exceptions and translates them to the generic, more informative, exception
            hierarchy defined in the org.springframework.dao package

            Currently supported databases are:
            • H2
            • MariaDB
            • Microsoft SQL Server
            • MySQL
            • Postgres

            DatabaseClient provides the basic functionality of running a statement. The following example
            shows what you need to include for minimal but fully functional code that creates a new table:

                Mono<Void> completion = client.sql("CREATE TABLE person (id VARCHAR(255) PRIMARY KEY,
                name VARCHAR(255), age INTEGER);").then();

            DatabaseClient is designed for convenient, fluent usage. It exposes intermediate, continuation, and
            terminal methods at each stage of the execution specification. The preceding example above uses
            then() to return a completion Publisher that completes as soon as the query (or queries, if the SQL
            query contains multiple statements) completes.

                Mono<Map<String, Object>> first = client.sql("SELECT id, name FROM person WHERE first_name = :fn")
                  .bind("fn", "Joe")
                  .fetch().first();

            You might have noticed the use of fetch() in the example above. fetch() is a continuation operator
            that lets you specify how much data you want to consume.
            Calling first() returns the first row from the result and discards remaining rows. You can consume
            data with the following operators:
            • first() return the first row of the entire result. Its Kotlin Coroutine variant is named
            awaitSingle() for non-nullable return values and awaitSingleOrNull() if the value is optional.
            • one() returns exactly one result and fails if the result contains more rows. Using Kotlin
            Coroutines, awaitOne() for exactly one value or awaitOneOrNull() if the value may be null.
            • all() returns all rows of the result. When using Kotlin Coroutines, use flow().
            • rowsUpdated() returns the number of affected rows (INSERT/UPDATE/DELETE count). Its Kotlin
            Coroutine variant is named awaitRowsUpdated().

            What about null?
            Relational database results can contain null values. The Reactive Streams specification
            forbids the emission of null values. That requirement mandates proper null handling in the
            extractor function. While you can obtain null values from a Row, you must not emit a null
            value. You must wrap any null values in an object (for example, Optional for singular values)
            to make sure a null value is never returned directly by your extractor function

            DatabaseClient leverages R2DBC’s bind API to
            eliminate the risk of SQL injection for query parameters. You can provide a parameterized SQL
            statement with the execute(…) operator and bind parameters to the actual Statement. Your R2DBC
            driver then runs the statement by using prepared statements and parameter substitution.
            Parameter binding supports two binding strategies:
            • By Index, using zero-based parameter indexes.
            • By Name, using the placeholder name.

                db.sql("INSERT INTO person (id, name, age) VALUES(:id, :name, :age)")
                  .bind("id", "joe")
                  .bind("name", "Joe")
                  .bind("age", 34);

        DatabaseClient Best Practices
            Instances of the DatabaseClient class are thread-safe, once configured. This is important because it
            means that you can configure a single instance of a DatabaseClient and then safely inject this
            shared reference into multiple DAOs (or repositories). The DatabaseClient is stateful, in that it
            maintains a reference to a ConnectionFactory, but this state is not conversational state.

            A common practice when using the DatabaseClient class is to configure a ConnectionFactory in your
            Spring configuration file and then dependency-inject that shared ConnectionFactory bean into your
            DAO classes. The DatabaseClient is created in the setter for the ConnectionFactory. This leads to DAOs
            that resemble the following:
                public class R2dbcCorporateEventDao implements CorporateEventDao {
                  private DatabaseClient databaseClient;
                  public void setConnectionFactory(ConnectionFactory connectionFactory) {
                    this.databaseClient = DatabaseClient.create(connectionFactory);
                  }
                  // R2DBC-backed implementations of the methods on the CorporateEventDao follow...
                }

            An alternative to explicit configuration is to use component-scanning and annotation support for
            dependency injection. In this case, you can annotate the class with @Component (which makes it a
            candidate for component-scanning) and annotate the ConnectionFactory setter method with
            @Autowired. The following example shows how to do so:

                @Component
                public class R2dbcCorporateEventDao implements CorporateEventDao {
                  private DatabaseClient databaseClient;
                  @Autowired
                  public void setConnectionFactory(ConnectionFactory connectionFactory) {
                    this.databaseClient = DatabaseClient.create(connectionFactory);
                  }
                  // R2DBC-backed implementations of the methods on the CorporateEventDao follow...
                }

    4.5. Object Relational Mapping (ORM) Data Access
        This section covers data access when you use Object Relational Mapping (ORM)

        4.5.1. Introduction to ORM with Spring
            The Spring Framework supports integration with the Java Persistence API (JPA) and supports native
            Hibernate for resource management, data access object (DAO) implementations, and transaction
            strategies. For example, for Hibernate, there is first-class support with several convenient IoC
            features that address many typical Hibernate integration issues. You can configure all of the
            supported features for OR (object relational) mapping tools through Dependency Injection. They
            can participate in Spring’s resource and transaction management, and they comply with Spring’s
            generic transaction and DAO exception hierarchies. The recommended integration style is to code
            DAOs against plain Hibernate or JPA APIs.

!!!         Spring adds significant enhancements to the ORM layer of your choice when you create data access
            applications. You can leverage as much of the integration support as you wish, and you should
            compare this integration effort with the cost and risk of building a similar infrastructure in-house.

!!!         The benefits of using the Spring Framework to create your ORM DAOs include:
                • Easier testing. Spring’s IoC approach makes it easy to swap the implementations and
                configuration locations of Hibernate SessionFactory instances, JDBC DataSource instances,
                transaction managers, and mapped object implementations (if needed). This in turn makes it
                much easier to test each piece of persistence-related code in isolation.
                • Common data access exceptions. Spring can wrap exceptions from your ORM tool, converting
                them from proprietary (potentially checked) exceptions to a common runtime
                DataAccessException hierarchy. This feature lets you handle most persistence exceptions, which
                are non-recoverable, only in the appropriate layers, without annoying boilerplate catches,
                throws, and exception declarations. You can still trap and handle exceptions as necessary.
                Remember that JDBC exceptions (including DB-specific dialects) are also converted to the same
                hierarchy, meaning that you can perform some operations with JDBC within a consistent
                programming model.
                • General resource management. Spring application contexts can handle the location and
                configuration of Hibernate SessionFactory instances, JPA EntityManagerFactory instances, JDBC
                DataSource instances, and other related resources. This makes these values easy to manage and
                change. Spring offers efficient, easy, and safe handling of persistence resources. For example,
                related code that uses Hibernate generally needs to use the same Hibernate Session to ensure
                efficiency and proper transaction handling. Spring makes it easy to create and bind a Session to
                the current thread transparently, by exposing a current Session through the Hibernate
                SessionFactory. Thus, Spring solves many chronic problems of typical Hibernate usage, for any
                local or JTA transaction environment.
                • Integrated transaction management. You can wrap your ORM code with a declarative, aspect oriented
                programming (AOP) style method interceptor either through the @Transactional
                annotation or by explicitly configuring the transaction AOP advice in an XML configuration file.
                In both cases, transaction semantics and exception handling (rollback and so on) are handled
                for you. As discussed in Resource and Transaction Management, you can also swap various
                transaction managers, without affecting your ORM-related code. For example, you can swap
                between local transactions and JTA, with the same full services (such as declarative
                transactions) available in both scenarios. Additionally, JDBC-related code can fully integrate
                transactionally with the code you use to do ORM. This is useful for data access that is not
                suitable for ORM (such as batch processing and BLOB streaming) but that still needs to share
                common transactions with ORM operations.

            For more comprehensive ORM support, including support for alternative database
            technologies such as MongoDB, you might want to check out the Spring Data suite
            of projects. If you are a JPA user, the Getting Started Accessing Data with JPA guide
            from https://spring.io provides a great introduction.

        4.5.2. General ORM Integration Considerations
            This section highlights considerations that apply to all ORM technologies. The Hibernate section
            provides more details and also show these features and configurations in a concrete context.
!!!         The major goal of Spring’s ORM integration is clear application layering (with any data access and
            transaction technology) and for loose coupling of application objects — no more business service
            dependencies on the data access or transaction strategy, no more hard-coded resource lookups, no
            more hard-to-replace singletons, no more custom service registries. The goal is to have one simple
            and consistent approach to wiring up application objects, keeping them as reusable and free from
            container dependencies as possible. All the individual data access features are usable on their own
            but integrate nicely with Spring’s application context concept, providing XML-based configuration
            and cross-referencing of plain JavaBean instances that need not be Spring-aware.

            Resource and Transaction Management
                Typical business applications are cluttered with repetitive resource management code. Many
                projects try to invent their own solutions, sometimes sacrificing proper handling of failures for
                programming convenience. Spring advocates simple solutions for proper resource handling,
                namely IoC through templating in the case of JDBC and applying AOP interceptors for the ORM
                technologies.

            Exception Translation
                When you use Hibernate or JPA in a DAO, you must decide how to handle the persistence
                technology’s native exception classes. The DAO throws a subclass of a HibernateException or
                PersistenceException, depending on the technology. These exceptions are all runtime exceptions
                and do not have to be declared or caught. You may also have to deal with IllegalArgumentException
                and IllegalStateException. This means that callers can only treat exceptions as being generally
                fatal, unless they want to depend on the persistence technology’s own exception structure. Catching
                specific causes (such as an optimistic locking failure) is not possible without tying the caller to the
                implementation strategy. This trade-off might be acceptable to applications that are strongly ORM based
                or do not need any special exception treatment (or both). However, Spring lets exception
                translation be applied transparently through the @Repository annotation. The following examples
                (one for Java configuration and one for XML configuration) show how to do so:

                    @Repository
                    public class ProductDaoImpl implements ProductDao {
                      // class body here...
                    }

!!!!            The postprocessor automatically looks for all exception translators (implementations of the
                PersistenceExceptionTranslator interface) and advises all beans marked with the @Repository
                annotation so that the discovered translators can intercept and apply the appropriate translation
                on the thrown exceptions.
!!!!            In summary, you can implement DAOs based on the plain persistence technology’s API and
                annotations while still benefiting from Spring-managed transactions, dependency injection, and
                transparent exception conversion (if desired) to Spring’s custom exception hierarchies.

        4.5.3. Hibernate
            We start with a coverage of Hibernate 5 in a Spring environment, using it to demonstrate the
            approach that Spring takes towards integrating OR mappers. This section covers many issues in
            detail and shows different variations of DAO implementations and transaction demarcation. Most
            of these patterns can be directly translated to all other supported ORM tools. The later sections in
            this chapter then cover the other ORM technologies and show brief examples.

            As of Spring Framework 5.3, Spring requires Hibernate ORM 5.2+ for Spring’s
            HibernateJpaVendorAdapter as well as for a native Hibernate SessionFactory setup. It
            is strongly recommended to go with Hibernate ORM 5.4 for a newly started
            application. For use with HibernateJpaVendorAdapter, Hibernate Search needs to be
            upgraded to 5.11.6.

            SessionFactory Setup in a Spring Container
                To avoid tying application objects to hard-coded resource lookups, you can define resources (such
                as a JDBC DataSource or a Hibernate SessionFactory) as beans in the Spring container. Application
                objects that need to access resources receive references to such predefined instances through bean
                references, as illustrated in the DAO definition in the next section.

                Implementing DAOs Based on the Plain Hibernate API
                Hibernate has a feature called contextual sessions, wherein Hibernate itself manages one current
                Session per transaction. This is roughly equivalent to Spring’s synchronization of one Hibernate
                Session per transaction. A corresponding DAO implementation resembles the following example,
                based on the plain Hibernate API:

                    public class ProductDaoImpl implements ProductDao {
                      private SessionFactory sessionFactory;
                      public void setSessionFactory(SessionFactory sessionFactory) {
                        this.sessionFactory = sessionFactory;
                      }
                      public Collection loadProductsByCategory(String category) {
                        return this.sessionFactory.getCurrentSession()
                            .createQuery("from test.Product product where product.category=?")
                            .setParameter(0, category)
                            .list();
                      }
                    }

                The preceding DAO example follows the dependency injection pattern. It fits nicely into a Spring
                IoC container, as it would if coded against Spring’s HibernateTemplate. You can also set up such a
                DAO in plain Java (for example, in unit tests). To do so, instantiate it and call setSessionFactory(..)
                with the desired factory reference.

                The main advantage of this DAO style is that it depends on Hibernate API only. No import of any
                Spring class is required. This is appealing from a non-invasiveness perspective and may feel more
                natural to Hibernate developers.
                However, the DAO throws plain HibernateException (which is unchecked, so it does not have to be
                declared or caught), which means that callers can treat exceptions only as being generally
                fatal — unless they want to depend on Hibernate’s own exception hierarchy. Catching specific
                causes (such as an optimistic locking failure) is not possible without tying the caller to the
                implementation strategy. This trade off might be acceptable to applications that are strongly
                Hibernate-based, do not need any special exception treatment, or both.

                In summary, you can implement DAOs based on the plain Hibernate API, while still being able to
                participate in Spring-managed transactions.

            Declarative Transaction Demarcation
                We recommend that you use Spring’s declarative transaction support, which lets you replace
                explicit transaction demarcation API calls in your Java code with an AOP transaction interceptor.
                You can configure this transaction interceptor in a Spring container by using either Java
                annotations or XML. This declarative transaction capability lets you keep business services free of
                repetitive transaction demarcation code and focus on adding business logic, which is the real value
                of your application.

                You can annotate the service layer with @Transactional annotations and instruct the Spring
                container to find these annotations and provide transactional semantics for these annotated
                methods. The following example shows how to do so:

                    public class ProductServiceImpl implements ProductService {
                      private ProductDao productDao;
                      public void setProductDao(ProductDao productDao) {
                        this.productDao = productDao;
                      }
                      @Transactional
                      public void increasePriceOfAllProductsInCategory(final String category) {
                        List productsToChange = this.productDao.loadProductsByCategory(category);
                        // ...
                      }
                      @Transactional(readOnly = true)
                      public List<Product> findAllProducts() {
                        return this.productDao.findAllProducts();
                      }
                    }
                In the container, you need to set up the PlatformTransactionManager implementation (as a bean) and
                a <tx:annotation-driven/> entry, opting into @Transactional processing at runtime.
                    Dan: i did not copy the xml ...you can fiind it in the notes

            Programmatic Transaction Demarcation
                You can demarcate transactions in a higher level of the application, on top of lower-level data
                access services that span any number of operations. Nor do restrictions exist on the
                implementation of the surrounding business service. It needs only a Spring
                PlatformTransactionManager. Again, the latter can come from anywhere, but preferably as a bean
                reference through a setTransactionManager(..) method. Also, the productDAO should be set by a
                setProductDao(..) method. The following pair of snippets show a transaction manager and a
                business service definition in a Spring application context and an example for a business method
                implementation

            Transaction Management Strategies
                Both TransactionTemplate and TransactionInterceptor delegate the actual transaction handling to a
                PlatformTransactionManager instance (which can be a HibernateTransactionManager (for a single
                Hibernate SessionFactory) by using a ThreadLocal Session under the hood) or a
                JtaTransactionManager (delegating to the JTA subsystem of the container) for Hibernate applications.
                You can even use a custom PlatformTransactionManager implementation. Switching from native
                Hibernate transaction management to JTA (such as when facing distributed transaction
                requirements for certain deployments of your application) is only a matter of configuration. You
                can replace the Hibernate transaction manager with Spring’s JTA transaction implementation. Both
                transaction demarcation and data access code work without changes, because they use the generic
                transaction management APIs.

        4.5.4. JPA
            The Spring JPA, available under the org.springframework.orm.jpa package, offers comprehensive
            support for the Java Persistence API in a manner similar to the integration with Hibernate while
            being aware of the underlying implementation in order to provide additional features.

            Three Options for JPA Setup in a Spring Environment
            The Spring JPA support offers three ways of setting up the JPA EntityManagerFactory that is used by
            the application to obtain an entity manager.
            • Using LocalEntityManagerFactoryBean
            • Obtaining an EntityManagerFactory from JNDI
            • Using LocalContainerEntityManagerFactoryBean

            Using LocalEntityManagerFactoryBean
                You can use this option only in simple deployment environments such as stand-alone applications
                and integration tests.
                The LocalEntityManagerFactoryBean creates an EntityManagerFactory suitable for simple deployment
                environments where the application uses only JPA for data access. The factory bean uses the JPA
                PersistenceProvider auto-detection mechanism (according to JPA’s Java SE bootstrapping) and, in
                most cases, requires you to specify only the persistence unit name. The following XML example
                configures such a bean:
                <beans>
                  <bean id="myEmf"
                class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean">
                  <property name="persistenceUnitName" value="myPersistenceUnit"/>
                  </bean>
                </beans>
                This form of JPA deployment is the simplest and the most limited. You cannot refer to an existing
                JDBC DataSource bean definition, and no support for global transactions exists. Furthermore,
                weaving (byte-code transformation) of persistent classes is provider-specific, often requiring a
                specific JVM agent to be specified on startup. This option is sufficient only for stand-alone
                applications and test environments, for which the JPA specification is designed.

            Obtaining an EntityManagerFactory from JNDI
                You can use this option when deploying to a Jakarta EE server. Check your server’s documentation
                on how to deploy a custom JPA provider into your server, allowing for a different provider than the
                server’s default.
                Obtaining an EntityManagerFactory from JNDI (for example in a Jakarta EE environment), is a
                matter of changing the XML configuration, as the following example shows:
                <beans>
                  <jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/>
                </beans>
                This action assumes standard Jakarta EE bootstrapping. The Jakarta EE server auto-detects
                persistence units (in effect, META-INF/persistence.xml files in application jars) and persistence-unit
                ref entries in the Jakarta EE deployment descriptor (for example, web.xml) and defines environment
                naming context locations for those persistence units.

                In such a scenario, the entire persistence unit deployment, including the weaving (byte-code
                transformation) of persistent classes, is up to the Jakarta EE server. The JDBC DataSource is defined
                through a JNDI location in the META-INF/persistence.xml file. EntityManager transactions are
                integrated with the server’s JTA subsystem. Spring merely uses the obtained EntityManagerFactory,
                passing it on to application objects through dependency injection and managing transactions for
                the persistence unit (typically through JtaTransactionManager).

            Using LocalContainerEntityManagerFactoryBean
                You can use this option for full JPA capabilities in a Spring-based application environment. This
                includes web containers such as Tomcat, stand-alone applications, and integration tests with
                sophisticated persistence requirements.

                Dealing with Multiple Persistence Units
                For applications that rely on multiple persistence units locations (stored in various JARS in the
                classpath, for example), Spring offers the PersistenceUnitManager to act as a central repository and
                to avoid the persistence units discovery process, which can be expensive. The default
                implementation lets multiple locations be specified. These locations are parsed and later retrieved
                through the persistence unit name.

            Implementing DAOs Based on JPA: EntityManagerFactory and EntityManager
                Although EntityManagerFactory instances are thread-safe, EntityManager instances
                are not. The injected JPA EntityManager behaves like an EntityManager fetched from
                an application server’s JNDI environment, as defined by the JPA specification. It
                delegates all calls to the current transactional EntityManager, if any. Otherwise, it
                falls back to a newly created EntityManager per operation, in effect making its
                usage thread-safe.
                It is possible to write code against the plain JPA without any Spring dependencies, by using an
                injected EntityManagerFactory or EntityManager. Spring can understand the @PersistenceUnit and
                @PersistenceContext annotations both at the field and the method level if a
                PersistenceAnnotationBeanPostProcessor is enabled.
                    public class ProductDaoImpl implements ProductDao {
                      private EntityManagerFactory emf;
                      @PersistenceUnit
                      public void setEntityManagerFactory(EntityManagerFactory emf) {
                        this.emf = emf;
                      }
                      public Collection loadProductsByCategory(String category) {
                        EntityManager em = this.emf.createEntityManager();
                        try {
                            Query query = em.createQuery("from Product as p where p.category = ?1");
                            query.setParameter(1, category);
                            return query.getResultList();
                        }
                        finally {
                            if (em != null) {
                                em.close();
                            }
                        }
                      }
                    }
                The preceding DAO has no dependency on Spring and still fits nicely into a Spring application
                context

                a transactional EntityManager (also called a “shared EntityManager” because it is a shared, thread-safe
                proxy for the actual transactional EntityManager) to be injected instead of the factory.

                The @PersistenceContext annotation has an optional attribute called type, which defaults to
                PersistenceContextType.TRANSACTION. You can use this default to receive a shared EntityManager
                proxy. The alternative, PersistenceContextType.EXTENDED, is a completely different affair. This results
                in a so-called extended EntityManager, which is not thread-safe and, hence, must not be used in a
                concurrently accessed component, such as a Spring-managed singleton bean. Extended
                EntityManager instances are only supposed to be used in stateful components that, for example,
                reside in a session, with the lifecycle of the EntityManager not tied to a current transaction but
                rather being completely up to the application.

            Spring-driven JPA transactions
                We strongly encourage you to read Declarative Transaction Management, if you
                have not already done so, to get more detailed coverage of Spring’s declarative
                transaction support.
                The recommended strategy for JPA is local transactions through JPA’s native transaction support.
                Spring’s JpaTransactionManager provides many capabilities known from local JDBC transactions
                (such as transaction-specific isolation levels and resource-level read-only optimizations) against
                any regular JDBC connection pool (no XA requirement).


    4.6. Marshalling XML by Using Object-XML Mappers
        This chapter, describes Spring’s Object-XML Mapping support. Object-XML Mapping (O-X mapping
        for short) is the act of converting an XML document to and from an object. This conversion process
        is also known as XML Marshalling, or XML Serialization. This chapter uses these terms
        interchangeably.
        Within the field of O-X mapping, a marshaller is responsible for serializing an object (graph) to
        XML. In similar fashion, an unmarshaller deserializes the XML to an object graph. This XML can
        take the form of a DOM document, an input or output stream, or a SAX handler.

        Some of the benefits of using Spring for your O/X mapping needs are:
        • Ease of configuration
        • Consistent Interfaces
        • Consistent Exception Hierarchy

        Ease of configuration
            Spring’s bean factory makes it easy to configure marshallers, without needing to construct JAXB
            context, JiBX binding factories, and so on. You can configure the marshallers as you would any
            other bean in your application context. Additionally, XML namespace-based configuration is
            available for a number of marshallers, making the configuration even simpler.

        Consistent Interfaces
            Spring’s O-X mapping operates through two global interfaces: Marshaller and Unmarshaller. These
            abstractions let you switch O-X mapping frameworks with relative ease, with little or no change
            required on the classes that do the marshalling. This approach has the additional benefit of making
            it possible to do XML marshalling with a mix-and-match approach (for example, some marshalling
            performed using JAXB and some by XStream) in a non-intrusive fashion, letting you use the
            strength of each technology.

        Consistent Exception Hierarchy
            Spring provides a conversion from exceptions from the underlying O-X mapping tool to its own
            exception hierarchy with the XmlMappingException as the root exception. These runtime exceptions
            wrap the original exception so that no information is lost.

        4.6.2. Marshaller and Unmarshaller
            As stated in the introduction, a marshaller serializes an object to XML, and an unmarshaller
            deserializes XML stream to an object. This section describes the two Spring interfaces used for this
            purpose.

            Understanding Marshaller
                Spring abstracts all marshalling operations behind the org.springframework.oxm.Marshaller
                interface
                The Marshaller interface has one main method, which marshals the given object to a given
                javax.xml.transform.Result. The result is a tagging interface that basically represents an XML
                output abstraction

            Understanding Unmarshaller
                Similar to the Marshaller, we have the org.springframework.oxm.Unmarshaller interface,

            Understanding XmlMappingException
                Spring converts exceptions from the underlying O-X mapping tool to its own exception hierarchy
                with the XmlMappingException as the root exception. These runtime exceptions wrap the original
                exception so that no information will be lost.

        4.6.5. JAXB
            The JAXB binding compiler translates a W3C XML Schema into one or more Java classes, a
            jaxb.properties file, and possibly some resource files. JAXB also offers a way to generate a schema
            from annotated Java classes.

            Using Jaxb2Marshaller
                The Jaxb2Marshaller class implements both of Spring’s Marshaller and Unmarshaller interfaces. It
                requires a context path to operate.

        4.6.7. XStream
            XStream is a simple library to serialize objects to XML and back again. It does not require any
            mapping and generates clean XML.
            For more information on XStream, see the XStream web site. The Spring integration classes reside
            in the org.springframework.oxm.xstream package.
            Using XStreamMarshaller
            The XStreamMarshaller does not require any configuration and can be configured in an application
            context directly

!!!         By default, XStream lets arbitrary classes be unmarshalled, which can lead to
            unsafe Java serialization effects. As such, we do not recommend using the
            XStreamMarshaller to unmarshal XML from external sources (that is, the Web), as
            this can result in security vulnerabilities



========================================================================================================================
Chapter 5. Web on Servlet Stack
    This part of the documentation covers support for Servlet-stack web applications built on the
    Servlet API and deployed to Servlet containers. Individual chapters include Spring MVC, View
    Technologies, CORS Support, and WebSocket Support. For reactive-stack web applications, see Web
    on Reactive Stack.

    5.1. Spring Web MVC
!!      Spring Web MVC is the original web framework built on the Servlet API and has been included in
        the Spring Framework from the very beginning. The formal name, “Spring Web MVC,” comes from
        the name of its source module (spring-webmvc), but it is more commonly known as “Spring MVC”.
        Parallel to Spring Web MVC, Spring Framework 5.0 introduced a reactive-stack web framework
        whose name, “Spring WebFlux,” is also based on its source module (spring-webflux). This section
        covers Spring Web MVC. The next section covers Spring WebFlux.
        For baseline information and compatibility with Servlet container and Jakarta EE version ranges,
        see the Spring Framework Wiki.

        5.1.1. DispatcherServlet

!!!         Spring MVC, as many other web frameworks, is designed around the front controller pattern where
            a central Servlet, the DispatcherServlet, provides a shared algorithm for request processing, while
            actual work is performed by configurable delegate components. This model is flexible and supports
            diverse workflows.
!!!         The DispatcherServlet, as any Servlet, needs to be declared and mapped according to the Servlet
            specification by using Java configuration or in web.xml. In turn, the DispatcherServlet uses Spring
            configuration to discover the delegate components it needs for request mapping, view resolution,
            exception handling, and more.
            The following example of the Java configuration registers and initializes the DispatcherServlet,
            which is auto-detected by the Servlet container

                public class MyWebApplicationInitializer implements WebApplicationInitializer {
                  @Override
                  public void onStartup(ServletContext servletContext) {
                    // Load Spring web application configuration
                    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
                    context.register(AppConfig.class);

                    // Create and register the DispatcherServlet
                    DispatcherServlet servlet = new DispatcherServlet(context);
                    ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);
                    registration.setLoadOnStartup(1);
                    registration.addMapping("/app/*");
                  }
                }

            The following example of web.xml configuration registers and initializes the DispatcherServlet:

                <web-app>
                  <listener>
                    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
                  </listener>
                  <context-param>
                    <param-name>contextConfigLocation</param-name>
                    <param-value>/WEB-INF/app-context.xml</param-value>
                  </context-param>
                  <servlet>
                    <servlet-name>app</servlet-name>
                    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
                    <init-param>
                        <param-name>contextConfigLocation</param-name>
                        <param-value></param-value>
                    </init-param>
                    <load-on-startup>1</load-on-startup>
                  </servlet>
                  <servlet-mapping>
                    <servlet-name>app</servlet-name>
                    <url-pattern>/app/*</url-pattern>
                  </servlet-mapping>
                </web-app>

            Spring Boot follows a different initialization sequence. Rather than hooking into
            the lifecycle of the Servlet container, Spring Boot uses Spring configuration to
            bootstrap itself and the embedded Servlet container. Filter and Servlet
            declarations are detected in Spring configuration and registered with the Servlet
            container. For more details, see the Spring Boot documentation.

            Context Hierarchy
!!!             DispatcherServlet expects a WebApplicationContext (an extension of a plain ApplicationContext) for
                its own configuration. WebApplicationContext has a link to the ServletContext and the Servlet with
                which it is associated. It is also bound to the ServletContext such that applications can use static
                methods on RequestContextUtils to look up the WebApplicationContext if they need access to it.

                For many applications, having a single WebApplicationContext is simple and suffices. It is also
                possible to have a context hierarchy where one root WebApplicationContext is shared across
                multiple DispatcherServlet (or other Servlet) instances, each with its own child
                WebApplicationContext configuration.

                The root WebApplicationContext typically contains infrastructure beans, such as data repositories
                and business services that need to be shared across multiple Servlet instances. Those beans are
                effectively inherited and can be overridden (that is, re-declared) in the Servlet-specific child
                WebApplicationContext, which typically contains beans local to the given Servlet. The following
                image shows this relationship:
                    Dan : check out picture "Spring MVC WebApplicationContext"

                The following example configures a WebApplicationContext hierarchy:
                    public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
                      @Override
                      protected Class<?>[] getRootConfigClasses() {
                        return new Class<?>[] { RootConfig.class };
                      }

                      @Override
                      protected Class<?>[] getServletConfigClasses() {
                        return new Class<?>[] { App1Config.class };
                      }

                      @Override
                      protected String[] getServletMappings() {
                        return new String[] { "/app1/*" };
                      }
                    }

                If an application context hierarchy is not required, applications can return all
                configuration through getRootConfigClasses() and null from
                getServletConfigClasses().

                The following example shows the web.xml equivalent:

                <web-app>
                  <listener>
                    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
                  </listener>
                  <context-param>
                    <param-name>contextConfigLocation</param-name>
                     <param-value>/WEB-INF/root-context.xml</param-value>
                  </context-param>
                  <servlet>
                    <servlet-name>app1</servlet-name>
                    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servletclass>
                    <init-param>
                        <param-name>contextConfigLocation</param-name>
                        <param-value>/WEB-INF/app1-context.xml</param-value>
                    </init-param>
                    <load-on-startup>1</load-on-startup>
                  </servlet>
                  <servlet-mapping>
                    <servlet-name>app1</servlet-name>
                    <url-pattern>/app1/*</url-pattern>
                  </servlet-mapping>
                </web-app>

            Special Bean Types
                The DispatcherServlet delegates to special beans to process requests and render the appropriate
                responses. By “special beans” we mean Spring-managed Object instances that implement
                framework contracts. Those usually come with built-in contracts, but you can customize their
                properties and extend or replace them.
                The following table lists the special beans detected by the DispatcherServlet:

                Bean type                   Explanation
                HandlerMapping              Map a request to a handler along with a list of interceptors for
                                            pre- and post-processing. The mapping is based on some criteria,
                                            the details of which vary by HandlerMapping implementation.
                                            The two main HandlerMapping implementations are
                                            RequestMappingHandlerMapping (which supports @RequestMapping
                                            annotated methods) and SimpleUrlHandlerMapping (which
                                            maintains explicit registrations of URI path patterns to handlers)

                HandlerAdapter              Help the DispatcherServlet to invoke a handler mapped to a
                                            request, regardless of how the handler is actually invoked. For
                                            example, invoking an annotated controller requires resolving
                                            annotations. The main purpose of a HandlerAdapter is to shield
                                            the DispatcherServlet from such details.

                HandlerExceptionResolver    Strategy to resolve exceptions, possibly mapping them to
                                            handlers, to HTML error views, or other targets. See Exceptions.

                ViewResolver                Resolve logical String-based view names returned from a
                                            handler to an actual View with which to render to the response.
                                            See View Resolution and View Technologies.

                LocaleResolver,             Resolve the Locale a client is using and possibly their time zone,
                LocaleContextResolver       in order to be able to offer internationalized views. See Locale.

                ThemeResolver               Resolve themes your web application can use — for example, to
                                            offer personalized layouts. See Themes.

                MultipartResolver           Abstraction for parsing a multi-part request (for example,
                                            browser form file upload) with the help of some multipart
                                            parsing library. See Multipart Resolver.

                FlashMapManager             Store and retrieve the “input” and the “output” FlashMap that can
                                            be used to pass attributes from one request to another, usually
                                            across a redirect. See Flash Attributes.

            Web MVC Config
                Applications can declare the infrastructure beans listed in Special Bean Types that are required to
                process requests. The DispatcherServlet checks the WebApplicationContext for each special bean. If
                there are no matching bean types, it falls back on the default types listed in
                DispatcherServlet.properties.
                In most cases, the MVC Config is the best starting point. It declares the required beans in either Java
                or XML and provides a higher-level configuration callback API to customize it.


            Servlet Config
                In a Servlet environment, you have the option of configuring the Servlet container
                programmatically as an alternative or in combination with a web.xml file. The following example
                registers a DispatcherServlet:

                    import org.springframework.web.WebApplicationInitializer;
                    public class MyWebApplicationInitializer implements WebApplicationInitializer {
                        @Override
                        public void onStartup(ServletContext container) {
                            XmlWebApplicationContext appContext = new XmlWebApplicationContext();
                            appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
                            ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
                            registration.setLoadOnStartup(1);
                            registration.addMapping("/");
                      }
                    }

                WebApplicationInitializer is an interface provided by Spring MVC that ensures your
                implementation is detected and automatically used to initialize any Servlet 3 container. An abstract
                base class implementation of WebApplicationInitializer named
                AbstractDispatcherServletInitializer makes it even easier to register the DispatcherServlet by
                overriding methods to specify the servlet mapping and the location of the DispatcherServlet
                configuration.
                This is recommended for applications that use Java-based Spring configuration, as the following
                example shows:

                    public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
                      @Override
                      protected Class<?>[] getRootConfigClasses() {
                        return null;
                      }
                      @Override
                      protected Class<?>[] getServletConfigClasses() {
                        return new Class<?>[] { MyWebConfig.class };
                      }
                      @Override
                      protected String[] getServletMappings() {
                        return new String[] { "/" };
                      }
                    }

                AbstractDispatcherServletInitializer also provides a convenient way to add Filter instances and
                have them be automatically mapped to the DispatcherServlet, as the following example shows:

                    public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {
                      // ...
                      @Override
                      protected Filter[] getServletFilters() {
                        return new Filter[] { bew HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
                      }
                    }

            Processing
!!!!            The DispatcherServlet processes requests as follows:
                    • The WebApplicationContext is searched for and bound in the request as an attribute that the
                    controller and other elements in the process can use. It is bound by default under the
                    DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE key.
                    • The locale resolver is bound to the request to let elements in the process resolve the locale to
                    use when processing the request (rendering the view, preparing data, and so on). If you do not
                    need locale resolving, you do not need the locale resolver.
                    • The theme resolver is bound to the request to let elements such as views determine which
                    theme to use. If you do not use themes, you can ignore it.
                    • If you specify a multipart file resolver, the request is inspected for multiparts. If multiparts are
                    found, the request is wrapped in a MultipartHttpServletRequest for further processing by other
                    elements in the process. See Multipart Resolver for further information about multipart
                    handling.
                    • An appropriate handler is searched for. If a handler is found, the execution chain associated
                    with the handler (preprocessors, postprocessors, and controllers) is run to prepare a model for
                    rendering. Alternatively, for annotated controllers, the response can be rendered (within the
                    HandlerAdapter) instead of returning a view.
                    • If a model is returned, the view is rendered. If no model is returned (maybe due to a
                    preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view
                    is rendered, because the request could already have been fulfilled.

                The HandlerExceptionResolver beans declared in the WebApplicationContext are used to resolve
                exceptions thrown during request processing. Those exception resolvers allow customizing the
                logic to address exceptions.

                You can customize individual DispatcherServlet instances by adding Servlet initialization
                parameters (init-param elements) to the Servlet declaration in the web.xml file. The following table
                lists the supported parameters:
                    Parameter                                               Explanation
                    contextClass                                            Class that implements
                                                                            ConfigurableWebApplicationContext, to be
                                                                            instantiated and locally configured by this
                                                                            Servlet. By default, XmlWebApplicationContext is
                                                                            used.
                    contextConfigLocation                                   String that is passed to the context instance
                                                                            (specified by contextClass) to indicate where
                                                                            contexts can be found. The string consists
                                                                            potentially of multiple strings (using a comma as
                                                                            a delimiter) to support multiple contexts. In the
                                                                            case of multiple context locations with beans
                                                                            that are defined twice, the latest location takes
                                                                            precedence.
                    namespace                                               Namespace of the WebApplicationContext.
                                                                            Defaults to [servlet-name]-servlet.
                    throwExceptionIfNoHandlerFound                          Whether to throw a NoHandlerFoundException
                                                                            when no handler was found for a request. The
                                                                            exception can then be caught with a
                                                                            HandlerExceptionResolver (for example, by using
                                                                            an @ExceptionHandler controller method) and
                                                                            handled as any others.
                                                                            By default, this is set to false, in which case the
                                                                            DispatcherServlet sets the response status to 404
                                                                            (NOT_FOUND) without raising an exception.
                                                                            Note that, if default servlet handling is also
                                                                            configured, unresolved requests are always
                                                                            forwarded to the default servlet and a 404 is
                                                                            never raised.

            Path Matching
!!!!            The Servlet API exposes the full request path as requestURI and further sub-divides it into
                contextPath, servletPath, and pathInfo whose values vary depending on how a Servlet is mapped.
                From these inputs, Spring MVC needs to determine the lookup path to use for mapping handlers,
                which should exclude the contextPath and any servletMapping prefix, if applicable

                The servletPath and pathInfo are decoded and that makes them impossible to compare directly to
                the full requestURI in order to derive the lookupPath and that makes it necessary to decode the
                requestURI. However this introduces its own issues because the path may contain encoded reserved
                characters such as "/" or ";" that can in turn alter the structure of the path after they are decoded
                which can also lead to security issues. In addition, Servlet containers may normalize the
                servletPath to varying degrees which makes it further impossible to perform startsWith
                comparisons against the requestURI.

                If the DispatcherServlet is mapped as the default Servlet with "/" or
                otherwise without a prefix with "/*" and the Servlet container is 4.0+ then Spring MVC is able to
                detect the Servlet mapping type and avoid use of the servletPath and pathInfo altogether. On a 3.1
                Servlet container, assuming the same Servlet mapping types, the equivalent can be achieved by
                providing a UrlPathHelper with alwaysUseFullPath=true via Path Matching in the MVC config

            Interception
!!              All HandlerMapping implementations support handler interceptors that are useful when you want to
                apply specific functionality to certain requests — for example, checking for a principal. Interceptors
                must implement HandlerInterceptor from the org.springframework.web.servlet package with three
                methods that should provide enough flexibility to do all kinds of pre-processing and postprocessing:
                    • preHandle(..): Before the actual handler is run
                    • postHandle(..): After the handler is run
                    • afterCompletion(..): After the complete request has finished

!!              The preHandle(..) method returns a boolean value. You can use this method to break or continue
                the processing of the execution chain. When this method returns true, the handler execution chain
                continues. When it returns false, the DispatcherServlet assumes the interceptor itself has taken care
                of requests (and, for example, rendered an appropriate view) and does not continue executing the
                other interceptors and the actual handler in the execution chain.

            Exceptions
            todo continue


















































































