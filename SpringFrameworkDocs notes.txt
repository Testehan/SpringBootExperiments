Spring Framework Documentation Version 6.0.0

https://docs.spring.io/spring-framework/docs/6.0.0/reference/pdf/spring-framework.pdf

========================================================================================================================
Chapter 1. Spring Framework Overview

    Spring is open source. It has a large and active community that provides continuous feedback based
    on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very
    long time.

    Spring supports a wide range of application scenarios. In a large enterprise, applications often exist
    for a long time and have to run on a JDK and application server whose upgrade cycle is beyond
    developer control. Others may run as a single jar with the server embedded, possibly in a cloud
    environment. Yet others may be standalone applications (such as batch or integration workloads)
    that do not need a server

    1.1. What We Mean by "Spring"
        The term "Spring" means different things in different contexts. It can be used to refer to the Spring
        Framework project itself. Over time, other Spring projects have been
        built on top of the Spring Framework. Most often, when people say "Spring", they mean the entire
        family of projects.

        The Spring Framework is divided into modules. Applications can choose which modules they need.
        At the heart are the modules of the core container, including a configuration model and a
        dependency injection mechanism. Beyond that, the Spring Framework provides foundational
        support for different application architectures, including messaging, transactional data and
        persistence, and web. It also includes the Servlet-based Spring MVC web framework and, in
        parallel, the Spring WebFlux reactive web framework

    1.2. History of Spring and the Spring Framework
        Spring came into being in 2003 as a response to the complexity of the early J2EE specifications.
        While some consider Java EE and its modern-day successor Jakarta EE to be in competition with
        Spring, they are in fact complementary. The Spring programming model does not embrace the
        Jakarta EE platform specification; rather, it integrates with carefully selected individual
        specifications from the traditional EE umbrella:
            • Servlet API (JSR 340)
            • WebSocket API (JSR 356)
            • Concurrency Utilities (JSR 236)
            • JSON Binding API (JSR 367)
            • Bean Validation (JSR 303)
            • JPA (JSR 338)
            • JMS (JSR 914)
            • as well as JTA/JCA setups for transaction coordination, if necessary

        The Spring Framework also supports the Dependency Injection (JSR 330) and Common Annotations
        (JSR 250) specifications, which application developers may choose to use instead of the Spring specific
        mechanisms provided by the Spring Framework.

        As of Spring Framework 6.0, Spring has been upgraded to the Jakarta EE 9 level (e.g. Servlet 5.0+,
        JPA 3.0+), based on the jakarta namespace instead of the traditional javax packages. With EE 9 as
        the minimum and EE 10 supported already, Spring is prepared to provide out-of-the-box support
        for the further evolution of the Jakarta EE APIs. Spring Framework 6.0 is fully compatible with
        Tomcat 10.1, Jetty 11 and Undertow 2.3 as web servers, and also with Hibernate ORM 6.1

        Over time, the role of Java/Jakarta EE in application development has evolved. In the early days of
        J2EE and Spring, applications were created to be deployed to an application server. Today, with the
        help of Spring Boot, applications are created in a devops- and cloud-friendly way, with the Servlet
        container embedded and trivial to change. As of Spring Framework 5, a WebFlux application does
        not even use the Servlet API directly and can run on servers (such as Netty) that are not Servlet
        containers.

        Spring continues to innovate and to evolve. Beyond the Spring Framework, there are other projects,
        such as Spring Boot, Spring Security, Spring Data, Spring Cloud, Spring Batch, among others. It’s
        important to remember that each project has its own source code repository, issue tracker, and
        release cadence

    1.3. Design Philosophy
        When you learn about a framework, it’s important to know not only what it does but what
        principles it follows. Here are the guiding principles of the Spring Framework:
            • Provide choice at every level. Spring lets you defer design decisions as late as possible. For
            example, you can switch persistence providers through configuration without changing your
            code. The same is true for many other infrastructure concerns and integration with third-party
            APIs.
            • Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated about
            how things should be done. It supports a wide range of application needs with different
            perspectives.
            • Maintain strong backward compatibility. Spring’s evolution has been carefully managed to
            force few breaking changes between versions. Spring supports a carefully chosen range of JDK
            versions and third-party libraries to facilitate maintenance of applications and libraries that
            depend on Spring.
            • Care about API design. The Spring team puts a lot of thought and time into making APIs that are
            intuitive and that hold up across many versions and many years.
            • Set high standards for code quality. The Spring Framework puts a strong emphasis on
            meaningful, current, and accurate javadoc. It is one of very few projects that can claim clean
            code structure with no circular dependencies between packages

    1.5. Getting Started
        If you are just getting started with Spring, you may want to begin using the Spring Framework by
        creating a Spring Boot (https://projects.spring.io/spring-boot/)-based application. Spring Boot provides a quick (and opinionated) way to
        create a production-ready Spring-based application. It is based on the Spring Framework, favors
        convention over configuration, and is designed to get you up and running as quickly as possible.
        You can use start.spring.io to generate a basic project or follow one of the "Getting Started" guides,
        such as Getting Started Building a RESTful Web Service. As well as being easier to digest, these
        guides are very task focused, and most of them are based on Spring Boot. They also cover other
        projects from the Spring portfolio that you might want to consider when solving a particular
        problem


========================================================================================================================
Chapter 2. Core Technologies

Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough
treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage
of Spring’s Aspect-Oriented Programming (AOP) technologies

    2.1. The IoC Container

        2.1.1. Introduction to the Spring IoC Container and Beans
            This chapter covers the Spring Framework implementation of the Inversion of Control (IoC)
            principle. IoC is also known as dependency injection (DI). It is a process whereby objects define
            their dependencies (that is, the other objects they work with) only through constructor arguments,
            arguments to a factory method, or properties that are set on the object instance after it is
            constructed or returned from a factory method. The container then injects those dependencies
            when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of
            Control) of the bean itself controlling the instantiation or location of its dependencies by using
            direct construction of classes or a mechanism such as the Service Locator pattern.

            The org.springframework.beans and org.springframework.context packages are the basis for Spring
            Framework’s IoC container.
!!!!
            In Spring, the objects that form the backbone of your application and that are managed by the
            Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and
            managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your
            application. Beans, and the dependencies among them, are reflected in the configuration metadata
            used by a container.

        2.1.2. Container Overview
            The org.springframework.context.ApplicationContext interface represents the Spring IoC container
            and is responsible for instantiating, configuring, and assembling the beans. The container gets its
            instructions on what objects to instantiate, configure, and assemble by reading configuration
            metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets
            you express the objects that compose your application and the rich interdependencies between
            those objects

            Several implementations of the ApplicationContext interface are supplied with Spring. In standalone
            applications, it is common to create an instance of ClassPathXmlApplicationContext or
            FileSystemXmlApplicationContext. While XML has been the traditional format for defining
            configuration metadata, you can instruct the container to use Java annotations or code as the
            metadata

            In most application scenarios, explicit user code is not required to instantiate one or more
            instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or
            so) lines of boilerplate web descriptor XML in the web.xml file of the application typically suffices

            The following diagram shows a high-level view of how Spring works. Your application classes are
            combined with configuration metadata so that, after the ApplicationContext is created and
            initialized, you have a fully configured and executable system or application.

                business objects (POJOs) + configuration metadata => fully configured system ready for use

            This configuration metadata represents how you, as an application developer, tell the
            Spring container to instantiate, configure, and assemble the objects in your application.

            Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is
            what most of this chapter uses to convey key concepts and features of the Spring IoC container.
                (Dan : well...this sucks...i won't add XML examples, unless very important, as nowadays most people
                use Annotations...)

            For information about using other forms of metadata with the Spring container, see:
                • Annotation-based configuration: Spring 2.5 introduced support for annotation-based
                configuration metadata.
                • Java-based configuration: Starting with Spring 3.0, many features provided by the Spring
                JavaConfig project became part of the core Spring Framework. Thus, you can define beans
                external to your application classes by using Java rather than XML files. To use these new
                features, see the @Configuration, @Bean, @Import, and @DependsOn annotations.

            XML-based configuration metadata configures these beans as <bean/> elements inside a top-level <beans/>
            element. Java configuration typically uses @Bean-annotated methods within a @Configuration class.

            These bean definitions correspond to the actual objects that make up your application. Typically,
            you define service layer objects, data access objects (DAOs), presentation objects such as Struts
            Action instances, infrastructure objects such as Hibernate SessionFactories, JMS Queues, and so
            forth. Typically, one does not configure fine-grained domain objects in the container, because it is
            usually the responsibility of DAOs and business logic to create and load domain objects

            Instantiating a Container
            The location path or paths supplied to an ApplicationContext constructor are resource strings that
            let the container load configuration metadata from a variety of external resources, such as the local
            file system, the Java CLASSPATH, and so on.

                ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

            Composing XML-based Configuration Metadata
            It can be useful to have bean definitions span multiple XML files. Often, each individual XML
            configuration file represents a logical layer or module in your architecture

            Using the Container
            The ApplicationContext is the interface for an advanced factory capable of maintaining a registry of
            different beans and their dependencies. By using the method T getBean(String name, Class<T>
            requiredType), you can retrieve instances of your beans

            You can then use getBean to retrieve instances of your beans. The ApplicationContext interface has a
            few other methods for retrieving beans, but, ideally, your application code should never use them.
            Indeed, your application code should have no calls to the getBean() method at all and thus have no
            dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides
            dependency injection for various web framework components such as controllers and JSF-managed
            beans, letting you declare a dependency on a specific bean through metadata (such as an
            autowiring annotation).

        2.1.3. Bean Overview
            A Spring IoC container manages one or more beans. These beans are created with the configuration
            metadata that you supply to the container (for example, in the form of XML <bean/> definitions).
            Within the container itself, these bean definitions are represented as BeanDefinition objects, which
            contain (among other information) the following metadata:
                • A package-qualified class name: typically, the actual implementation class of the bean
                • Bean behavioral configuration elements, which state how the bean should behave in the
                container (scope, lifecycle callbacks, and so forth).
                • References to other beans that are needed for the bean to do its work. These references are also
                called collaborators or dependencies.
                • Other configuration settings to set in the newly created object — for example, the size limit of
                the pool or the number of connections to use in a bean that manages a connection pool.

            ApplicationContext implementations also permit the registration of existing objects that are created
            outside the container (by users). This is done by accessing the ApplicationContext’s BeanFactory
            through the getBeanFactory() method, which returns the DefaultListableBeanFactory
            implementation. DefaultListableBeanFactory supports this registration through the
            registerSingleton(..) and registerBeanDefinition(..) methods. However, typical applications
            work solely with beans defined through regular bean definition metadata.
!!!
            While overriding existing metadata and existing singleton instances is supported to some degree, the
            registration of new beans at runtime (concurrently with live access to the factory) is not officially
            supported and may lead to concurrent access exceptions, inconsistent state in the
            bean container, or both.

            Naming Beans
            Every bean has one or more identifiers. These identifiers must be unique within the container that
            hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the
            extra ones can be considered aliases.

            In XML-based configuration metadata, you use the id attribute, the name attribute, or both to specify
             the bean identifiers. The id attribute lets you specify exactly one id. Conventionally, these names
             are alphanumeric ('myBean', 'someService', etc.), but they can contain special characters as well. If
             you want to introduce other aliases for the bean, you can also specify them in the name attribute,
             separated by a comma (,), semicolon (;), or white space.

            You are not required to supply a name or an id for a bean. If you do not supply a name or id explicitly,
            the container generates a unique name for that bean. However, if you want to refer to that bean by
            name, through the use of the ref element or a Service Locator style lookup, you must provide a name.

                Bean Naming Conventions
                The convention is to use the standard Java convention for instance field names when naming
                beans. That is, bean names start with a lowercase letter and are camel-cased from there.
                Examples of such names include accountManager, accountService, userDao, loginController, and
                so forth.

            Aliasing a Bean outside the Bean Definition
            In a bean definition itself, you can supply more than one name for the bean, by using a
            combination of up to one name specified by the id attribute and any number of other names in the
            name attribute. These names can be equivalent aliases to the same bean and are useful for some
            situations, such as letting each component in an application refer to a common dependency by
            using a bean name that is specific to that component itself.
            In XML-based configuration metadata, you can use the <alias/> element to accomplish this

            For example, the configuration metadata for subsystem A may refer to a DataSource by the name of
            subsystemA-dataSource. The configuration metadata for subsystem B may refer to a DataSource by
            the name of subsystemB-dataSource. When composing the main application that uses both these
            subsystems, the main application refers to the DataSource by the name of myApp-dataSource. To have
            all three names refer to the same object, you can add the following alias definitions to the
            configuration metadata:
                <alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
                <alias name="myApp-dataSource" alias="subsystemB-dataSource"/>

            If you use Java configuration, the @Bean annotation can be used to provide aliases. See Using
            the @Bean Annotation for details.

            Instantiating Beans
            A bean definition is essentially a recipe for creating one or more objects. The container looks at the
            recipe for a named bean when asked and uses the configuration metadata encapsulated by that
            bean definition to create (or acquire) an actual object.

            You can use the Class property in one of two ways:
            • Typically, to specify the bean class to be constructed in the case where the container itself
            directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java
            code with the new operator.
            • To specify the actual class containing the static factory method that is invoked to create the
            object, in the less common case where the container invokes a static factory method on a class
            to create the bean. The object type returned from the invocation of the static factory method
            may be the same class or another class entirely.

            Instantiation with a Constructor
            When you create a bean by the constructor approach, all normal classes are usable by and
            compatible with Spring. That is, the class being developed does not need to implement any specific
            interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice.
            However, depending on what type of IoC you use for that specific bean, you may need a default
            (empty) constructor.

            The Spring IoC container can manage virtually any class you want it to manage. It is not limited to
            managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (noargument) constructor and appropriate setters and getters modeled after the properties in the
            container. You can also have more exotic non-bean-style classes in your container. If, for example,
            you need to use a legacy connection pool that absolutely does not adhere to the JavaBean
            specification, Spring can manage it as well.

            Instantiation with a Static Factory Method
            When defining a bean that you create with a static factory method, use the class attribute to specify
            the class that contains the static factory method and an attribute named factory-method to specify
            the name of the factory method itself. You should be able to call this method (with optional
            arguments, as described later) and return a live object, which subsequently is treated as if it had
            been created through a constructor. One use for such a bean definition is to call static factories in
            legacy code

            In Spring documentation, "factory bean" refers to a bean that is configured in the
            Spring container and that creates objects through an instance or static factory
            method. By contrast, FactoryBean (notice the capitalization) refers to a Spring specific FactoryBean implementation class.

        2.1.4. Dependencies
            A typical enterprise application does not consist of a single object (or bean in the Spring parlance).
            Even the simplest application has a few objects that work together to present what the end-user
            sees as a coherent application. This next section explains how you go from defining a number of
            bean definitions that stand alone to a fully realized application where objects collaborate to achieve
            a goal.

!!!         Dependency Injection
            Dependency injection (DI) is a process whereby objects define their dependencies (that is, the other
            objects with which they work) only through constructor arguments, arguments to a factory method,
            or properties that are set on the object instance after it is constructed or returned from a factory
            method. The container then injects those dependencies when it creates the bean. This process is
            fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the
            instantiation or location of its dependencies on its own by using direct construction of classes or the
            Service Locator pattern.

            Code is cleaner with the DI principle, and decoupling is more effective when objects are provided
            with their dependencies. The object does not look up its dependencies and does not know the
            location or class of the dependencies. As a result, your classes become easier to test, particularly
            when the dependencies are on interfaces or abstract base classes, which allow for stub or mock
            implementations to be used in unit tests

            DI exists in two major variants: Constructor-based dependency injection and Setter-based
            dependency injection.

            Constructor-based Dependency Injection
            Constructor-based DI is accomplished by the container invoking a constructor with a number of
            arguments, each representing a dependency. Calling a static factory method with specific
            arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a
            constructor and to a static factory method similarly.

            Constructor Argument Resolution
            Constructor argument resolution matching occurs by using the argument’s type. If no potential
            ambiguity exists in the constructor arguments of a bean definition, the order in which the
            constructor arguments are defined in a bean definition is the order in which those arguments are
            supplied to the appropriate constructor when the bean is being instantiated

            Setter-based Dependency Injection
            Setter-based DI is accomplished by the container calling setter methods on your beans after
            invoking a no-argument constructor or a no-argument static factory method to instantiate your bean.

            The ApplicationContext supports constructor-based and setter-based DI for the beans it manages. It
            also supports setter-based DI after some dependencies have already been injected through the
            constructor approach. You configure the dependencies in the form of a BeanDefinition, which you
            use in conjunction with PropertyEditor instances to convert properties from one format to another.
            However, most Spring users do not work with these classes directly (that is, programmatically) but
            rather with XML bean definitions, annotated components (that is, classes annotated with @Component,
            @Controller, and so forth), or @Bean methods in Java-based @Configuration classes

!!!!        The Spring team generally advocates constructor injection, as it lets you implement
            application components as immutable objects and ensures that required dependencies are
            not null. Furthermore, constructor-injected components are always returned to the client
            (calling) code in a fully initialized state. As a side note, a large number of constructor
            arguments is a bad code smell, implying that the class likely has too many responsibilities and
            should be refactored to better address proper separation of concerns.

!!          Setter injection should primarily only be used for optional dependencies that can be assigned
            reasonable default values within the class. Otherwise, not-null checks must be performed
            everywhere the code uses the dependency. One benefit of setter injection is that setter
            methods make objects of that class amenable to reconfiguration or re-injection later.
            Management through JMX MBeans is therefore a compelling use case for setter injection.

            Use the DI style that makes the most sense for a particular class. Sometimes, when dealing
            with third-party classes for which you do not have the source, the choice is made for you. For
            example, if a third-party class does not expose any setter methods, then constructor injection
            may be the only available form of DI.

!!!         Dependency Resolution Process
            The container performs bean dependency resolution as follows:
            • The ApplicationContext is created and initialized with configuration metadata that describes all
            the beans. Configuration metadata can be specified by XML, Java code, or annotations.
            • For each bean, its dependencies are expressed in the form of properties, constructor arguments,
            or arguments to the static-factory method (if you use that instead of a normal constructor).
            These dependencies are provided to the bean, when the bean is actually created.
            • Each property or constructor argument is an actual definition of the value to set, or a reference
            to another bean in the container.
            • Each property or constructor argument that is a value is converted from its specified format to
            the actual type of that property or constructor argument. By default, Spring can convert a value
            supplied in string format to all built-in types, such as int, long, String, boolean, and so forth.
            The Spring container validates the configuration of each bean as the container is created. However,
            the bean properties themselves are not set until the bean is actually created. Beans that are
            singleton-scoped and set to be pre-instantiated (the default) are created when the container is
            created. Scopes are defined in Bean Scopes. Otherwise, the bean is created only when it is
            requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s
            dependencies and its dependencies' dependencies (and so on) are created and assigned.

            Circular dependencies
            If you configure beans for
            classes A and B to be injected into each other, the Spring IoC container detects this circular
            reference at runtime, and throws a BeanCurrentlyInCreationException.
            One possible solution is to edit the source code of some classes to be configured by setters
            rather than constructors. Alternatively, avoid constructor injection and use setter injection
            only. In other words, although it is not recommended, you can configure circular
            dependencies with setter injection.
            Unlike the typical case (with no circular dependencies), a circular dependency between bean
            A and bean B forces one of the beans to be injected into the other prior to being fully
            initialized itself (a classic chicken-and-egg scenario).

            You can generally trust Spring to do the right thing. It detects configuration problems, such as
            references to non-existent beans and circular dependencies, at container load-time. Spring sets
            properties and resolves dependencies as late as possible, when the bean is actually created. This
            means that a Spring container that has loaded correctly can later generate an exception when you
            request an object if there is a problem creating that object or one of its dependencies — for
            example, the bean throws an exception as a result of a missing or invalid property. This potentially
            delayed visibility of some configuration issues is why ApplicationContext implementations by
            default pre-instantiate singleton beans. At the cost of some upfront time and memory to create
            these beans before they are actually needed, you discover configuration issues when the
            ApplicationContext is created, not later. You can still override this default behavior so that singleton
            beans initialize lazily, rather than being eagerly pre-instantiated.

            Strongly-typed collection
            Thanks to Java’s support for generic types, you can use strongly typed collections. That is, it is
            possible to declare a Collection type such that it can only contain (for example) String elements. If
            you use Spring to dependency-inject a strongly-typed Collection into a bean, you can take
            advantage of Spring’s type-conversion support such that the elements of your strongly-typed
            Collection instances are converted to the appropriate type prior to being added to the Collection

            Null and Empty String Values
            Spring treats empty arguments for properties and the like as empty Strings.
            The <null/> element handles null values.        (Dan: this is for XML based configurations)

!!          Lazy-initialized Beans
            By default, ApplicationContext implementations eagerly create and configure all singleton beans as
            part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the
            configuration or surrounding environment are discovered immediately, as opposed to hours or
            even days later. When this behavior is not desirable, you can prevent pre-instantiation of a
            singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells
            the IoC container to create a bean instance when it is first requested, rather than at startup.

            However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazyinitialized, the
            ApplicationContext creates the lazy-initialized bean at startup, because it must
            satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean
            elsewhere that is not lazy-initialized.

            Autowiring Collaborators
            The Spring container can autowire relationships between collaborating beans. You can let Spring
            resolve collaborators (other beans) automatically for your bean by inspecting the contents of the
            ApplicationContext. Autowiring has the following advantages:
                • Autowiring can significantly reduce the need to specify properties or constructor arguments.
                (Other mechanisms such as a bean template discussed elsewhere in this chapter are also
                valuable in this regard.)
                • Autowiring can update a configuration as your objects evolve. For example, if you need to add a
                dependency to a class, that dependency can be satisfied automatically without you needing to
                modify the configuration. Thus autowiring can be especially useful during development,
                without negating the option of switching to explicit wiring when the code base becomes more
                stable.

            The following table describes the four autowiring modes:
                no -> (Default) No autowiring. Bean references must be defined by ref elements.
                Changing the default setting is not recommended for larger deployments,
                because specifying collaborators explicitly gives greater control and clarity. To
                some extent, it documents the structure of a system.

                byName -> Autowiring by property name. Spring looks for a bean with the same name as
                the property that needs to be autowired. For example, if a bean definition is
                set to autowire by name and it contains a master property (that is, it has a
                setMaster(..) method), Spring looks for a bean definition named master and
                uses it to set the property.

                byType -> Lets a property be autowired if exactly one bean of the property type exists in
                the container. If more than one exists, a fatal exception is thrown, which
                indicates that you may not use byType autowiring for that bean. If there are no
                matching beans, nothing happens (the property is not set).

                constructor ->  Analogous to byType but applies to constructor arguments. If there is not
                exactly one bean of the constructor argument type in the container, a fatal
                error is raised.

            Consider the limitations and disadvantages of autowiring:
                • Explicit dependencies in property and constructor-arg settings always override autowiring. You
                cannot autowire simple properties such as primitives, Strings, and Classes (and arrays of such
                simple properties). This limitation is by-design.
                • Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is
                careful to avoid guessing in case of ambiguity that might have unexpected results. The
                relationships between your Spring-managed objects are no longer documented explicitly.
                • Wiring information may not be available to tools that may generate documentation from a
                Spring container.
                • Multiple bean definitions within the container may match the type specified by the setter
                method or constructor argument to be autowired. For arrays, collections, or Map instances, this is
                not necessarily a problem. However, for dependencies that expect a single value, this ambiguity
                is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.

            Method Injection
            In most application scenarios, most beans in the container are singletons. When a singleton bean
            needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with
            another non-singleton bean, you typically handle the dependency by defining one bean as a
            property of the other. A problem arises when the bean lifecycles are different. Suppose singleton
            bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A.
            The container creates the singleton bean A only once, and thus only gets one opportunity to set the
            properties. The container cannot provide bean A with a new instance of bean B every time one is
            needed.
            A solution is to forego some inversion of control. You can make bean A aware of the container by
            implementing the ApplicationContextAware interface, and by making a getBean("B") call to the
            container ask for (a typically new) bean B instance every time bean A needs it

            Lookup Method Injection
            Lookup method injection is the ability of the container to override methods on container-managed
            beans and return the lookup result for another named bean in the container. The lookup typically
            involves a prototype bean, as in the scenario described in the preceding section. The Spring
            Framework implements this method injection by using bytecode generation from the CGLIB library
            to dynamically generate a subclass that overrides the method.

            Alternatively, within the annotation-based component model, you can declare a lookup method
            through the @Lookup annotation, as the following example shows:

                (Dan: A method annotated with @Lookup tells Spring to return an instance of the method's return type
                        when we invoke it. Essentially, Spring will override our annotated method and use our method's
                        return type and parameters as arguments to BeanFactory#getBean.

                      @Lookup is useful for:
                        Injecting a prototype-scoped bean into a singleton bean (similar to Provider)
                        Injecting dependencies procedurally)

            Arbitrary Method Replacement
            A less useful form of method injection than lookup method injection is the ability to replace
            arbitrary methods in a managed bean with another method implementation. You can safely skip
            the rest of this section until you actually need this functionality


        2.1.5. Bean Scopes
            When you create a bean definition, you create a recipe for creating actual instances of the class
            defined by that bean definition. The idea that a bean definition is a recipe is important, because it
            means that, as with a class, you can create many object instances from a single recipe.

!!!!        Beans can be defined to be deployed in one of a number of scopes. The Spring Framework supports
            six scopes, four of which are available only if you use a web-aware ApplicationContext. You can also
            create a custom scope.

!!!!        The following table describes the supported scopes:
            Scope                   Description
            singleton               (Default) Scopes a single bean definition to a single object instance for each
                                    Spring IoC container.
            prototype               Scopes a single bean definition to any number of object instances
                                (Dan:  A new object is created each time it is injected/looked up)
            request                 Scopes a single bean definition to the lifecycle of a single HTTP request. That
                                    is, each HTTP request has its own instance of a bean created off the back of a
                                    single bean definition. Only valid in the context of a web-aware Spring
                                    ApplicationContext.
            session                 Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid
                                    in the context of a web-aware Spring ApplicationContext.
            application             Scopes a single bean definition to the lifecycle of a ServletContext. Only valid
                                    in the context of a web-aware Spring ApplicationContext.
            websocket               Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the
                                    context of a web-aware Spring ApplicationContext.

!!!         The Singleton Scope
            Only one shared instance of a singleton bean is managed, and all requests for beans with an ID or
            IDs that match that bean definition result in that one specific bean instance being returned by the
            Spring container.
            To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring
            IoC container creates exactly one instance of the object defined by that bean definition. This single
            instance is stored in a cache of such singleton beans, and all subsequent requests and references
            for that named bean return the cached object.

            Spring’s concept of a singleton bean differs from the singleton pattern as defined in the Gang of
            Four (GoF) patterns book. The GoF singleton hard-codes the scope of an object such that one and
            only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton
            is best described as being per-container and per-bean. This means that, if you define one bean for a
            particular class in a single Spring container, the Spring container creates one and only one instance
            of the class defined by that bean definition.

!!!!!!      The singleton scope is the default scope in Spring.

            The Prototype Scope
            The non-singleton prototype scope of bean deployment results in the creation of a new bean
            instance every time a request for that specific bean is made. That is, the bean is injected into
            another bean or you request it through a getBean() method call on the container.

!!!!!!      As a rule, you should use the prototype scope for all stateful beans and the singleton scope for
            stateless beans.

!!!!        In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean
            The container instantiates, configures, and otherwise assembles a prototype object and hands it to
            the client, with no further record of that prototype instance. Thus, although initialization lifecycle
            callback methods are called on all objects regardless of scope, in the case of prototypes, configured
            destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped
            objects and release expensive resources that the prototype beans hold. To get the Spring container
            to release resources held by prototype-scoped beans, try using a custom bean post-processor, which
            holds a reference to beans that need to be cleaned up.

            Singleton Beans with Prototype-bean Dependencies
            When you use singleton-scoped beans with dependencies on prototype beans, be aware that
            dependencies are resolved at instantiation time. Thus, if you dependency-inject a prototype-scoped
            bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency injected into
            the singleton bean. The prototype instance is the sole instance that is ever supplied to
            the singleton-scoped bean.
            However, suppose you want the singleton-scoped bean to acquire a new instance of the prototypescoped bean
            repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into
            your singleton bean, because that injection occurs only once, when the Spring container
            instantiates the singleton bean and resolves and injects its dependencies. If you need a new
            instance of a prototype bean at runtime more than once, see Method Injection.

            Request, Session, Application, and WebSocket Scopes
            The request, session, application, and websocket scopes are available only if you use a web-aware
            Spring ApplicationContext implementation (such as XmlWebApplicationContext). If you use these
            scopes with regular Spring IoC containers, such as the ClassPathXmlApplicationContext, an
            IllegalStateException that complains about an unknown bean scope is thrown.

            Initial Web Configuration
            To support the scoping of beans at the request, session, application, and websocket levels
            (webscoped beans), some minor initial configuration is required before you define your beans. (This
            initial setup is not required for the standard scopes: singleton and prototype.)
            How you accomplish this initial setup depends on your particular Servlet environment.
            If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by
            the Spring DispatcherServlet, no special setup is necessary. DispatcherServlet already exposes all
            relevant state.
            If you use a Servlet web container, with requests processed outside of Spring’s DispatcherServlet
            (for example, when using JSF or Struts), you need to register the
            org.springframework.web.context.request.RequestContextListener ServletRequestListener. This can
            be done programmatically by using the WebApplicationInitializer interface. Alternatively, add the
            following declaration to your web application’s web.xml file:
                <web-app>
                  ...
                  <listener>
                    <listener-class>
                        org.springframework.web.context.request.RequestContextListener
                    </listener-class>
                  </listener>
                  ...
                </web-app>

            Alternatively, if there are issues with your listener setup, consider using Spring’s
            RequestContextFilter. The filter mapping depends on the surrounding web application
            configuration, so you have to change it as appropriate. The following listing shows the filter part of
            a web application:
                <web-app>
                  ...
                  <filter>
                    <filter-name>requestContextFilter</filter-name>
                    <filter-class>org.springframework.web.filter.RequestContextFilter</filterclass>
                  </filter>
                  <filter-mapping>
                    <filter-name>requestContextFilter</filter-name>
                    <url-pattern>/*</url-pattern>
                  </filter-mapping>
                  ...
                </web-app>

!!!!!!!!    DispatcherServlet, RequestContextListener, and RequestContextFilter all do exactly the same thing,
            namely bind the HTTP request object to the Thread that is servicing that request. This makes beans
            that are request- and session-scoped available further down the call chain

            Request scope
            Consider the following XML configuration for a bean definition:
            <bean id="loginAction" class="com.something.LoginAction" scope="request"/>
            The Spring container creates a new instance of the LoginAction bean by using the loginAction bean
            definition for each and every HTTP request. That is, the loginAction bean is scoped at the HTTP
            request level. You can change the internal state of the instance that is created as much as you want,
            because other instances created from the same loginAction bean definition do not see these
            changes in state. They are particular to an individual request.
!!!         When the request completes processing, the bean that is scoped to the request is discarded

!!!         When using annotation-driven components or Java configuration, the @RequestScope annotation can
            be used to assign a component to the request scope.

            Session Scope
            Consider the following XML configuration for a bean definition:
            <bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
            The Spring container creates a new instance of the UserPreferences bean by using the
            userPreferences bean definition for the lifetime of a single HTTP Session. In other words, the
            userPreferences bean is effectively scoped at the HTTP Session level. As with request-scoped beans,
            you can change the internal state of the instance that is created as much as you want, knowing that
            other HTTP Session instances that are also using instances created from the same userPreferences
            bean definition do not see these changes in state, because they are particular to an individual HTTP
            Session.
!!!!        When the HTTP Session is eventually discarded, the bean that is scoped to that particular HTTP Session is
            also discarded.

!!!         When using annotation-driven components or Java configuration, you can use the @SessionScope
            annotation to assign a component to the session scope

            Application Scope
            Consider the following XML configuration for a bean definition:
            <bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
            The Spring container creates a new instance of the AppPreferences bean by using the appPreferences
            bean definition once for the entire web application. That is, the appPreferences bean is scoped at the
            ServletContext level and stored as a regular ServletContext attribute.

!!          This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton
            per ServletContext, not per Spring ApplicationContext (for which there may be several in any given web
            application), and it is actually exposed and therefore visible as a ServletContext attribute.

!!!         When using annotation-driven components or Java configuration, you can use the
            @ApplicationScope annotation to assign a component to the application scope.


!!!!!       Scoped Beans as Dependencies
            The Spring IoC container manages not only the instantiation of your objects (beans), but also the
            wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request scoped
            bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in
            place of the scoped bean. That is, you need to inject a proxy object that exposes the same public
            interface as the scoped object but that can also retrieve the real target object from the relevant
            scope (such as an HTTP request) and delegate method calls onto the real object.

                  <!-- an HTTP Session-scoped bean exposed as a proxy -->
                  <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
                    <!-- instructs the container to proxy the surrounding bean -->
                    <aop:scoped-proxy/> ①
                  </bean>
                  <!-- a singleton-scoped bean injected with a proxy to the above bean -->
                  <bean id="userService" class="com.something.SimpleUserService">
                    <!-- a reference to the proxied userPreferences bean -->
                    <property name="userPreferences" ref="userPreferences"/>
                  </bean>

            To create such a proxy, you insert a child <aop:scoped-proxy/> element into a scoped bean definition. Why do
            definitions of beans scoped at the request, session and custom-scope levels require the <aop:scopedproxy/>
            element? Consider the following singleton bean definition and contrast it with what you
            need to define for the aforementioned scopes (note that the following userPreferences bean
            definition as it stands is incomplete):
                <bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
                <bean id="userManager" class="com.something.UserManager">
                  <property name="userPreferences" ref="userPreferences"/>
                </bean>

!!!         In the preceding example, the singleton bean (userManager) is injected with a reference to the HTTP
            Session-scoped bean (userPreferences). The salient point here is that the userManager bean is a
            singleton: it is instantiated exactly once per container, and its dependencies (in this case only one,
            the userPreferences bean) are also injected only once. This means that the userManager bean
            operates only on the exact same userPreferences object (that is, the one with which it was originally
            injected).

            This is not the behavior you want when injecting a shorter-lived scoped bean into a longer-lived
            scoped bean (for example, injecting an HTTP Session-scoped collaborating bean as a dependency
            into singleton bean). Rather, you need a single userManager object, and, for the lifetime of an HTTP
            Session, you need a userPreferences object that is specific to the HTTP Session. Thus, the container
            creates an object that exposes the exact same public interface as the UserPreferences class (ideally
            an object that is a UserPreferences instance), which can fetch the real UserPreferences object from
            the scoping mechanism (HTTP request, Session, and so forth). The container injects this proxy
            object into the userManager bean, which is unaware that this UserPreferences reference is a proxy. In
            this example, when a UserManager instance invokes a method on the dependency-injected
            UserPreferences object, it is actually invoking a method on the proxy. The proxy then fetches the
            real UserPreferences object from (in this case) the HTTP Session and delegates the method
            invocation onto the retrieved real UserPreferences object.

            Thus, you need the following (correct and complete) configuration when injecting request- and
            session-scoped beans into collaborating objects, as the following example shows:
                <bean id="userPreferences" class="com.something.UserPreferences" scope="session">
                  <aop:scoped-proxy/>
                </bean>
                <bean id="userManager" class="com.something.UserManager">
                  <property name="userPreferences" ref="userPreferences"/>
                </bean>


            Choosing the Type of Proxy to Create
            By default, when the Spring container creates a proxy for a bean that is marked up with the
            <aop:scoped-proxy/> element, a CGLIB-based class proxy is created.

            CGLIB proxies intercept only public method calls! Do not call non-public methods
            on such a proxy. They are not delegated to the actual scoped target object

!!          Custom Scopes
            The bean scoping mechanism is extensible. You can define your own scopes or even redefine
            existing scopes, although the latter is considered bad practice and you cannot override the built-in
            singleton and prototype scopes.

            Creating a Custom Scope
!!          To integrate your custom scopes into the Spring container, you need to implement the
            org.springframework.beans.factory.config.Scope interface, which is described in this section. For an
            idea of how to implement your own scopes, see the Scope implementations that are supplied with
            the Spring Framework itself and the Scope javadoc, which explains the methods you need to
            implement in more detail

                (Dan: i did not add here more details about the subject, as this is not something that one comes across often)


    2.1.6. Customizing the Nature of a Bean
        The Spring Framework provides a number of interfaces you can use to customize the nature of a
        bean. This section groups them as follows:
            • Lifecycle Callbacks
            • ApplicationContextAware and BeanNameAware
            • Other Aware Interfaces

        Lifecycle Callbacks
!!!!    To interact with the container’s management of the bean lifecycle, you can implement the Spring
        InitializingBean and DisposableBean interfaces. The container calls afterPropertiesSet() for the
        former and destroy() for the latter to let the bean perform certain actions upon initialization and
        destruction of your beans.

            The JSR-250 @PostConstruct and @PreDestroy annotations are generally considered
            best practice for receiving lifecycle callbacks in a modern Spring application. Using
            these annotations means that your beans are not coupled to Spring-specific
            interfaces. For details, see Using @PostConstruct and @PreDestroy.
            If you do not want to use the JSR-250 annotations but you still want to remove
            coupling, consider init-method and destroy-method bean definition metadata.

        Internally, the Spring Framework uses BeanPostProcessor implementations to process any callback
        interfaces it can find and call the appropriate methods. If you need custom features or other
        lifecycle behavior Spring does not by default offer, you can implement a BeanPostProcessor yourself

        In addition to the initialization and destruction callbacks, Spring-managed objects may also
        implement the Lifecycle interface so that those objects can participate in the startup and shutdown
        process, as driven by the container’s own lifecycle.

!!!     We recommend that you do not use the InitializingBean interface, because it unnecessarily couples
        the code to Spring. Alternatively, we suggest using the @PostConstruct annotation or specifying a
        POJO initialization method. In the case of XML-based configuration metadata, you can use the initmethod
        attribute to specify the name of the method that has a void no-argument signature. With
        Java configuration, you can use the initMethod attribute of @Bean

        Consider the following example:
            <bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
            Java
            public class ExampleBean {
              public void init() {
              // do some initialization work
              }
            }

        The preceding example has almost exactly the same effect as the following example (which consists of two listings):
            <bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
            Java
            public class AnotherExampleBean implements InitializingBean {
              @Override
              public void afterPropertiesSet() {
              // do some initialization work
              }
            }

!!      However, the first of the two preceding examples does not couple the code to Spring.

        We recommend that you do not use the DisposableBean callback interface, because it unnecessarily
        couples the code to Spring. Alternatively, we suggest using the @PreDestroy annotation or specifying
        a generic method that is supported by bean definitions. With XML-based configuration metadata,
        you can use the destroy-method attribute on the <bean/>. With Java configuration, you can use the
        destroyMethod attribute of @Bean.

        You can assign the destroy-method attribute of a <bean> element a special (inferred)
        value, which instructs Spring to automatically detect a public close or shutdown
        method on the specific bean class. (Any class that implements
        java.lang.AutoCloseable or java.io.Closeable would therefore match.) You can
        also set this special (inferred) value on the default-destroy-method attribute of a
        <beans> element to apply this behavior to an entire set of beans (see Default
        Initialization and Destroy Methods). Note that this is the default behavior with Java configuration.

        Default Initialization and Destroy Methods
!!!!    When you write initialization and destroy method callbacks that do not use the Spring-specific
        InitializingBean and DisposableBean callback interfaces, you typically write methods with names
        such as init(), initialize(), dispose(), and so on. Ideally, the names of such lifecycle callback
        methods are standardized across a project so that all developers use the same method names and
        ensure consistency. You can configure the Spring container to “look” for named initialization and destroy
        callback method names on every bean. This means that you, as an application developer, can write your
        application classes and use an initialization callback called init(), without having to configure an
        init-method="init" attribute with each bean definition. The Spring IoC container calls that method
        when the bean is created (and in accordance with the standard lifecycle callback contract described
        previously). This feature also enforces a consistent naming convention for initialization and destroy
        method callbacks.
        Suppose that your initialization callback methods are named init() and your destroy callback
        methods are named destroy(). Your class then resembles the class in the following example:

            public class DefaultBlogService implements BlogService {
              private BlogDao blogDao;
              public void setBlogDao(BlogDao blogDao) {
                this.blogDao = blogDao;
              }
              // this is (unsurprisingly) the initialization callback method
              public void init() {
                if (this.blogDao == null) {
                    throw new IllegalStateException("The [blogDao] property must be set.");
                }
              }
            }

            <beans default-init-method="init">
              <bean id="blogService" class="com.something.DefaultBlogService">
              <property name="blogDao" ref="blogDao" />
              </bean>
            </beans>

        The presence of the default-init-method attribute on the top-level <beans/> element attribute causes
        the Spring IoC container to recognize a method called init on the bean class as the initialization
        method callback. When a bean is created and assembled, if the bean class has such a method, it is
        invoked at the appropriate time.
        You can configure destroy method callbacks similarly (in XML, that is) by using the defaultdestroy-method
        attribute on the top-level <beans/> element.

        The Spring container guarantees that a configured initialization callback is called immediately after
        a bean is supplied with all dependencies. Thus, the initialization callback is called on the raw bean
        reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target
        bean is fully created first and then an AOP proxy (for example) with its interceptor chain is applied.
        If the target bean and the proxy are defined separately, your code can even interact with the raw
        target bean, bypassing the proxy. Hence, it would be inconsistent to apply the interceptors to the
        init method, because doing so would couple the lifecycle of the target bean to its proxy or
        interceptors and leave strange semantics when your code interacts directly with the raw target
        bean.

        Combining Lifecycle Mechanisms
        As of Spring 2.5, you have three options for controlling bean lifecycle behavior:
            • The InitializingBean and DisposableBean callback interfaces
            • Custom init() and destroy() methods
            • The @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control
            a given bean

        Multiple lifecycle mechanisms configured for the same bean, with different initialization methods,
        are called as follows:
            1. Methods annotated with @PostConstruct
            2. afterPropertiesSet() as defined by the InitializingBean callback interface
            3. A custom configured init() method
        Destroy methods are called in the same order:
            1. Methods annotated with @PreDestroy
            2. destroy() as defined by the DisposableBean callback interface
            3. A custom configured destroy() method

        Startup and Shutdown Callbacks
        The Lifecycle interface defines the essential methods for any object that has its own lifecycle
        requirements (such as starting and stopping some background process):
            public interface Lifecycle {
              void start();
              void stop();
              boolean isRunning();
            }

        Any Spring-managed object may implement the Lifecycle interface. Then, when the
        ApplicationContext itself receives start and stop signals (for example, for a stop/restart scenario at
        runtime), it cascades those calls to all Lifecycle implementations defined within that context.

        The order of startup and shutdown invocations can be important. If a “depends-on” relationship
        exists between any two objects, the dependent side starts after its dependency, and it stops before
        its dependency. However, at times, the direct dependencies are unknown. You may only know that
        objects of a certain type should start prior to objects of another type. In those cases, the
        SmartLifecycle interface defines another option, namely the getPhase() method as defined on its
        super-interface, Phased.

        When starting, the objects with the lowest phase start first. When stopping, the reverse order is
        followed. Therefore, an object that implements SmartLifecycle and whose getPhase() method
        returns Integer.MIN_VALUE would be among the first to start and the last to stop. At the other end of
        the spectrum, a phase value of Integer.MAX_VALUE would indicate that the object should be started
        last and stopped first (likely because it depends on other processes to be running). When
        considering the phase value, it is also important to know that the default phase for any “normal”
        Lifecycle object that does not implement SmartLifecycle is 0.


        Shutting Down the Spring IoC Container Gracefully in Non-Web Applications
!!!!    This section applies only to non-web applications. Spring’s web-based
        ApplicationContext implementations already have code in place to gracefully shut
        down the Spring IoC container when the relevant web application is shut down

        If you use Spring’s IoC container in a non-web application environment (for example, in a rich
        client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful
        shutdown and calls the relevant destroy methods on your singleton beans so that all resources are
        released. You must still configure and implement these destroy callbacks correctly

        Thus, beans can programmatically manipulate the ApplicationContext that created them, through
        the ApplicationContext interface or by casting the reference to a known subclass of this interface
        (such as ConfigurableApplicationContext, which exposes additional functionality). One use would be
        the programmatic retrieval of other beans. Sometimes this capability is useful. However, in general,
        you should avoid it, because it couples the code to Spring and does not follow the Inversion of
        Control style, where collaborators are provided to beans as properties. Other methods of the
        ApplicationContext provide access to file resources, publishing application events, and accessing a
        MessageSource. These additional features are described in Additional Capabilities of the
        ApplicationContext.

        Other Aware Interfaces
        Besides ApplicationContextAware and BeanNameAware (discussed earlier), Spring offers a wide range of
        Aware callback interfaces that let beans indicate to the container that they require a certain
        infrastructure dependency. As a general rule, the name indicates the dependency type. The
        following table summarizes the most important Aware interfaces:
            Name                            Injected Dependency
            ApplicationContextAware         Declaring ApplicationContext.
            ApplicationEventPublisherAware  Event publisher of the enclosing ApplicationContext
            BeanClassLoaderAware            Class loader used to load the bean classes
            BeanFactoryAware                Declaring BeanFactory.
            BeanNameAware                   Name of the declaring bean
            LoadTimeWeaverAware             Defined weaver for processing class definition at load time.
            MessageSourceAware              Configured strategy for resolving messages (with support for parametrization
                                            and internationalization).
            NotificationPublisherAware      Spring JMX notification publisher.
            ResourceLoaderAware             Configured loader for low-level access to resources.
            ServletConfigAware              Current ServletConfig the container runs in. Valid only in
                                            a web-aware Spring ApplicationContext.
            ServletContextAware             Current ServletContext the container runs in. Valid only in
                                            a web-aware Spring ApplicationContext.

        Note again that using these interfaces ties your code to the Spring API and does not follow the
        Inversion of Control style. As a result, we recommend them for infrastructure beans that require
        programmatic access to the container.


    2.1.7. Bean Definition Inheritance
        A bean definition can contain a lot of configuration information, including constructor arguments,
        property values, and container-specific information, such as the initialization method, a static
        factory method name, and so on. A child bean definition inherits configuration data from a parent
        definition. The child definition can override some values or add others as needed. Using parent and
        child bean definitions can save a lot of typing. Effectively, this is a form of templating.

        If you work with an ApplicationContext interface programmatically, child bean definitions are
        represented by the ChildBeanDefinition class. Most users do not work with them on this level.
        Instead, they configure bean definitions declaratively in a class such as the
        ClassPathXmlApplicationContext. When you use XML-based configuration metadata, you can
        indicate a child bean definition by using the parent attribute, specifying the parent bean as the
        value of this attribute

        A child bean definition inherits scope, constructor argument values, property values, and method
        overrides from the parent, with the option to add new values. Any scope, initialization method,
        destroy method, or static factory method settings that you specify override the corresponding
        parent settings.
        The remaining settings are always taken from the child definition: depends on, autowire mode,
        dependency check, singleton, and lazy init


    2.1.8. Container Extension Points
        Typically, an application developer does not need to subclass ApplicationContext implementation
        classes. Instead, the Spring IoC container can be extended by plugging in implementations of
        special integration interfaces. The next few sections describe these integration interfaces.

        Customizing Beans by Using a BeanPostProcessor
        The BeanPostProcessor interface defines callback methods that you can implement to provide your
        own (or override the container’s default) instantiation logic, dependency resolution logic, and so
        forth. If you want to implement some custom logic after the Spring container finishes instantiating,
        configuring, and initializing a bean, you can plug in one or more custom BeanPostProcessor
        implementations

        An ApplicationContext automatically detects any beans that are defined in the configuration
        metadata that implement the BeanPostProcessor interface. The ApplicationContext registers these
        beans as post-processors so that they can be called later, upon bean creation. Bean post-processors
        can be deployed in the container in the same fashion as any other beans.

        Using callback interfaces or annotations in conjunction with a custom BeanPostProcessor
        implementation is a common means of extending the Spring IoC container. An example is Spring’s
        AutowiredAnnotationBeanPostProcessor — a BeanPostProcessor implementation that ships with the
        Spring distribution and autowires annotated fields, setter methods, and arbitrary config methods.

        Customizing Configuration Metadata with a BeanFactoryPostProcessor
        The next extension point that we look at is the
        org.springframework.beans.factory.config.BeanFactoryPostProcessor. The semantics of this
        interface are similar to those of the BeanPostProcessor, with one major difference:
        BeanFactoryPostProcessor operates on the bean configuration metadata. That is, the Spring IoC
        container lets a BeanFactoryPostProcessor read the configuration metadata and potentially change it
        before the container instantiates any beans other than BeanFactoryPostProcessor instances.

        A bean factory post-processor is automatically run when it is declared inside an ApplicationContext,
        in order to apply changes to the configuration metadata that define the container. Spring includes a
        number of predefined bean factory post-processors, such as PropertyOverrideConfigurer and
        PropertySourcesPlaceholderConfigurer.

!!!     Customizing Instantiation Logic with a FactoryBean
        You can implement the org.springframework.beans.factory.FactoryBean interface for objects that are
        themselves factories.
        The FactoryBean interface is a point of pluggability into the Spring IoC container’s instantiation
        logic. If you have complex initialization code that is better expressed in Java as opposed to a
        (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex
        initialization inside that class, and then plug your custom FactoryBean into the container.

        The FactoryBean concept and interface are used in a number of places within the Spring
        Framework. More than 50 implementations of the FactoryBean interface ship with Spring itself.

    2.1.9. Annotation-based Container Configuration     TODO Continue from here





















































































