Spring Security in Action

!!!!!!!
    Spring Security - playlist by the Author of the book
    https://www.youtube.com/watch?v=Of4HFbsPKqk&list=PLEocw3gLFc8XRaRBZkhBEZ_R3tmvfkWZz


    I have designed this book as a resource for a developer starting with no background in Spring Security.
    The reader should already know how to work with some of the Spring framework fundamental aspects such as these:
            Using the Spring context
            Implementing REST endpoints
            Using data sources

    In chapter 19, we discuss applying security configurations for reactive apps. For this
    chapter, I also consider that you understand reactive applications and how to develop
    them with Spring a prerequisite.

    My recommendation is that you try to write
    your own example from scratch together with the explanations in the book, and then
    only use the provided project to compare your solution with my solution. This
    approach helps you better understand the security configurations you’re learning

========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================
PART I First Steps

    Security is one of the essential nonfunctional qualities of a software system.
    One of the most crucial aspects you learn in this book is that you should consider security from the beginning
    stages of application development



========================================================================================================================
Chapter 1. Security today

    If we go to the official website, https://spring.io/projects/spring-security, we
    see Spring Security described as a powerful and highly customizable framework for
    authentication and access control. I would simply say it is a framework that enormously simplifies applying
    (or “baking”) security for Spring applications

    Spring Security, however, doesn’t automatically secure your application. It’s not
    some kind of magic panacea that guarantees a vulnerability-free app. Developers need
    to understand how to configure and customize Spring Security around the needs of
    their applications. How to do this depends on many factors, from the functional
    requirements to the architecture.

    To think about application-level security, you can consider your home and the way
    you allow access to it. Do you place the key under the entrance rug? Do you even have
    a key for your front door? The same concept applies to applications, and Spring Security helps you
    develop this functionality. It’s a puzzle that offers plenty of choices for
    building the exact image that describes your system. You can choose to leave your house
    completely unsecured, or you can decide not to allow everyone to enter your home.

!!!!Based on configurations, you write Spring Security components that intercept the requests and
    that ensure whoever makes the requests has permission to access protected resources.
    The developer configures components to do precisely what’s desired.

    Other responsibilities of Spring Security components relate to data storage as well
    as data transit between different parts of the systems. By intercepting calls to these different parts, the
    components can act on the data. For example, when data is stored,
    these components can apply encryption or hashing algorithms. The data encodings
    keep the data accessible only to privileged entities

    Application-level security (figure 1.3) refers to everything that an application should
    do to protect the environment it executes in, as well as the data it processes and stores.
    Mind that this isn’t only about the data affected and used by the application. An application might
    contain vulnerabilities that allow a malicious individual to affect the entire system!

    I referred earlier to authentication and authorization. And, indeed, these are often
    present in most applications. Through authentication, an application identifies a user
    (a person or another application). The purpose of identifying these is to be able to
    decide afterward what they should be allowed to do—that’s authorization.

!!!!
    I would also like to bring to your attention data storage. Data at rest adds to the
    responsibility of the application. Your app shouldn’t store all its data in a readable format.
    The application sometimes needs to keep the data either encrypted with a private key or hashed.
    Secrets like credentials and private keys can also be considered
    data at rest. These should be carefully stored, usually in a secrets vault.

!!! Finally, an executing application must manage its internal memory as well. It may
    sound strange, but data stored in the heap of the application can also present vulnerabilities.
    Sometimes the class design allows the app to store sensitive data like credentials or private keys for a
    long time. In such cases, someone who has the privilege to
    make a heap dump could find these details and then use them maliciously.

!!! The lessons learned from those who failed before you are that the
    cost of an attack is usually higher than the investment cost of avoiding the vulnerability

    We often describe vulnerability as a weakness that could allow the execution of actions that are unwanted,
    usually done with malicious intentions.
    An excellent start to understanding vulnerabilities is being aware of the Open Web
    Application Security Project, also known as OWASP (https://www.owasp.org)

    Among the common vulnerabilities that you should be aware of, you’ll
    find these:
         Broken authentication
         Session fixation
         Cross-site scripting (XSS)
         Cross-site request forgery (CSRF)
         Injections
         Sensitive data exposure
         Lack of method access control
         Using dependencies with known vulnerabilities

!!! Vulnerabilities in authentication and authorization
        Authentication represents the process in which an application identifies someone trying to use it.
        When someone or something uses the app, we want to find their identity so that further access is granted
        or not. In real-world apps, you’ll also find cases in which access
        is anonymous, but in most cases, one can use data or do specific actions only when
        identified. Once we have the identity of the user, we can process the authorization.
        Authorization is the process of establishing if an authenticated caller has the privileges to use
        specific functionality and data. For example, in a mobile banking application, most of the authenticated
        users can transfer money but only from their account.

        For example, you could use Spring Security to define access to specific endpoints for an authenticated
        individual with a particular role

            Dan: see "1-5 vulnerabilities in auth and authorization.png"

    What is session fixation?
        Session fixation vulnerability is a more specific, high-severity weakness of a web application. If present,
        it permits an attacker to impersonate a valid user by reusing a previously generated session ID. This
        vulnerability can happen if, during the authentication
        process, the web application does not assign a unique session ID. This can potentially
        lead to the reuse of existing session IDs. Exploiting this vulnerability consists of obtaining a valid
        session ID and making the intended victim’s browser use it.

        if the application provides the session ID in the URL, then the victim could be tricked into clicking
        on a malicious link.
        If the application uses a hidden attribute, the attacker can fool the victim into using a
        foreign form and then post the action to the server. If the application stores the value
        of the session in a cookie, then the attacker can inject a script and force the victim’s
        browser to execute it.

    What is cross-site scripting (XSS)?
        Cross-site scripting, also referred to as XSS, allows the injection of client-side scripts into
        web services exposed by the server, thereby permitting other users to run these.
        Before being used or even stored, you should properly “sanitize” the request to avoid
        undesired executions of foreign scripts. The potential impact can relate to account
        impersonation (combined with session fixation) or to participation in distributed
        attacks like DDoS.

    What is cross-site request forgery (CSRF)?
        Cross-site request forgery (CSRF) vulnerabilities are also common in web applications.
        CSRF attacks assume that a URL that calls an action on a specific server can be
        extracted and reused from outside the application (figure 1.8). If the server trusts the
        execution without doing any check on the origin of the request, one could execute it
        from any other place

    Dealing with the exposure of sensitive data
        Well, we’ll deal with credentials and private keys in the examples in this book. We might use secrets
        in configuration files, but we’ll place a note for these cases to remind you that you should store
        sensitive data in vaults. Naturally, for a developed system, the developers aren’t allowed to see the
        values for these sensitive keys in all of the environments. Usually, at least for production,
        only a small group of people should be allowed to access private data.

        Never log something that isn’t public information. By public, I mean
        that anyone can see or access the info. Things like private keys or certificates
        aren’t public and shouldn’t be logged together with your error, warning, or
        info messages.

!!! What is the lack of method access control?
        Even at the application level, you don’t apply authorization to only one of the tiers.
        Sometimes, it’s a must to ensure that a particular use case can’t be called at all (for
        example, if the privileges of the currently authenticated user don’t allow it).
!!!     Say you have a web application with a straightforward design. The app has a controller exposing
        endpoints. The controller directly calls a service that implements some
        logic and that uses persisted data managed through a repository (figure 1.9). Imagine
        a situation where the authorization is done only at the endpoint level (assuming that
        you can access the method through a REST endpoint). A developer might be tempted
        to apply authorization rules only in the controller layer

            Dan: check "1-9 lack of method access control.png"

        While the case presented in figure 1.9 works correctly, applying the authorization
        rules only at the controller layer can leave room for error. In this case, some future
        implementation could expose that use case without testing or without testing all the
        authorization requirements. In figure 1.10, you can see what can happen if a developer adds another
        functionality that depends on the same repository.

    Fortunately, with Spring Security, this capability is available out of the box. CSRF protection as well as
    validation of the origin CORS is enabled by default. You’ll have to disable it if you don’t want it explicitly.


    Understanding the OAuth 2 flow
!!!!    We’ll discuss this topic in detail in chapters 12 through 15. We certainly want to find a
        solution to avoid resending credentials for each of the requests to the backend and
        store these on the client side. The OAuth 2 flow offers a better way to implement
        authentication and authorization in these cases.

!!!!    The OAuth 2 framework defines two separate entities: the authorization server and
        the resource server. The purpose of the authorization server is to authorize the user
        and provide them with a token that specifies, among other things, a set of privileges
        that they can use. The part of the backend implementing this functionality is called
        the resource server. The endpoints that can be called are considered protected resources.
        Based on the obtained token, and after accomplishing authorization, a call on a
        resource is permitted or rejected.

!!!!    Step by step, the following happens:
            1 The user accesses a use case in the application (also known as the client). The
            application needs to call a resource in the backend.
            2 To be able to call the resource, the application first has to obtain an access
            token, so it calls the authorization server to get the token. In the request, it
            sends the user credentials or a refresh token, in some cases.
            3 If the credentials or the refresh token are correct, the authorization server
            returns a (new) access token to the client.
            4 The header of the request to the resource server uses the access token when
            calling the needed resources.

        Dan: check "1-13 OAuth2 flow .png"

!!!!!   A token is like an access card you use inside an office building. As a visitor, you first
        visit the front desk, where you receive an access card after identifying yourself.
        The access card can open some of the doors, but not necessarily all. Based on your identity,
        you can access precisely the doors that you’re allowed to and no more. The same happens with an access
        token. After authentication, the caller is provided with a token,
        and based on that, they can access the resources for which they have privileges

        A token has a fixed lifetime, usually being short-lived. When a token expires, the
        app needs to obtain a new one. If needed, the server can disqualify the token earlier
        than its expiration time. The following lists some of the advantages of this flow:
             The client doesn’t have to store the user credentials. The access token and,
            eventually, the refresh token are the only access details you need to save.
             The application doesn’t expose the user credentials, which are often on the
            network.
             If someone intercepts a token, you can disqualify the token without needing to
            invalidate the user credentials.
             A token can be used by a third entity to access resources on the user’s behalf,
            without having to impersonate the user. Of course, an attacker can steal the
            token in this case. But because the token usually has a limited lifespan, the timeframe in which
            one can use this vulnerability is limited.


========================================================================================================================
Chapter 2. Hello Spring Security

    Starting with the first project
        You’ll see how, without doing much, Spring Security secures this endpoint using HTTP Basic authentication.
        Just by creating the project and adding the correct dependencies, Spring Boot applies default
        configurations, including a username and a password when you start the application

        Once you run the application, besides the other lines in the console, you
        should see something that looks similar to this:
            Using generated security password: 93a01cf0-794b-4b98-86ef-54860f36f7f3
        Each time you run the application, it generates a new password and prints this password in the console
        as presented in the previous code snippet. You must use this password to call any of the application’s
        endpoints with HTTP Basic authentication

!!!     The response status is HTTP 401 Unauthorized. We expected this result as we didn’t
        use the proper credentials for authentication. By default, Spring Security expects the
        default username (user) with the provided password (in my case, the one starting with
        93a01). Let’s try it again but now with the proper credentials:
            curl -u user:93a01cf0-794b-4b98-86ef-54860f36f7f3 http://localhost:8080/hello
        The response to the call now is:
            Hello!

!!!     With cURL, you can set the HTTP basic username and password with the -u flag.
        Behind the scenes, cURL encodes the string <username>:<password> in Base64
        and sends it as the value of the Authorization header prefixed with the string
        Basic. And with cURL, it’s probably easier for you to use the -u flag. But it’s also
        essential to know what the real request looks like. So, let’s give it a try and manually
        create the Authorization header.

!!!     In the first step, take the <username>:<password> string and encode it with
        Base64. When our application makes the call, we need to know how to form the
        correct value for the Authorization header. You do this using the Base64 tool in
        a Linux console. You could also find a web page that encodes strings in Base64, like
        https://www.base64encode.org. This snippet shows the command in a Linux or a Git Bash console:
            echo -n user:93a01cf0-794b-4b98-86ef-54860f36f7f3 | base64

!!!     You can now use the Base64-encoded value as the value of the Authorization
        header for the call. This call should generate the same result as the one using the
        -u option:
           curl -H "Authorization: Basic dXNlcjo3NGQ4MTE5NS1lOWM5LTRlZjctYWM0Ny0wYWVmN2Q2M2ZkZGI=" http://localhost:8080/hello

!!!        Dan : check "2-2 main components in Spring Security"

         In figure 2.2, you can see that
             The authentication filter delegates the authentication request to the authentication manager and, based on the response, configures the security context.
             The authentication manager uses the authentication provider to process
            authentication.
             The authentication provider implements the authentication logic.
             The user details service implements user management responsibility, which the
            authentication provider uses in the authentication logic.
             The password encoder implements password management, which the authentication provider uses in the authentication logic.
             The security context keeps the authentication data after the authentication
            process.

!!!     An object that implements a UserDetailsService contract with Spring Security
        manages the details about users. Until now, we used the default implementation provided by Spring Boot.
        This implementation only registers the default credentials in
        the internal memory of the application. These default credentials are “user” with a
        default password that’s a universally unique identifier (UUID). This password is randomly generated when the Spring
        context is loaded. At this time, the application
        writes the password to the console where you can see it. Thus, you can use it in the
        example we just worked on in this chapter.
        This default implementation serves only as a proof of concept and allows us to see
        that the dependency is in place. The implementation stores the credentials in
        memory—the application doesn’t persist the credentials. This approach is suitable
        for examples or proof of concepts, but you should avoid it in a production-ready
        application.

         And then we have the PasswordEncoder. The PasswordEncoder does two
        things:
             Encodes a password
             Verifies if the password matches an existing encoding
        Even if it’s not as obvious as the UserDetailsService object, the PasswordEncoder is mandatory for the Basic
        authentication flow. The simplest implementation manages the passwords in plain text and doesn’t encode these
        When we replace the default implementation of the UserDetailsService, we must also specify a PasswordEncoder.

        Basic authentication only requires the client to send a username and a password through the HTTP Authorization
        header. In the value of the header, the client attaches the prefix Basic, followed by the Base64 encoding of the
        string that contains the username and password, separated by a colon (:).
        NOTE HTTP Basic authentication doesn’t offer confidentiality of the credentials. Base64 is only an encoding
        method for the convenience of the transfer; it’s not an encryption or hashing method. While in transit, if
        intercepted, anyone can see the credentials. Generally, we don’t use HTTP Basic authentication without at least
        HTTPS for confidentiality.

!!!!!   With Spring Boot, you can easily enable HTTPS at the application level, as you’ll learn in the next example
        in this sidebar. In any of these configuration scenarios, you need a certificate signed by a certification
        authority (CA). Using this certificate, the client that calls the endpoint knows whether the response comes from
        the authentication server and that nobody intercepted the communication. You can buy such a certificate, but you have to renew
        it. If you only need to configure HTTPS to test your application, you can generate a
        self-signed certificate using a tool like OpenSSL. Let’s generate our self-signed certificate and then configure
        it in the project:
            openssl req -newkey rsa:2048 -x509 -keyout key.pem -out cert.pem -days 365

        After running the openssl command in a terminal, you’ll be asked for a password
        and details about your CA. Because it is only a self-signed certificate for a test, you
        can input any data there; just make sure to remember the password. The command
        outputs two files: key.pem (the private key) and cert.pem (a public certificate). We’ll
        use these files further to generate our self-signed certificate for enabling HTTPS. In
        most cases, the certificate is the Public Key Cryptography Standards #12 (PKCS12).
        Less frequently, we use a Java KeyStore (JKS) format. Let’s continue our example
        with a PKCS12 format.
            openssl pkcs12 -export -in cert.pem -inkey key.pem -out certificate.p12 -name "certificate"

        The second command we use receives as input the two files generated by the first
        command and outputs the self-signed certificate.

        Finally, having the self-signed certificate, you can configure HTTPS for your endpoints.
        Copy the certificate.p12 file into the resources folder of the Spring Boot project and
        add the following lines to your application.properties file:
            server.ssl.key-store-type=PKCS12
            server.ssl.key-store=classpath:certificate.p12
            server.ssl.key-store-password=12345
        The password (in my case, “12345”) was requested in the prompt after running the
        command for generating the certificate. The value of the password is the
        one you specified when running the second command to generate the PKCS12 certificate file.

!!!!    If you use a self-signed certificate, you should configure the tool you use to make the
        endpoint call so that it skips testing the authenticity of the certificate. If the tool tests
        the authenticity of the certificate, it won’t recognize it as being authentic, and the call
        won’t work. With cURL, you can use the -k option to skip testing the authenticity of
        the certificate:
            curl -k -H "Authorization: Basic dXNlcjplNzFmMTUzMS0yYTUxLTQ4YWItYjEyMy02NGZlMWJmNzgyZjQ=" https://localhost:8080/hello

        Dan: i managed to add the certificate file in Postman as well, and use https
            https://stackoverflow.com/questions/27501819/how-to-add-a-client-side-pkcs12-certificate-to-postman-chrome-w7

!!!!    Remember that even if you use HTTPS, the communication between components of
        your system isn’t bulletproof. Many times, I’ve heard people say, “I’m not encrypting
        this anymore, I use HTTPS!” While helpful in protecting communication, HTTPS is just
        one of the bricks of the security wall of a system. Always treat the security of your
        system with responsibility and take care of all the layers involved in it.

     Overriding default configurations
        The implementations we use in this chapter are all provided by Spring Security

        Overriding the UserDetailsService component
            In this example, we use the InMemoryUserDetailsManager implementation.
            Even if this implementation is a bit more than just a UserDetailsService, for now,
            we only refer to it from the perspective of a UserDetailsService. This implementation stores credentials
            in memory, which can then be used by Spring Security to authenticate a request
            An InMemoryUserDetailsManager implementation isn’t meant for
            production-ready applications, but it’s an excellent tool for examples or
            proof of concepts.

            The application now uses the instance of type UserDetailsService you added
            to the context instead of the default autoconfigured one. But, at the same time, you
            won’t be able to access the endpoint anymore for two reasons:
                 You don’t have any users.
                 You don’t have a PasswordEncoder.
            In figure 2.2, you can see that authentication depends on a PasswordEncoder as
            well. Let’s solve these two issues step by step. We need to
                1 Create at least one user who has a set of credentials (username and password)
                2 Add the user to be managed by our implementation of UserDetailsService
                3 Define a bean of the type PasswordEncoder that our application can use to
                verify a given password with the one stored and managed by UserDetailsService

            When building the instance, we have to provide the username, the password, and
            at least one authority. The authority is an action allowed for that user, and we can use
            any string for this. In listing 2.4, I name the authority read, but because we won’t use
            this authority for the moment, this name doesn’t really matter

            The NoOpPasswordEncoder instance treats passwords as plain text. It
            doesn’t encrypt or hash them. For matching, NoOpPasswordEncoder only
            compares the strings using the underlying equals(Object o) method of
            the String class. You shouldn’t use this type of PasswordEncoder in a production-ready app.
            NoOpPasswordEncoder is a good option for examples
            where you don’t want to focus on the hashing algorithm of the password.
            Therefore, the developers of the class marked it as @Deprecated, and your
            development environment will show its name with a strikethrough.

         Overriding the endpoint authorization configuration
            With default configuration, all the endpoints
            assume you have a valid user managed by the application. Also, by default, your app
            uses HTTP Basic authentication as the authorization method, but you can easily override this configuration.

            As you’ll learn in the next chapters, HTTP Basic authentication doesn’t fit into
            most application architectures. Sometimes we’d like to change it to match our application. Similarly, not
            all endpoints of an application need to be secured, and for those
            that do, we might need to choose different authorization rules. To make such
            changes, we start by extending the WebSecurityConfigurerAdapter class. Extending this class allows us to
            override the configure(HttpSecurity http) method as presented in the next listing

            Dan: WebSecurityConfigurerAdapter was removed since the book was written...there is another way of doinf that config

        Overriding the AuthenticationProvider implementation
            As you can see, here the condition of the if-else clause is replacing the responsibilities of
            UserDetailsService and PasswordEncoder. Your are not required to use
            the two beans, but if you work with users and passwords for authentication, I strongly
            suggest you separate the logic of their management

        Using multiple configuration classes in your project
            In a production-ready application, you probably have more declarations
            than in our first examples. You also might find it useful to have more than one configuration class to make
            the project readable.
            It’s always a good practice to have only one class per each responsibility. For this
            example, we can separate user management configuration from authorization configuration. We do that by
            defining two configuration classes: UserManagementConfig (defined in listing 2.17) and WebAuthorizationConfig


========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================
PART II Implementation



========================================================================================================================
Chapter 3.  Managing users

    This chapter is about understanding in detail one of the fundamental roles you
    encountered in the first example we worked on in chapter 2—the UserDetailsService. Along with the UserDetailsService,
    we’ll discuss
         UserDetails, which describes the user for Spring Security.
         GrantedAuthority, which allows us to define actions that the user can execute.
         UserDetailsManager, which extends the UserDetailsService contract.
        Beyond the inherited behavior, it also describes actions like creating a user and
        modifying or deleting a user’s password.

!!! From chapter 2, you already have an idea of the roles of the UserDetailsService
    and the PasswordEncoder in the authentication process. But we only discussed how
    to plug in an instance defined by you instead of using the default one configured by Spring Boot
    We have more details to discuss:
         What implementations are provided by Spring Security and how to use them
         How to define a custom implementation for contracts and when to do so
         Ways to implement interfaces that you find in real-world applications
         Best practices for using these interfaces

    Figure 3.1 presents the authentication flow in Spring Security. This architecture is
    the backbone of the authentication process as implemented by Spring Security. It’s
    really important to understand it because you’ll rely on it in any Spring Security
    implementation. You’ll observe that we discuss parts of this architecture in almost all
    the chapters of this book. You’ll see it so often that you’ll probably learn it by heart,
    which is good. If you know this architecture, you’re like a chef who knows their ingredients and can put
    together any recipe
!!!!    Dan: check "2-2 main components in Spring Security.png"

!!! As part of user management, we use the UserDetailsService and UserDetailsManager interfaces.
    The UserDetailsService is only responsible for retrieving the user by username. This action is the
    only one needed by the framework to complete authentication.
    The UserDetailsManager adds behavior that refers to adding, modifying, or deleting the user, which is a
    required functionality in most applications
!!!!The separation between the two contracts is an excellent example of the interface segregation
    principle. Separating the interfaces allows for better flexibility because the framework
    doesn’t force you to implement behavior if your app doesn’t need it. If the app only
    needs to authenticate the users, then implementing the UserDetailsService contract is enough to cover the
    desired functionality. To manage the users, UserDetailsService and the UserDetailsManager components need
    a way to represent them.

    Spring Security offers the UserDetails contract, which you have to implement to
    describe a user in the way the framework understands. As you’ll learn in this chapter, in
    Spring Security a user has a set of privileges, which are the actions the user is allowed
    to do. But for now, Spring Security represents the actions that a user can do with the
    GrantedAuthority interface. We often call these authorities, and a user has one or
    more authorities. In figure 3.2, you find a representation of the relationship between
    the components of the user management part of the authentication flow
        Dan see "3-2 userdetails and granted authorithy.png"

    Describing the user
        In this section, you’ll learn how to describe the users of your application such that
        Spring Security understands them

!!!!    For Spring Security, a user definition should respect the UserDetails contract.
        The UserDetails contract represents the user as understood by Spring Security. The
        class of your application that describes the user has to implement this interface, and
        in this way, the framework understands it.

        If you choose to implement these user restrictions in your application’s logic, you
        need to override the following methods: isAccountNonExpired(), isAccountNonLocked(),
        isCredentialsNonExpired(), isEnabled(), such that those
        needing to be enabled return true. Not all applications have accounts that expire or
        get locked with certain conditions. If you do not need to implement these functionalities in your
        application, you can simply make these four methods return true.

!!      The authorities represent what the user can do in your application. Without
        authorities, all users would be equal. While there are simple applications in which the
        users are equal, in most practical scenarios, an application defines multiple kinds of
        users. An application might have users that can only read specific information, while
        others also can modify the data. And you need to make your application differentiate
        between them, depending on the functional requirements of the application, which
        are the authorities a user needs. To describe the authorities in Spring Security, you use
        the GrantedAuthority interface

        To create an authority, you only need to find a name for that privilege so you can refer
        to it later when writing the authorization rules. For example, a user can read the
        records managed by the application or delete them. You write the authorization rules
        based on the names you give to these actions.

        In this chapter, we’ll implement the getAuthority() method to return the
!!!!    authority’s name as a String. The GrantedAuthority interface has only one
        abstract method, and in this book, you often find examples in which we use a lambda
        expression for its implementation. Another possibility is to use the SimpleGrantedAuthority class
        to create authority instances.
        Here we make use of a lambda expression and then use the SimpleGrantedAuthority class:
            GrantedAuthority g1 = () -> "READ";
            GrantedAuthority g2 = new SimpleGrantedAuthority("READ");

!!!!!!  It is good practice to verify that the interface is marked as functional
        with the @FunctionalInterface annotation before implementing it with
        lambda expressions. The reason for this practice is that if the interface is not
        marked as functional, it can mean that its developers reserve the right to add
        more abstract methods to it in future versions. In Spring Security, the
        GrantedAuthority interface is not marked as functional. However, we’ll
        use lambda expressions in this book to implement that interface to make the
        code shorter and easier to read, even if it’s not something I recommend you
        do in a real-world project.

        Some applications are simple and don’t need a custom implementation of the UserDetails interface.
        In this section, we take a look at using a builder class provided by
        Spring Security to create simple user instances. Instead of declaring one more class in
        your application, you quickly obtain an instance representing your user with the User
        builder class.
        The User class from the org.springframework.security.core.userdetails package is
        a simple way to build instances of the UserDetails type. Using this class, you can create immutable
        instances of UserDetails

            UserDetails u = User.withUsername("bill")
                 .password("12345")
                 .authorities("read", "write")
                 .accountExpired(false)
                 .disabled(true)
                 .build();

        In most cases, you find multiple
        responsibilities to which a user relates. And if you store users in a database, and then
        in the application, you would need a class to represent the persistence entity as well.
        Or, if you retrieve users through a web service from another system, then you would
        probably need a data transfer object to represent the user instances. Assuming the
        first, a simple but also typical case, let’s consider we have a table in an SQL database in
        which we store the users. To make the example shorter, we give each user only one
        authority. The following listing shows the entity class that maps the table.

!!!!    How can we write this code to be cleaner? The root of the muddy aspect of the previous code example
        is a mix of two responsibilities. While it’s true that you need both
        in the application, in this case, nobody says that you have to put these into the same
        class. Let’s try to separate those by defining a separate class called SecurityUser,
        which decorates the User class. As listing 3.10 shows, the SecurityUser class implements the
        UserDetails contract and uses that to plug our user into the Spring Security architecture. The User
        class has only its JPA entity responsibility remaining.

        As you can observe, we use the SecurityUser class only to map the user details in the
        system to the UserDetails contract understood by Spring Security. To mark the fact
        that the SecurityUser makes no sense without a User entity, we make the field final.
        You have to provide the user through the constructor. The SecurityUser class decorates the User
        entity class and adds the needed code related to the Spring Security contract without mixing the
        code into a JPA entity, thereby implementing multiple different tasks

    Instructing Spring Security on how to manage users
        The UserDetailsService interface contains only one method, as follows:
            public interface UserDetailsService {
                UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
            }

!!!     The authentication implementation calls the loadUserByUsername(String username) method to obtain the
        details of a user with a given username (figure 3.3). The
        username is, of course, considered unique. The user returned by this method is an
        implementation of the UserDetails contract. If the username doesn’t exist, the
        method throws a UsernameNotFoundException.

            Dan: see "3-3 UserDetailsService loadUserByUsername.png"

        In this section, we work on a practical example to demonstrate the implementation of
        the UserDetailsService. Your application manages details about credentials and
        other user aspects. It could be that these are stored in a database or handled by
        another system that you access through a web service or by other means (figure 3.3).
        Regardless of how this happens in your system, the only thing Spring Security needs
        from you is an implementation to retrieve the user by username.

!!!     In this section, we discuss using and implementing the UserDetailsManager interface. This interface
        extends and adds more methods to the UserDetailsService
        contract. Spring Security needs the UserDetailsService contract to do the authentication. But
        generally, in applications, there is also a need for managing users. Most
        of the time, an app should be able to add new users or delete existing ones. In this
        case, we implement a more particular interface defined by Spring Security, the UserDetailsManager. It
        extends UserDetailsService and adds more operations that we need to implement.

!!!!!   Beside the InMemoryUserDetailsManager, we often use another UserDetailManager, the
        JdbcUserDetailsManager. The JdbcUserDetailsManager manages users in an SQL database. It connects to
        the database directly through JDBC. This way, the JdbcUserDetailsManager is independent of any
        other framework or specification related to database connectivity

            Dan: see "3-4 JdbcUserDetailsManager.png"

        But the easiest would be to let Spring Boot itself run the scripts for you. To do
        this, just add two more files to your project in the resources folder: schema.sql and
        data.sql. In the schema.sql file, you add the queries related to the structure of the
        database, like creating, altering, or dropping tables. In the data.sql file, you add the
        queries that work with the data inside the tables, like INSERT, UPDATE, or DELETE.
        Spring Boot automatically runs these files for you when you start the application. A
        simpler solution for building examples that need databases is using an H2 in-memory
        database. This way, you don’t need to install a separate DBMS solution.

        The JdbcUserDetailsManager also allows you to configure the queries used. In the
        previous example, we made sure we used the exact names for the tables and columns,
        as the JdbcUserDetailsManager implementation expects those. But it could be
        that for your application, these names are not the best choice. The next listing shows
        how to override the queries for the JdbcUserDetailsManager.

!!!!    The JdbcUserDetailsManager has the advantage of directly using JDBC and
        does not lock the application in to other frameworks.


========================================================================================================================
Chapter 4. Dealing with passwords

    Because, in general, a system doesn’t manage passwords in plain text, these usually
    undergo a sort of transformation that makes it more challenging to read and steal
    them. For this responsibility, Spring Security defines a separate contract. To explain it
    easily in this section, I provide plenty of code examples related to the PasswordEncoder implementation.
    We’ll start with understanding the contract, and then we’ll
    write our implementation within a project. Then in section 4.1.3, I’ll provide you with
    a list of the most well-known and widely used implementations of the PasswordEncoder provided by Spring Security

    The definition of the PasswordEncoder contract
        You implement this contract to tell Spring Security how to validate a user’s password. In
        the authentication process, the PasswordEncoder decides if a password is valid or not

        Every system stores passwords encoded in some way. You preferably store them
        hashed so that there’s no chance someone can read the passwords. The PasswordEncoder can also encode
        passwords. The methods encode() and matches(), which
        the contract declares, are actually the definition of its responsibility. Both of these are
        parts of the same contract because these are strongly linked, one to the other. The way
        the application encodes a password is related to the way the password is validated.

!!!!    The purpose of the encode(CharSequence rawPassword) method is to return
        a transformation of a provided string. In terms of Spring Security functionality, it’s
        used to provide encryption or a hash for a given password. You can use the
        matches(CharSequence rawPassword, String encodedPassword) method
        afterward to check if an encoded string matches a raw password. You use the
        matches() method in the authentication process to test a provided password against
        a set of known credentials.

        While knowing how to implement your PasswordEncoder is powerful, you also have
        to be aware that Spring Security already provides you with some advantageous implementations. If one of
        these matches your application, you don’t need to rewrite it. In
        this section, we discuss the PasswordEncoder implementation options that Spring Security provides. These are
             NoOpPasswordEncoder—Doesn’t encode the password but keeps it in cleartext. We use this implementation
            only for examples. Because it doesn’t hash the password, you should never use it in a real-world scenario.
             StandardPasswordEncoder—Uses SHA-256 to hash the password. This
            implementation is now deprecated, and you shouldn’t use it for your new implementations. The reason why
            it’s deprecated is that it uses a hashing algorithm that we don’t consider strong enough anymore, but you
            might still find this implementation used in existing applications.
             Pbkdf2PasswordEncoder—Uses the password-based key derivation function 2 (PBKDF2).
             BCryptPasswordEncoder—Uses a bcrypt strong hashing function to encode the password.
             SCryptPasswordEncoder—Uses a scrypt hashing function to encode the password.

!!!     Another option offered by Spring Security is the Pbkdf2PasswordEncoder implementation that uses the PBKDF2
        for password encoding. To create instances of the Pbkdf2PasswordEncoder, you have the following options:
            PasswordEncoder p = new Pbkdf2PasswordEncoder();
            PasswordEncoder p = new Pbkdf2PasswordEncoder("secret");
            PasswordEncoder p = new Pbkdf2PasswordEncoder("secret", 185000, 256);
        The PBKDF2 is a pretty easy, slow-hashing function that performs an HMAC as many
        times as specified by an iterations argument. The three parameters received by the last
        call are the value of a key used for the encoding process, the number of iterations
        used to encode the password, and the size of the hash. The second and third parameters can influence the
        strength of the result. You can choose more or fewer iterations, as well as the length of the result. The
        longer the hash, the more powerful the password. However, be aware that performance is affected by these
        values: the more iterations, the more resources your application consumes. You should make a wise
        compromise between the resources consumed for generating the hash and the
        needed strength of the encoding

        Another excellent option offered by Spring Security is the BCryptPasswordEncoder, which uses a bcrypt
        strong hashing function to encode the password. You can instantiate the BCryptPasswordEncoder by calling
        the no-arguments constructor. But you also have the option to specify a strength coefficient representing the log
        rounds (logarithmic rounds) used in the encoding process.

        The last option I present to you is SCryptPasswordEncoder (figure 4.2). This
        password encoder uses an scrypt hashing function. For the ScryptPasswordEncoder, you have two options to create
        its instances:
            PasswordEncoder p = new SCryptPasswordEncoder();
            PasswordEncoder p = new SCryptPasswordEncoder(16384, 8, 1, 32, 64);
        The values in the previous examples are the ones used if you create the instance by
        calling the no-arguments constructor.

        In some applications, you might find it useful to have various password encoders
        and choose from these depending on some specific configuration. A common scenario in which I find the
        DelegatingPasswordEncoder in production applications
        is when the encoding algorithm is changed, starting with a particular version of the
        application. Imagine somebody finds a vulnerability in the currently used algorithm,
        and you want to change it for newly registered users, but you do not want to change it
        for existing credentials. So you end up having multiple kinds of hashes. How do you
        manage this case? While it isn’t the only approach for this scenario, a good choice is to
        use a DelegatingPasswordEncoder object.

!!!!    The DelegatingPasswordEncoder is an implementation of the PasswordEncoder interface that, instead of
        implementing its encoding algorithm, delegates to another instance of an implementation of the same contract.
        The hash starts with a prefix naming the algorithm used to define that hash. The DelegatingPasswordEncoder
        delegates to the correct implementation of the PasswordEncoder based on the prefix of the password

         It sounds complicated, but with an example, you can observe that it is pretty easy.
        Figure 4.3 presents the relationship among the PasswordEncoder instances. The
        DelegatingPasswordEncoder has a list of PasswordEncoder implementations to
        which it delegates. The DelegatingPasswordEncoder stores each of the instances
        in a map. The NoOpPasswordEncoder is assigned to the key noop, while the
        BCryptPasswordEncoder implementation is assigned the key bcrypt. When the
        password has the prefix {noop}, the DelegatingPasswordEncoder delegates the
        operation to the NoOpPasswordEncoder implementation. If the prefix is {bcrypt},
        then the action is delegated to the BCryptPasswordEncoder

        For convenience, Spring Security offers a way to create a DelegatingPasswordEncoder that has a map to all
        the standard provided implementations of PasswordEncoder. The PasswordEncoderFactories class provides a
        createDelegatingPasswordEncoder() static method that returns the implementation of the
        DelegatingPasswordEncoder with bcrypt as a default encoder:
        PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!             Dan: below is such a simple awesome explanation
        Encoding vs. encrypting vs. hashing
        In the previous sections, I often used the terms encoding, encrypting, and hashing. I
        want to briefly clarify these terms and the way we use them throughout the book.
        Encoding refers to any transformation of a given input. For example, if we have a function x that reverses
        a string, function x -> y applied to ABCD produces DCBA.
        Encryption is a particular type of encoding where, to obtain the output, you provide
        both the input value and a key. The key makes it possible for choosing afterward who
        should be able to reverse the function (obtain the input from the output). The simplest form of representing
        encryption as a function looks like this:
            (x, k) -> y
        where x is the input, k is the key, and y is the result of the encryption. This way, an
        individual knows the key can use a known function to obtain the input from the output
        (y, k) -> x. We call this reverse function decryption. If the key used for encryption
        is the same as the one used for decryption, we usually call it a symmetric key.
        If we have two different keys for encryption ((x, k1) -> y) and decryption ((y, k2) -> x)
        then we say that the encryption is done with asymmetric keys. Then (k1, k2)
        is called a key pair. The key used for encryption, k1, is also referred to as the
        public key, while k2 is known as the private one. This way, only the owner of the private key can decrypt the data.
        Hashing is a particular type of encoding, except the function is only one way. That is,
        from an output y of the hashing function, you cannot get back the input x. However,
        there should always be a way to check if an output y corresponds to an input x, so
        we can understand the hashing as a pair of functions for encoding and matching. If
        hashing is x -> y, then we should also have a matching function (x,y) -> boolean.
        Sometimes the hashing function could also use a random value added to the input:
        (x, k) -> y. We refer to this value as the salt. The salt makes the function stronger, enforcing the difficulty
        of applying a reverse function to obtain the input from the result.
!!!!!!!!!!!!!!!!!!!!!!!!!!

     More about the Spring Security Crypto module   SSCM
        In this section, we discuss what
        other options the SSCM offers that are related to cryptography. You’ll see examples of
        how to use two essential features from the SSCM:
             Key generators—Objects used to generate keys for hashing and encryption algorithms
             Encryptors—Objects used to encrypt and decrypt data

!!!     A key generator is an object used to generate a
        specific kind of key, generally needed for an encryption or hashing algorithm. The
        implementations of key generators that Spring Security offers are great utility tools.
        You’ll prefer to use these implementations rather than adding another dependency
        for your application, and this is why I recommend that you become aware of them.

        Two interfaces represent the two main types of key generators: BytesKeyGenerator and StringKeyGenerator.
        We can build them directly by making use of
        the factory class KeyGenerators. You can use a string key generator, represented by
        the StringKeyGenerator contract, to obtain a key as a string. Usually, we use this
        key as a salt value for a hashing or encryption algorithm

        In some cases, we prefer an implementation that returns the same key value for each
        call of the same key generator. In this case, we can create a BytesKeyGenerator with
        the KeyGenerators.shared(int length) method. In this code snippet, key1 and
        key2 have the same value:
            BytesKeyGenerator keyGenerator = KeyGenerators.shared(16);
            byte [] key1 = keyGenerator.generateKey();
            byte [] key2 = keyGenerator.generateKey();

!!!!    An encryptor is an object that implements an encryption algorithm. When talking about security, encryption
        and decryption are common operations, so expect to need these within your application.
        We often need to encrypt data either when sending it between components of the
        system or when persisting it. The operations provided by an encryptor are encryption
        and decryption. There are two types of encryptors defined by the SSCM: BytesEncryptor and TextEncryptor


========================================================================================================================
Chapter 5. Implementing authentication

!!  The AuthenticationProvider layer, however, is the one responsible for the
    logic of authentication. The AuthenticationProvider is where you find the
    conditions and instructions that decide whether to authenticate a request or not. The
    component that delegates this responsibility to the AuthenticationProvider is the
    AuthenticationManager, which receives the request from the HTTP filter layer

    the authentication process, which has only two possible results:
         The entity making the request is not authenticated. The user is not recognized, and
        the application rejects the request without delegating to the authorization process. Usually, in this case,
        the response status sent back to the client is HTTP 401 Unauthorized.
         The entity making the request is authenticated. The details about the requester are
        stored such that the application can use these for authorization. As you’ll find
        out in this chapter, the SecurityContext interface is the instance that stores
        the details about the current authenticated request.

    Near the end of the chapter, you’ll learn how to customize the HTTP Basic authentication method. We’ll also
    discuss another option for authentication that we can use in our applications—the form-based login

    Understanding the AuthenticationProvider
        In enterprise applications, you might find yourself in a situation in which the default
        implementation of authentication based on username and password does not apply.
        Additionally, when it comes to authentication, your application may require the
        implementation of several scenarios. For example, you might want the
        user to be able to prove who they are by using a code received in an SMS message or
        displayed by a specific application. Or, you might need to implement authentication
        scenarios where the user has to provide a certain kind of key stored in a file. You
        might even need to use a representation of the user’s fingerprint to implement the
        authentication logic. A framework’s purpose is to be flexible enough to allow you to
        implement any of these required scenarios.

        In terms of Spring Security, you can use the AuthenticationProvider contract to define any custom
        authentication logic. In this section, you learn to represent the authentication event by implementing the
        Authentication interface and then creating your custom authentication logic with an AuthenticationProvider

        Representing the request during authentication
!!!!!       Authentication is one of the essential interfaces involved in the process with the
            same name. The Authentication interface represents the authentication request
            event and holds the details of the entity that requests access to the application. You
            can use the information related to the authentication request event during and after
            the authentication process. The user requesting access to the application is called a
            principal. If you’ve ever used the Java Security API in any app, you learned that in the
            Java Security API, an interface named Principal represents the same concept. The
            Authentication interface of Spring Security extends this contract

            Dan: see "5-3 authentication interface"

            For the moment, the only methods of Authentication contract that you need to learn are these:
                 isAuthenticated()—Returns true if the authentication process ends or false
                if the authentication process is still in progress.
                 getCredentials()—Returns a password or any secret used in the process of authentication.
                 getAuthorities()—Returns a collection of granted authorities for the
                authenticated request

        Implementing custom authentication logic
            The AuthenticationProvider responsibility is strongly coupled with the Authentication contract.
            The authenticate() method receives an Authentication
            object as a parameter and returns an Authentication object. We implement the
!!!         authenticate() method to define the authentication logic. We can quickly summarize the way you should
            implement the authenticate() method with three bullets:
                 The method should throw an AuthenticationException if the authentication fails.
                 If the method receives an authentication object that is not supported by your
                    implementation of AuthenticationProvider, then the method should
                    return null. This way, we have the possibility of using multiple Authentication
                    types separated at the HTTP-filter level. We’ll discuss this aspect more in chapter
                    9. You’ll also find an example having multiple AuthorizationProvider
                    classes in chapter 11, which is the second hands-on chapter of this book.
                 The method should return an Authentication instance representing a fully
                    authenticated object. For this instance, the isAuthenticated() method
                    returns true, and it contains all the necessary details about the authenticated
                    entity. Usually, the application also removes sensitive data like a password from
                    this instance. After implementation, the password is no longer required and
                    keeping these details can potentially expose them to unwanted eyes.

            The second method in the AuthenticationProvider interface is supports-
            (Class<?> authentication). You can implement this method to return true if the
            current AuthenticationProvider supports the type provided as an Authentication object. Observe that even
            if this method returns true for an object, there is still a
            chance that the authenticate() method rejects the request by returning null.
            Spring Security is designed like this to be more flexible and to allow you to implement
            an AuthenticationProvider that can reject an authentication request based on
            the request’s details, not only by its type.

             An analogy of how the authentication manager and authentication provider work
            together to validate or invalidate an authentication request is having a more complex
            lock for your door. You can open this lock either by using a card or an old fashioned
            physical key (figure 5.4). The lock itself is the authentication manager that decides
            whether to open the door. To make that decision, it delegates to the two authentication
            providers: one that knows how to validate the card or the other that knows how to verify
            the physical key. If you present a card to open the door, the authentication provider that
            works only with physical keys complains that it doesn’t know this kind of authentication.
            But the other provider supports this kind of authentication and verifies whether the
            card is valid for the door. This is actually the purpose of the supports() methods.

                Dan: see "5-4 authentication manager and multiple authentication providers.png"

            That’s it! You successfully customized the implementation of the AuthenticationProvider. You can now
            customize the authentication logic for your application where you need it
                Dan: see chapter5 ex1

            When deciding to use a framework, make sure you understand, at least, its
            basics well.
                – Be mindful of the resources you use to learn about the framework. Sometimes, articles you find on
                the web show you how to do quick workarounds and not necessarily how to correctly implement a class design.
                – Use multiple sources in your research. To clarify your misunderstandings,
                write a proof of concept when unsure how to use something.

    Using the SecurityContext
        This section discusses the security context. We analyze how it works, how to access data
        from it, and how the application manages it in different thread-related scenarios.

!!!!    Once the AuthenticationManager completes
        the authentication process successfully, it stores the Authentication instance for the
        rest of the request. The instance storing the Authentication object is called the security context.

        Dan: see "5-6 SecurityContext flow.png"

!!!     The security context of Spring Security is described by the SecurityContext interface. The following listing
        defines this interface.
            public interface SecurityContext extends Serializable {
                Authentication getAuthentication();
                void setAuthentication(Authentication authentication);
            }

!!!!!   As you can observe from the contract definition, the primary responsibility of the
        SecurityContext is to store the Authentication object. But how is the
        SecurityContext itself managed? Spring Security offers three strategies to manage
        the SecurityContext with an object in the role of a manager. It’s named the
        SecurityContextHolder:
             MODE_THREADLOCAL—Allows each thread to store its own details in the security
                context. In a thread-per-request web application, this is a common approach as
                each request has an individual thread.
             MODE_INHERITABLETHREADLOCAL—Similar to MODE_THREADLOCAL but also
                instructs Spring Security to copy the security context to the next thread in case
                of an asynchronous method. This way, we can say that the new thread running
                the @Async method inherits the security context.
             MODE_GLOBAL—Makes all the threads of the application see the same security context instance.

        in this section, we also discuss what happens when you define your own
        threads that are not known by Spring. As you will learn, for these cases, you need to
        explicitly copy the details from the security context to the new thread. Spring Security
        cannot automatically manage objects that are not in Spring’s context, but it offers
        some great utility classes for this.

        Using a holding strategy for the security context
!!!!        The first strategy for managing the security context is the MODE_THREADLOCAL strategy.
            This strategy is also the default for managing the security context used by Spring Security. With this
            strategy, Spring Security uses ThreadLocal to manage the context.
            ThreadLocal is an implementation provided by the JDK. This implementation works
            as a collection of data but makes sure that each thread of the application can see only
            the data stored in the collection. This way, each request has access to its security context. No thread
            will have access to another’s ThreadLocal. And that means that in a
            web application, each request can see only its own security context. We could say that
            this is also what you generally want to have for a backend web application.

            Dan : see "5-7 SecurityContextHolder MODE_THREADLOCAL.png"

         Using a holding strategy for asynchronous calls
            The situation gets more complicated if we have to deal with multiple threads per
            request. Look at what happens if you make the endpoint asynchronous. The thread
            that executes the method is no longer the same thread that serves the request. Think
            about an endpoint like the one presented in the next listing

                @GetMapping("/bye")
                @Async
                public void goodbye() {
                 SecurityContext context = SecurityContextHolder.getContext();
                 String username = context.getAuthentication().getName();
                 // do something with the username
                }

            To enable the functionality of the @Async annotation, I have also created a configuration class and annotated
            it with @EnableAsync, as shown here:
                @Configuration
                @EnableAsync
                public class ProjectConfig {
                }

            If you try the code as it is now, it throws a NullPointerException on the line that
            gets the name from the authentication, which is
                String username = context.getAuthentication().getName()
            This is because the method executes now on another thread that does not inherit the
            security context. For this reason, the Authorization object is null and, in the context of the presented
!!!!!!      code, causes a NullPointerException. In this case, you could
            solve the problem by using the MODE_INHERITABLETHREADLOCAL strategy. This can
            be set either by calling the SecurityContextHolder.setStrategyName()
            method or by using the system property spring.security.strategy. By setting
            this strategy, the framework knows to copy the details of the original thread of the
            request to the newly created thread of the asynchronous method

        Using a holding strategy for standalone applications
            If what you need is a security context shared by all the threads of the application, you
            change the strategy to MODE_GLOBAL

            With MODE_GLOBAL used as the security context management
            strategy, all the threads access the same security context. This implies that these
            all have access to the same data and can change that information. Because of
            this, race conditions can occur, and you have to take care of synchronization.

!!!         Also, be aware that the SecurityContext is not thread safe. So, with this strategy
            where all the threads of the application can access the SecurityContext object, you
            need to take care of concurrent access.

        Forwarding the security context with DelegatingSecurityContextRunnable
!!!         what happens when your code starts new threads without the framework knowing about them? Sometimes
            we name these self-managed threads because it is we who manage them, not the framework. In this section,
            we apply some utility tools provided by Spring Security that help you propagate the security context to
            newly created threads.

            One solution for this is to use the DelegatingSecurityContextRunnable to
            decorate the tasks you want to execute on a separate thread. The DelegatingSecurityContextRunnable extends
            Runnable. You can use it following the execution of the task when there is no value expected. If you have a
            return value, then you can use the Callable<T> alternative, which is DelegatingSecurityContextCallable<T>.
            Both classes represent tasks executed asynchronously, as any other Runnable or Callable. Moreover, these
            make sure to copy the current security context for the thread that executes the task

            dan: see example 3 from chapter5

        Forwarding the security context with DelegatingSecurityContextExecutorService
            An alternative to decorating tasks is to use a particular type of Executor. In the
            next example, you can observe that the task remains a simple Callable<T>, but the
            thread still manages the security context. The propagation of the security context happens because an
            implementation called DelegatingSecurityContextExecutorService decorates the ExecutorService.
            The DelegatingSecurityContextExecutorService also takes care of the security context propagation,

            Dan: various other classes that are helpful when dealing with self managed threads are presented in this chapter.
                They seem to be too detailed for me to exercise practice them...But good to know that such Spring utility
                classes exist.

    Understanding HTTP Basic and form-based login authentications
        Up to now, we’ve only used HTTP Basic as the authentication method, but throughout this book, you’ll learn
        that there are other possibilities as well. The HTTP Basic
        authentication method is simple, which makes it an excellent choice for examples and
        demonstration purposes or proof of concept. But for the same reason, it might not fit
        all of the real-world scenarios that you’ll need to implement

        Using and configuring HTTP Basic
            You are aware that HTTP Basic is the default authentication method, and we have
            observed the way it works in various examples in chapter 3. In this section, we add
            more details regarding the configuration of this authentication method.

        Implementing authentication with form-based login
            When developing a web application, you would probably like to present a user friendly login form where
            the users can input their credentials. As well, you might like
            your authenticated users to be able to surf through the web pages after they logged in
            and to be able to log out. For a small web application, you can take advantage of the
            form-based login method. In this section, you learn to apply and configure this
            authentication method for your application. To achieve this, we write a small web
            application that uses form-based login

            Dan: see "5-12 form based login.png"

!!!!        You can log in using the default provided credentials as long as you do not register
            your UserDetailsService. These are, as we learned in chapter 2, username “user”
            and a UUID password that is printed in the console when the application starts. After
            a successful login, because there is no other page defined, you are redirected to a
            default error page.

            To add a simple page to the application, you first have to create an HTML file in the
            resources/static folder of the project. I call this file home.html. Inside it, type some
            text that you will be able to find afterward in the browser. You can just add a heading
            (for example, <h1>Welcome</h1>). After creating the HTML page, a controller
            needs to define the mapping from the path to the view. The following listing presents
            the definition of the action method for the home.html page in the controller class.

            The formLogin() method returns an object of type FormLoginConfigurer<HttpSecurity>, which allows
            us to work on customizations. For example, you can do this by calling the defaultSuccessUrl()method,

            If you need to go even more in depth with this, using the AuthenticationSuccessHandler and
            AuthenticationFailureHandler objects offers a more detailed customization approach

            Dan: If you want to logout, you can navigate to the /logout URL and click on the "Log out" button


========================================================================================================================
Chapter 6. Hands-on: A small secured web application

    It is advisable to have a many-to-many relationship between the authorities and the users. To keep the
    example simpler from the point of view of the
    persistence layer and focus on the essential aspects of Spring Security, I decided to make this one-to-many.

    I use here a Spring Data JPA repository. Then Spring Data implements the method
    declared in the interface and executes a query based on its name. The method
    returns an Optional instance containing the User entity with the name provided as a
    parameter. If no such user exists in the database, the method returns an empty
    Optional instance.


========================================================================================================================
Chapter 7. Configuring authorization: Restricting access

    Up to now, we’ve only discussed authentication, which is, as you learned, the
    process in which the application identifies the caller of a resource. In the examples
    we worked on in the previous chapters, we didn’t implement any rule to decide
    whether to approve a request. We only cared if the system knew the user or not.

!!!!In most applications, it doesn’t happen that all the users identified by the system can
    access every resource in the system. In this chapter, we’ll discuss authorization. Authorization is the process
    during which the system decides if an identified client has permission to access the requested resource

!!! Authorization always happens after authentication.

    In Spring Security, once the application ends the authentication flow, it delegates the
    request to an authorization filter. The filter allows or rejects the request based on the
    configured authorization rules

    To cover all the essential details on authorization, in this chapter we’ll follow these steps:
        1 Gain an understanding of what an authority is and apply access rules on all
        endpoints based on a user’s authorities.
        2 Learn how to group authorities in roles and how to apply authorization rules
        based on a user’s roles.

    Dan: see "7-1 AuthorizationFilter big picture.png"

    Restricting access based on authorities and roles
        Figure 7.3 presents the relationship between the UserDetails contract and the GrantedAuthority interface.
        Once we finish discussing this contract, you’ll learn how to use these rules individually
        or for specific requests.

        Dan: see "7-3 relationship between UserDetails and GrantedAuthority"

        An authority is an action that a user can perform with a system resource. An authority has a name that
        the getAuthority() behavior of the object returns as a String. We use the name of
        the authority when defining the custom authorization rule. Often an authorization
        rule can look like this: “Jane is allowed to delete the product records,” or “John is
        allowed to read the document records.” In these cases, delete and read are the granted
        authorities. The application allows the users Jane and John to perform these actions,
        which often have names like read, write, or delete.

        The authorizeRequests() method lets us continue with specifying authorization
        rules on endpoints. The anyRequest() method indicates that the rule applies to all
        the requests, regardless of the URL or HTTP method used. The permitAll()
        method allows access to all requests, authenticated or not.

        Restricting access for all endpoints based on user authorities

             http.authorizeRequests()
                            .anyRequest()
                            .hasAuthority("WRITE");
    !!!!    You can see that I replaced the permitAll() method with the hasAuthority()
            method. You provide the name of the authority allowed to the user as a parameter of
            the hasAuthority() method. The application needs, first, to authenticate the
            request and then, based on the user’s authorities, the app decides whether to allow
            the call.

            Dan: this access method is an alternative to the hasAuthority and hasAnyAuthority methods, but as you will see,
            it overs more flexibility in configuration

            However, the access() method has the advantage of allowing you to customize rules through the
            expression you provide as a parameter. And this is really powerful! As with SpEL
            expressions, you can basically define any condition.

            In listing 7.8, you find the access() method applied with an expression that’s not
            easy to write otherwise. Precisely, the configuration presented in listing 7.8 defines two
            users, John and Jane, who have different authorities. The user John has only read
            authority, while Jane has read, write, and delete authorities. The endpoint should be
            accessible to those users who have read authority but not to those that have delete
            authority.

        Restricting access for all endpoints based on user roles
            Roles are another way to refer to what a user can do (figure 7.5). You find these as well in real world
            applications, so this is why it is important to understand roles and the difference between roles and authorities.

            Spring Security understands authorities as fine-grained privileges on which we apply
            restrictions. Roles are like badges for users. These give a user privileges for a group of
            actions. Some applications always provide the same groups of authorities to specific
            users. Imagine, in your application, a user can either only have read authority or have
            all: read, write, and delete authorities. In this case, it might be more comfortable to
            think that those users who can only read have a role named READER, while the others
            have the role ADMIN. Having the ADMIN role means that the application grants you
            read, write, update, and delete privileges. You could potentially have more roles. For
            example, if at some point the requests specify that you also need a user who is only
            allowed to read and write, you can create a third role named MANAGER for your application.

!!!!!!      NOTE When using an approach with roles in the application, you won’t have
            to define authorities anymore. The authorities exist, in this case as a concept,
            and can appear in the implementation requirements. But in the application,
            you only have to define a role to cover one or more such actions a user is privileged to do.

!!!!        Behind the scenes, anyway, roles are represented using the same contract in Spring
            Security, GrantedAuthority. When defining a role, its name should start with the
            ROLE_ prefix. At the implementation level, this prefix specifies the difference
            between a role and an authority

!!!!        To set constraints for user roles, you can use one of the following methods:
                 hasRole()—Receives as a parameter the role name for which the application
                            authorizes the request.
                 hasAnyRole()—Receives as parameters the role names for which the application approves the request
                 access()—Uses a Spring expression to specify the role or roles for which the
                    application authorizes requests. In terms of roles, you could use hasRole() or
                    hasAnyRole() as SpEL expressions

            My recommendations are also similar: use the hasRole() or hasAnyRole() methods as
            your first option, and fall back to using access() only when the previous two don’t
            apply.

!!!         The hasRole() method now specifies the roles for which access to the
            endpoint is permitted. Mind that the ROLE_ prefix does not appear here.

            A critical thing to observe is that we use the ROLE_ prefix only to
            declare the role. But when we use the role, we do it only by its name.

!!          Make sure the parameter you provide for the roles() method does
            not include the ROLE_ prefix. If that prefix is inadvertently included in the
            role() parameter, the method throws an exception. In short, when using
            the authorities() method, include the ROLE_ prefix. When using the
            roles() method, do not include the ROLE_ prefix.

        Restricting access to all endpoints
            In this section, we discuss restricting access to all requests. You learned in chapter 5
            that by using the permitAll() method, you can permit access for all requests. You
            learned as well that you can apply access rules based on authorities and roles. But what
            you can also do is deny all requests. The denyAll() method is just the opposite of the
            permitAll() method.

            So, where could you use such a restriction? You won’t find it used as much as the other
            methods, but there are cases in which requirements make it necessary. Let me show
            you a couple of cases to clarify this point.
            Let’s assume that you have an endpoint receiving as a path variable an email
            address. What you want is to allow requests that have the value of the variable
            addresses ending in .com. You don’t want the application to accept any other format
            for the email address
                Dan: in the next chapter we will see how to do this


========================================================================================================================
Chapter 8. Configuring authorization: Applying restrictions

    In chapter 7, you learned how to configure access based on authorities and roles.
    But we only applied the configurations for all of the endpoints. In this chapter,
    you’ll learn how to apply authorization constraints to a specific group of requests.

     Even though we didn’t call attention to it, the first matcher method you used
    was the anyRequest() method.

     First, let’s talk about selecting requests by path; then we can also add the HTTP
    method to the scenario. To choose the requests to which we apply authorization configuration, we use matcher methods. Spring Security offers you three types of matcher
    methods:
         MVC matchers—You use MVC expressions for paths to select endpoints.
         Ant matchers—You use Ant expressions for paths to select endpoints.
         regex matchers—You use regular expressions (regex) for paths to select endpoints
!!!         Dan: "In Spring Security 5.8, the antMatchers, mvcMatchers, and regexMatchers methods were deprecated in
                favor of new requestMatchers methods."
                 The flavors of requestMatchers() facilitate all the ways of restricting requests that were supported
                 by the removed methods.

        anyRequest().permitAll();  // The permitAll() method states that all other requests are allowed without authentication.

!!!!NOTE When you use matchers to refer to requests, the order of the rules
    should be from particular to general. This is why the anyRequest() method
    cannot be called before a more specific matcher method like mvcMatchers().

    Unauthenticated vs. failed authentication
        If you have designed an endpoint to be accessible to anyone, you can call it without
        providing a username and a password for authentication. In this case, Spring Security
        won’t do the authentication. If you, however, provide a username and a password,
        Spring Security evaluates them in the authentication process. If they are wrong (not
        known by the system), authentication fails, and the response status will be 401
        Unauthorized.

!!!     This behavior of the framework might look strange, but it makes sense as the framework evaluates
        any username and password if you provide them in the request. As
        you learned in chapter 7, the application always does authentication before authorization, as this figure shows.


    You could decide, of course, to make all the other endpoints accessible only for
    authenticated users. To do this, you would change the permitAll() method with
    authenticated() as presented in the following listing. Similarly, you could even
    deny all other requests by using the denyAll() method.

    Selecting requests for authorization using MVC matchers
        these were deprecated and removed

        Spring Security applies, by default, protection
        against cross-site request forgery (CSRF). In chapter 1, I described CSRF, which is
        one of the most common vulnerabilities for web applications. For a long time, CSRF
        was present in the OWASP Top 10 vulnerabilities. In chapter 10, we’ll discuss how
        Spring Security mitigates this vulnerability by using CSRF tokens. But to make things
        simpler for the current example and to be able to call all endpoints, including those
        exposed with POST, PUT, or DELETE, we need to disable CSRF protection in our
        configure() method:
            http.csrf().disable();

!!!!!   As presented in the previous examples, the ** operator refers to any number of pathnames. You can use it as
        we have done in the last example so that you can match
        requests with paths having a known prefix. You can also use it in the middle of a path
        to refer to any number of pathnames or to refer to paths ending in a specific pattern
        like /a/**/c. Therefore, /a/**/c would not only match /a/b/c but also /a/b/d/c
        and a/b/c/d/e/c and so on. If you only want to match one pathname, then you can use
        a single *. For example, a/*/c would match a/b/c and a/d/c but not a/b/d/c.

        Because you generally use path variables, you can find it useful to apply authorization rules for such requests.
        You can even apply rules referring to the path variable
        value. Do you remember the discussion from section 8.1 about the denyAll()
        method and restricting all requests?
        Let’s turn now to a more suitable example of what you have learned in this section.
        We have an endpoint with a path variable, and we want to deny all requests that use a
        value for the path variable that has anything else other than digits

    Selecting requests for authorization using Ant matchers
        Dan: first part is an explanation of the differences between antmatchers and mvcmatchers... Since these are
            deprecated i moved fast...Still this is relevant for an app that uses an old Spring Security

    Selecting requests for authorization using regex matchers
        Dan: regex matchers are also deprecated...see above comments about deprecations

        In some cases, however, you might have requirements that are more particular, and you cannot
        solve those with Ant and MVC expressions. An example of such a requirement could be
        this: “Deny all requests when paths contain specific symbols or characters.” For these
        scenarios, you need to use a more powerful expression like a regex.


========================================================================================================================
Chapter 9. Implementing filters

    In Spring Security, HTTP filters delegate the different responsibilities that apply to
    an HTTP request. In chapters 3 through 5, where we discussed HTTP Basic authentication and authorization
    architecture, I often referred to filters. You learned
    about a component we named the authentication filter, which delegates the
    authentication responsibility to the authentication manager. You learned as well
    that a certain filter takes care of authorization configuration after successful
    authentication. In Spring Security, in general, HTTP filters manage each responsibility that must be applied to the
    request. The filters form a chain of responsibilities. A filter receives a request, executes its logic, and eventually
    delegates the request to the next filter in the chain

!!! The idea is simple. When you go to the airport, from entering the terminal to
    boarding the aircraft, you go through multiple filters

    Dan: see "9-1 filter chain.png"

    Spring Security provides filter implementations that you add to the filter chain through customization, but you
    can also define custom filters.

    In this chapter, we’ll discuss how you can customize filters that are part of the
    authentication and authorization architecture in Spring Security. For example, you
    might want to augment authentication by adding one more step for the user, like
    checking their email address or using a one-time password. You can, as well, add functionality referring to
    auditing authentication events.

    You’ll need to add or replace existing components of the chain. With the default implementation, you use the HTTP
    Basic authentication method, which allows you to rely on a username and password. But in
    practical scenarios, there are plenty of situations in which you’ll need more than this.
    Maybe you need to implement a different strategy for authentication, notify an external system about an
    authorization event, or simply log a successful or failed authentication that’s later used in tracing and auditing

     Implementing filters in the Spring Security architecture
!!!!!   The filters in Spring Security architecture are typical HTTP filters. We can create
        filters by implementing the Filter interface from the javax.servlet package. As for
        any other HTTP filter, you need to override the doFilter() method to implement
        its logic. This method receives as parameters the ServletRequest, ServletResponse, and FilterChain:
             ServletRequest—Represents the HTTP request. We use the ServletRequest object to retrieve details about
                the request.
             ServletResponse—Represents the HTTP response. We use the ServletResponse object to alter the response
                before sending it back to the client or further along the filter chain.
             FilterChain—Represents the chain of filters. We use the FilterChain
                object to forward the request to the next filter in the chain.

!!!     The filter chain represents a collection of filters with a defined order in which they act.
        Spring Security provides some filter implementations and their order for us. Among
        the provided filters
             BasicAuthenticationFilter takes care of HTTP Basic authentication, if present.
             CsrfFilter takes care of cross-site request forgery (CSRF) protection, which
            we’ll discuss in chapter 10.
             CorsFilter takes care of cross-origin resource sharing (CORS) authorization
            rules, which we’ll also discuss in chapter 10.

        You don’t need to know all of the filters as you probably won’t touch these directly
        from your code, but you do need to understand how the filter chain works and to be
        aware of a few implementations. In this book, I only explain those filters that are
        essential to the various topics we discuss.

!!!!!!! It is important to understand that an application doesn’t necessarily have instances
        of all these filters in the chain. The chain is longer or shorter depending on how you
        configure the application. For example, in chapters 2 and 3, you learned that you
        need to call the httpBasic() method of the HttpSecurity class if you want to use
        the HTTP Basic authentication method. What happens is that if you call the httpBasic() method, an
        instance of the BasicAuthenticationFilter is added to the chain. Similarly, depending on the configurations
        you write, the definition of the filter chain is affected

        Each filter has an order number. This determines the order in which filters are applied to
        a request. You can add custom filters along with the filters provided by Spring Security
        You add a new filter to the chain relative to another one (figure 9.4). Or, you can add
        a filter either before, after, or at the position of a known one. Each position is, in fact,
        an index (a number), and you might find it also referred to as “the order.”
         You can add two or more filters in the same position (figure 9.5). In section 9.4,
        we’ll encounter a common case in which this might occur, one which usually creates
        confusion among developers.
        NOTE If multiple filters have the same position, the order in which they are
        called is not defined.

    Adding a filter before an existing one in the chain
        In this section, we discuss applying custom HTTP filters before an existing one in the
        filter chain. You might find scenarios in which this is useful. To approach this in a
        practical way, we’ll work on a project for our example. With this example, you’ll easily
        learn to implement a custom filter and apply it before an existing one in the filter
        chain. You can then adapt this example to any similar requirement you might find in a
        production application.
        For our first custom filter implementation, let’s consider a trivial scenario. We want
        to make sure that any request has a header called Request-Id.
        We assume that our application uses this header for tracking requests
        and that this header is mandatory. At the same time, we want to validate these assumptions
        before the application performs authentication.
        The authentication process might involve querying the database or other resource-consuming actions that we
        don’t want the application to execute if the format of the request isn’t valid.

    Adding a filter after an existing one in the chain
        Let’s assume that you have to execute some logic after the
        authentication process. Examples for this could be notifying a different system after
        certain authentication events or simply for logging and tracing purposes

    Adding a filter at the location of another in the chain
        You use this approach especially when providing a different implementation
        for a responsibility that is already assumed by one of the filters known by Spring Security. A typical
        scenario is authentication.

        In our first scenario, identification based on a static key for authentication, the client
        sends a string to the app in the header of HTTP request, which is always the same.
        The application stores these values somewhere, most probably in a database or a
        secrets vault. Based on this static value, the application identifies the client.
!!!!    This approach (figure 9.9) offers weak security related to authentication, but architects and developers
        often choose it in calls between backend applications for its simplicity. The implementations also execute fast
        because these don’t need to do complex calculations, as in the case of applying a cryptographic signature.

         In our second scenario, using symmetric keys to sign and validate requests, both
        client and server know the value of a key (client and server share the key). The client
        uses this key to sign a part of the request (for example, to sign the value of specific
        headers), and the server checks if the signature is valid using the same key (figure
        9.10). The server can store individual keys for each client in a database or a secrets
        vault. Similarly, you can use a pair of asymmetric keys.

        And finally, for our third scenario, using an OTP in the authentication process, the
        user receives the OTP via a message or by using an authentication provider app like
        Google Authenticator (figure 9.11)
            Dan: see "9-11 OneTimePassword flow.png"

        We start with implementing the filter class, named StaticKeyAuthenticationFilter. This class reads the value
         of the static key from the properties file and verifies
        if the value of the Authorization header is equal to it. If the values are the same, the
        filter forwards the request to the next component in the filter chain. If not, the filter
        sets the value 401 Unauthorized to the HTTP status of the response without forwarding
        the request in the filter chain

        Once we define the filter, we add it to the filter chain at the position of the class BasicAuthenticationFilter
        by using the addFilterAt() method

!!!!    But remember what we discussed in section 9.1. When adding a filter at a specific position, Spring Security
        does not assume it is the only one at that position. You might add
        more filters at the same location in the chain. In this case, Spring Security doesn’t
        guarantee in which order these will act. I tell you this again because I’ve seen many
        people confused by how this works. Some developers think that when you apply a filter at a position of a known
        one, it will be replaced. This is not the case! We must
        make sure not to add filters that we don’t need to the chain.

!!!!!   I do advise you not to add multiple filters at the same position in the
        chain. When you add more filters in the same location, the order in which
        they are used is not defined. It makes sense to have a definite order in which
        filters are called. Having a known order makes your application easier to
        understand and maintain.

    Filter implementations provided by Spring Security
!!      Spring Security offers a few abstract classes that implement the Filter interface
        and for which you can extend your filter definitions. These classes also add functionality your implementations
        could benefit from when you extend them. For example, you could extend the GenericFilterBean class, which
        allows you to use initialization parameters that you would define in a web.xml descriptor file where applicable.
        A more useful class that extends the GenericFilterBean is OncePerRequestFilter. When adding a filter to the
        chain, the framework doesn’t guarantee it will be called only once per request. OncePerRequestFilter, as the
        name suggests, implements logic to make sure that the filter’s doFilter() method is executed only one time per
        request.

!!      If you need such functionality in your application, use the classes that Spring provides. But if you don’t
        need them, I’d always recommend you to go as simple as possible with your implementations. Too often, I’ve seen
        developers extending the GenericFilterBean class instead of implementing the Filter interface in functionalities
        that don’t require the custom logic added by the GenericFilterBean class. When asked why, it seems they
        don’t know. They probably copied the implementation as they found it in examples on the web.

        A few short observations about the OncePerRequestFilter class that you might
        find useful:
             It supports only HTTP requests, but that’s actually what we always use. The advantage
                is that it casts the types, and we directly receive the requests as HttpServletRequest and HttpServletResponse.
                Remember, with the Filter interface, we had to cast the request and the response.
             You can implement logic to decide if the filter is applied or not. Even if you added the
                filter to the chain, you might decide it doesn’t apply for certain requests. You
                set this by overriding the shouldNotFilter(HttpServletRequest)
                method. By default, the filter applies to all requests.
             By default, a OncePerRequestFilter doesn’t apply to asynchronous requests or
                error dispatch requests. You can change this behavior by overriding the methods
                shouldNotFilterAsyncDispatch() and shouldNotFilterErrorDispatch().


========================================================================================================================
Chapter 10. Applying CSRF protection and CORS
    But Spring Security also adds its own filters to the chain. In this chapter,
    we’ll discuss the filter that applies CSRF protection and the one related to CORS
    configurations. You’ll learn to customize these filters to make a perfect fit for your
    scenarios.

    Applying cross-site request forgery (CSRF) protection in applications

!!!!    The reason why you can’t directly call an endpoint with HTTP POST is because of CSRF protection, which is
        enabled by default in Spring Security.

        CSRF is a widespread type of attack, and applications vulnerable to CSRF can force
        users to execute unwanted actions on a web application after authentication. You
        don’t want the applications you develop to be CSRF vulnerable and allow attackers to
        trick your users into making unwanted actions

        How CSRF protection works in Spring Security
            As an example, consider this scenario (figure 10.1): you are at work, where you use
            a web tool to store and manage your files. With this tool, in a web interface you can
            add new files, add new versions for your records, and even delete them. You receive an
            email asking you to open a page for a specific reason. You open the page, but the page
            is blank or it redirects you to a known website. You go back to your work but observe
            that all your files are gone!

            What happened? You were logged into the application so you could manage your
            files. When you add, change, or delete a file, the web page you interact with calls some
            endpoints from the server to execute these operations. When you opened the foreign
            page by clicking the unknown link in the email, that page called the server and executed actions on your
            behalf (it deleted your files). It could do that because you logged
            in previously, so the server trusted that the actions came from you. You might think
            that someone couldn’t trick you so easily into clicking a link from a foreign email or
            message, but trust me, this happens to a lot of people. Most web app users aren’t aware
            of security risks. So it’s wiser if you, who know all the tricks to protect your users, build
            secure apps rather than rely on your apps’ users to protect themselves.

!!!!!       CSRF attacks assume that a user is logged into a web application. They’re tricked
            by the attacker into opening a page that contains scripts that execute actions in the
            same application the user was working on. Because the user has already logged in (as
            we’ve assumed from the beginning), the forgery code can now impersonate the user
            and do actions on their behalf.
                Dan: see "10-1 CSRF attack example.png"

            How do we protect our users from such scenarios? What CSRF protection wants to
            ensure is that only the frontend of web applications can perform mutating operations
            (by convention, HTTP methods other than GET, HEAD, TRACE, or OPTIONS).
            Then, a foreign page, like the one in our example, can’t act on behalf of the user.
             How can we achieve this? What you know for sure is that before being able to do
            any action that could change data, a user must send a request using HTTP GET to see
            the web page at least once. When this happens, the application generates a unique
            token. The application now accepts only requests for mutating operations (POST,
            PUT, DELETE, and so forth) that contain this unique value in the header. The application
            considers that knowing the value of the token is proof that it is the app itself
            making the mutating request and not another system. Any page containing mutating
            calls, like POST, PUT, DELETE, and so on, should receive through the response the
            CSRF token, and the page must use this token when making mutating calls.

!!!!!!      The starting point of CSRF protection is a filter in the filter chain called CsrfFilter.
            The CsrfFilter intercepts requests and allows all those that use these HTTP
            methods: GET, HEAD, TRACE, and OPTIONS. For all other requests, the filter expects
            to receive a header containing a token. If this header does not exist or contains an
            incorrect token value, the application rejects the request and sets the status of the
            response to HTTP 403 Forbidden.

!!!         The CsrfFilter (figure 10.3) uses a component named CsrfTokenRepository to
            manage the CSRF token values that generate new tokens, store tokens, and eventually
            invalidate these. By default, the CsrfTokenRepository stores the token on the
            HTTP session and generates the tokens as random universally unique identifiers
            (UUIDs). In most cases, this is enough, but as you’ll learn in section 10.1.3, you can
            use your own implementation of CsrfTokenRepository if the default one doesn’t
            apply to the requirements you need to implement.

        Using CSRF protection in practical scenarios
            You use CSRF protection for web apps running in a browser, where you should
            expect that mutating operations can be done by the browser that loads the displayed
            content of the app. The most basic example I can provide here is a simple web application developed on the
            standard Spring MVC flow

            If you look at Chapter 2, example 2, and you run the project, after opening localhost:8080/main, you will be
            redirected to the login page. Here if you use ChromeDevTools, you will see that there is an extra hidden
            element that contains the CRSF token:
                <input name="_csrf" type="hidden" value="BcE4axXon3EQPHxo8xT45dGpoHJbz21Vmtb7xkv3rBdPguLGMPJZD3GLrBA9XkVdxjnMh-KZjUtq-1t4_-PJon_AlS5-sIHz">

            But what about developing our own endpoints that use POST, PUT, or DELETE as
            HTTP methods? For these, we have to take care of sending the value of the CSRF
            token if CSRF protection is enabled. To test this, let’s add an endpoint using HTTP
            POST to our application. We call this endpoint from the main page, and we create a
            second controller for this, called ProductController. Within this controller, we
            define an endpoint, /product/add, that uses HTTP POST

                Dan: in chapter 10 ex2 we provide the CSRF token in the html form via thymeleaf

            Of course, for any action or asynchronous JavaScript request your page uses to call a
            mutable action, you need to send a valid CSRF token. This is the most common way
            used by an application to make sure the request doesn’t come from a third party. A
            third-party request could try to impersonate the user to execute actions on their
            behalf.

        Customizing CSRF protection
            In this section, the examples let you apply the most frequently encountered needs in customization of the
            CSRF protection mechanism. These are
                 Configuring paths for which CSRF applies
                 Managing CSRF tokens

            But what if you want to disable it only for some of your application paths? You can do this configuration
            quickly with a Customizer object

!!!!!!      Another need often found in the requirements of the application is customizing the
            management of CSRF tokens. As you learned, by default, the application stores CSRF
            tokens in the HTTP session on the server side. This simple approach is suitable for
            small applications, but it’s not great for applications that serve a large number of
            requests and that require horizontal scaling. The HTTP session is stateful and reduces
            the scalability of the application

!!!!!!!     Let’s suppose you want to change the way the application manages tokens and
            store them somewhere in a database rather than in the HTTP session. Spring Security
            offers two contracts that you need to implement to do this:
                 CsrfToken — Describes the CSRF token itself
                 CsrfTokenRepository — Describes the object that creates, stores, and loads CSRF tokens

!!          CsrfTokenRepository is responsible for managing CSRF tokens in Spring Security.
            The interface CsrfTokenRepository is the contract that represents the component that manages CSRF tokens.
            To change the way the application manages the
            tokens, you need to implement the CsrfTokenRepository interface, which allows
            you to plug your custom implementation into the framework.

            An alternative to this approach would be to use CSRF tokens with a defined lifetime. With such an approach,
            tokens expire after a time you define. You can store
            tokens in the database without linking them to a specific user ID. You only need to
            check if a token provided via an HTTP request exists and is not expired to decide
            whether you allow that request.

     Using cross-origin resource sharing
!!!!    First, what is CORS and why should you care? The necessity for
        CORS came from web applications. By default, browsers don’t allow requests made for
        any domain other than the one from which the site is loaded. For example, if you
        access the site from example.com, the browser won’t let the site make requests to
        api.example.com. Figure 10.12 shows this concept.
        We can briefly say that a browser uses the CORS mechanism to relax this strict policy and allow requests
        made between different origins in some conditions. You need
        to know this because it’s likely you will have to apply it to your applications, especially
        nowadays where the frontend and backend are separate applications. It is common
        that a frontend application is developed using a framework like Angular, ReactJS, or
        Vue and hosted at a domain like example.com, but it calls endpoints on the backend
        hosted at another domain like api.example.com. For this section, we develop some
        examples from which you can learn how to apply CORS policies for your web applications.
        We also describe some details that you need to know such that you avoid leaving
        security breaches in your applications.

        Dan: see "10-12 CORS meaning.png"

        How does CORS work?
            In this section, we discuss how CORS applies to web applications. If you are the owner
            of example.com, for example, and for some reason the developers from example.org
            decide to call your REST endpoints from their website, they won’t be able to. The
            same situation can happen if a domain loads your application using an iframe, for
            example (see figure 10.13).
                NOTE An iframe is an HTML element that you use to embed content generated by a web page into another
                web page (for example, to integrate the content from example.org inside a page from example.com).
!!          Any situation in which an application makes calls between two different domains is
            prohibited. But, of course, you can find cases in which you need to make such calls. In
            these situations, CORS allows you to specify from which domain your application
!!!!!       allows requests and what details can be shared. The CORS mechanism works based on
            HTTP headers. The most important are
               Access-Control-Allow-Origin — Specifies the foreign domains (origins) that can access resources on your domain.
               Access-Control-Allow-Methods — Lets us refer only to some HTTP methods in situations in which we want to
                allow access to a different domain, but only to specific HTTP methods. You use this if you’re going to
                enable example.com to call some endpoint, but only with HTTP GET, for example.
               Access-Control-Allow-Headers — Adds limitations to which headers you can use in a specific request.

!!!!!       With Spring Security, by default, none of these headers are added to the response. So
            let’s start at the beginning: what happens when you make a cross-origin call if you don’t
            configure CORS in your application. When the application makes the request, it
            expects that the response has an Access-Control-Allow-Origin header containing the origins accepted by the
            server. If this doesn’t happen, as in the case of default
            Spring Security behavior, the browser won’t accept the response.

            The error looks like this:
                Access to XMLHttpRequest at 'http://127.0.0.1:8080/test' from origin 'http://
                localhost:8080' has been blocked by CORS policy: No 'Access-ControlAllow-Origin' header is present on the requested resource.
            The error message tells us that the response wasn’t accepted because the AccessControl-Allow-Origin HTTP
            header doesn’t exist. This behavior happens because we didn’t configure anything regarding CORS in our
            Spring Boot application, and by default, it doesn’t set any header related to CORS. So the browser’s
            behavior of not displaying the response is correct. I would like you, however, to notice
            that in the application console, the log proves the method was called

!!!         This aspect is important! I meet many developers who understand CORS as a restriction
            similar to authorization or CSRF protection. Instead of being a restriction, CORS helps
            to relax a rigid constraint for cross-domain calls. And even with restrictions applied, in
            some situations, the endpoint can be called. This behavior doesn’t always happen.
            Sometimes, the browser first makes a call using the HTTP OPTIONS method to test
            whether the request should be allowed. We call this test request a preflight request. If the
            preflight request fails, the browser won’t attempt to honor the original request.
            The preflight request and the decision to make it or not are the responsibility of
            the browser. You don’t have to implement this logic. But it is important to understand
            it, so you won’t be surprised to see cross-origin calls to the backend even if you did not
            specify any CORS policies for specific domains.

!!!         The CORS mechanism is, in the end, related to the browser and not a way to secure endpoints. The only
            thing it guarantees is that only origin domains that you allow can
            make requests from specific pages in the browser.

        Applying CORS policies with the @CrossOrigin annotation
!!!         In this section, we discuss how to configure CORS to allow requests from different
            domains using the @CrossOrigin annotation. You can place the @CrossOrigin
            annotation directly above the method that defines the endpoint and configure it
            using the allowed origins and methods. As you learn in this section, the advantage of
            using the @CrossOrigin annotation is that it makes it easy to configure CORS for
            each endpoint.

            The value parameter of @CrossOrigin receives an array to let you define multiple
            origins; for example, @CrossOrigin({"example.com", "example.org"}). You
            can also set the allowed headers and methods using the allowedHeaders attribute
            and the methods attribute of the annotation. For both origins and headers, you can
            use the asterisk (*) to represent all headers or all origins

            The advantage of using @CrossOrigin to specify the rules directly where the endpoints are defined is that
            it creates good transparency of the rules. The disadvantage is
            that it might become verbose, forcing you to repeat a lot of code. It also imposes the
            risk that the developer might forget to add the annotation for newly implemented
            endpoints. In section 10.2.3, we discuss applying the CORS configuration centralized
            within the configuration class

        Applying CORS using a CorsConfigurer
            you might find it more comfortable in a lot of cases to define CORS configuration in one place.

                http.cors(c -> {
                 CorsConfigurationSource source = request -> {
                     CorsConfiguration config = new CorsConfiguration();
                     config.setAllowedOrigins(
                        List.of("example.com", "example.org"));
                     config.setAllowedMethods(
                        List.of("GET", "POST", "PUT", "DELETE"));
                     return config;
                 };
                 c.configurationSource(source);
                 });


========================================================================================================================
Chapter 11. Hands-on: A separation of responsibilities
    In this chapter, we’ll design a system of three actors: the client, the authentication
    server, and the business logic server. From these three actors, we’ll implement the
    backend part of the authentication server and a business logic server. As you’ll
    observe, our examples are more complex. This is a sign that we are getting closer and
    closer to real-world scenarios.

    This exercise is also a great chance to recap, apply, and better understand what
    you’ve already learned and to touch on new subjects like JSON Web Tokens (JWTs). You
    also see a first demonstration of separating the authentication and authorization
    responsibilities in a system

    The scenario and requirements of the example
        The architecture of the system has three components. You’ll find these components illustrated in figure 11.1.
        The three components are:
             The client—This is the application consuming the backend. It could be a mobile
            app or the frontend of a web application developed using a framework like
            Angular, ReactJS, or Vue.js. We don’t implement the client part of the system,
            but keep in mind that it exists in a real-world application. Instead of using the
            client to call endpoints, we use cURL.
             The authentication server—This is an application with a database of user credentials. The purpose of this
            application is to authenticate users based on their credentials (username and password) and send them a one-time
            password (OTP) through SMS. Because we won’t actually send an SMS in this example, we’ll
            read the value of the OTP from the database directly.
            In this chapter, we implement this whole application without sending the
            SMS. Later, you can also extend it to send messages using a service of your
            choice, like AWS SNS (https://aws.amazon.com/sns/), Twillio (https://www.twilio.com/sms), or others.
             The business logic server—This is the application exposing endpoints that our client consumes. We want to
            secure access to these endpoints. Before calling an
            endpoint, the user must authenticate with their username and password and
            then send an OTP. The user receives the OTP through an SMS message. Because
            this application is our target application, we secure it with Spring Security

            Dan: see "11-1 architecture of project built in this chapter.png"

!!!!    To call any endpoint on the business logic server, the client has to follow three steps:
            1 Authenticate the username and password by calling the /login endpoint on the
                business logic server to obtain a randomly generated OTP.
            2 Call the /login endpoint with the username and OTP.
            3 Call any endpoint by adding the token received in step 2 to the Authorization header of the HTTP request

!!!!    When the client authenticates the username and password, the business logic server
        sends a request for an OTP to the authentication server. After successful authentication, the authentication
        server sends a randomly generated OTP to the client via SMS
        (figure 11.2). This way of identifying the user is called multi-factor authentication
        (MFA), and it’s pretty common nowadays. We generally need users to prove who they
        are both by using their credentials and with another means of identification (for
        example, they own a specific mobile device).
        In the second authentication step, once the client has the code from the received
        SMS, the user can call the /login endpoint, again with the username and the code.
        The business logic server validates the code with the authentication server. If the code
        is valid, the client receives a token that it can use to call any endpoint on the business
        logic server (figure 11.3).

!!!            Dan: see "11-2 first authentication step.png"
!!!            Dan: see "11-3 second authentication step.png"

        In the third authentication step, the client can now call any endpoint by adding the
        token it receives in step 2 to the Authorization header of the HTTP request. Figure
        11.4 illustrates this step.

            Dan: see "11-4 third authentication step.png"

        Someone could argue that this architecture
        uses vicious approaches as the client should only share passwords with the
        authentication server and never with the business logic server. This is correct!
        In our case, it’s just a simplification. In real-world scenarios, in general, we
        strive to keep credentials and secrets known by as few components in the system as possible. Also, someone
        could argue that the MFA scenario itself could
        be more easily implemented by using a third-party management system like
        Okta or something similar. Part of the purpose of the example is to teach you
        how to define custom filters. For this reason, I chose the hard way to implement, ourselves, this part in
        the authentication architecture

    Implementing and using tokens
!!!!    A token is similar to an access card. An application obtains a token as a result of the
        authentication process and to access resources. Endpoints represent the resources in
        a web application. For a web application, a token is a string, usually sent through an
        HTTP header by clients that want to access a particular endpoint. This string can be
        plain like a pure universally unique identifier (UUID), or it might have a more complex shape like a
        JSON Web Token (JWT).
        Today, tokens are often used in authentication and authorization architectures,
        and that’s why you need to understand them. As you’ll find out in chapter 12, these
        are one of the most important elements in the OAuth 2 architecture, which is also frequently used today.
        And as you’ll learn in this chapter, but also in chapters 12 through
        15, tokens offer us advantages (like separation of responsibilities in the authentication
        and authorization architecture), help us make our architecture stateless, and provide
        possibilities to validate requests

        What is a token?
            Tokens provide a method that an application uses to prove it has authenticated a user,
            which allows the user to access the application’s resources. In section 11.2.2, you’ll discover one of
            the most common token implementations used today: the JWT.

!!!!        What are tokens? A token is just an access card, theoretically. When you visit an
            office building, you first go to the reception desk. There, you identify yourself
            (authentication), and you receive an access card (token). You can use the access card
            to open some doors, but not necessarily all doors. This way, the token authorizes your
            access and decides whether you’re allowed to do something, like opening a particular door

!!!!!       But tokens bring more advantages, so let’s enumerate them and then discuss them one by one:
                 Tokens help you avoid sharing credentials in all requests.
                    In chapters 2 through 10, we
                    worked with HTTP Basic as the authentication method for all requests. And this
                    method, as you learned, assumes you send credentials for each request. Sending credentials
                    with each request isn’t OK because it often means that you expose them. The
                    more often you expose the credentials, the bigger the chances are that someone intercepts them.
                    With tokens, we change the strategy. We send credentials only in the first
                    request to authenticate. Once authenticated, we get a token, and we can use it to get
                    authorized for calling resources. This way, we only have to send credentials once to
                    obtain the token.
                 You can define tokens with a short lifetime.
                 You can invalidate tokens without invalidating the credentials.
                    If a deceitful individual steals the token,
                    they won’t be able to use it forever. Most probably, the token might expire before they
                    find out how to use it to break into your system. You can also invalidate tokens. If you
                    find out a token has been exposed, you can refute it. This way, it can’t be used anymore by anyone.
                 Tokens can also store details like user authorities that the client needs to send in the request.
                    We can use tokens to store details like
                    authorities and roles of the user. This way, we can replace a server-side session with a client-side
                    session, which offers us better flexibility for horizontal scaling. You’ll see more
                    about this approach in chapters 12 through 15 when we discuss the OAuth 2 flow
                 Tokens help you delegate the authentication responsibility to another component in the system.

        What is a JSON Web Token?
            In this section, we discuss a more specific implementation of tokens—the JSON Web
            Token (JWT). This token implementation has benefits that make it quite common in
            today’s applications. This is why we discuss it in this section, and this is also why I’ve
            chosen to apply it within the hands-on example of this chapter

            It’s easy to understand a lot about JWTs from the name of the implementation itself:
                 JSON—It uses JSON to format the data it contains.
                 Web—It’s designed to be used for web requests.
                 Token—It’s a token implementation.

            A JWT has three parts, each part separated from the others by a dot (a period). You
            find an example in this code snippet:
                eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImRhbmllbGxlIn0.wg6LFProg7s_KvFxvnYGiZFMj4rr-0nJA1tVGZNn8U

!!!!        The first two parts are the header and the body. The header (from the beginning of
            the token to the first dot) and the body (between the first and the second dot) are formatted as JSON and
            then are Base64 encoded. We use the header and the body to store details in the token.

                So eyJhbGciOiJIUzI1NiJ9 base64 decoded is {"alg":"HS256"}
                eyJ1c2VybmFtZSI6ImRhbmllbGxlIn0  base64 decoded is {"username":"danielle"}

            In the header, you store metadata related to the token. In this case, because I chose to
            sign the token (as you’ll soon learn in the example), the header contains the name of
            the algorithm that generates the signature (HS256). In the body, you can include
            details needed later for authorization. In this case, we only have the username. I recommend that you
            keep the token as short as possible and that you don’t add a lot of
            data in the body. Even if, technically, there’s no limitation, you’ll find that
                 If the token is long, it slows the request.
                 When you sign the token, the longer the token, the more time the cryptographic algorithm needs for
                    signing it.

!!!!!       The last part of the token (from the second dot to the end) is the digital signature,
            but this part can be missing. Because you’ll usually prefer to sign the header and the
            body, when you sign the content of the token, you can later use the signature to check
            that the content hasn’t changed. Without a signature, you can’t be sure that someone
            didn’t intercept the token when transferred on the network and chang its content.

                Dan: see "11-8 JWT structure.png"

            In this chapter, we’ll use Java JSON Web Token (JJWT) as the library to create and
            parse JWTs. This is one of the most frequently used libraries to generate and parse
            JWT tokens in Java applications. Besides all the needed details related to how to use
            this library, on JJWT’s GitHub repository, I also found a great explanation of JWTs.
            You might find it useful to read as well:
                https://github.com/jwtk/jjwt#overview

    Implementing the authentication server
        In our scenario, the authentication server connects to a database where it stores
        the user credentials and the OTPs generated during request authentication events.
        We need this application to expose three endpoints (figure 11.9):
             /user/add—Adds a user that we use later for testing our implementation.
             /user/auth—Authenticates a user by their credentials and sends an SMS with
            an OTP. We take out the part that sends the SMS, but you can do this as an exercise.
             /otp/check—Verifies that an OTP value is the one that the authentication server
            generated earlier for a specific user

        I added Spring Security to the dependencies as well for this application. The only reason I did this for
        the authentication server is to have the BCryptPasswordEncoder
        that I like to use to hash the users’ passwords when stored in the database. To keep the
        example short and relevant to our purpose, I don’t implement authentication
        between the business logic server and the authentication server. But I’d like to leave
        this to you as an exercise later, after finishing with the hands-on example

    Implementing the business logic server
        With this part of the system, you learn to implement and use JWTs
        for authentication and authorization. As well, we implement communication between
        the business logic server and the authentication server to establish the MFA in your
        application. To accomplish our task, at a high level, we need to:
            1 Create an endpoint that represents the resource we want to secure.
            2 Implement the first authentication step in which the client sends the user credentials (username and
                password) to the business logic server to log in.
            3 Implement the second authentication step in which the client sends the OTP
                the user receives from the authentication server to the business logic server.
                Once authenticated by the OTP, the client gets back a JWT, which it can use to
                access a user’s resources.
            4 Implement authorization based on the JWT. The business logic server validates
                the JWT received from a client and, if valid, allows the client to access the
                resource

        Dan : see "11-11 first authentication step.png"
                   "11-12 second authentication step.png"
                   "11-13 third authentication step.png"

!!!     I wrote a minimal implementation of our example, and I skipped
        some details like treating exceptions and logging the event. These aspects
        aren’t essential for our example now, where I only ask you to focus on Spring
        Security components and architecture. In a real-world application, you
        should also implement all these details.

        The following code snippet builds the JWT. I use the setClaims() method to add a
        value in the JWT body and the signWith() method to attach a signature to the
        token. For our example, I use a symmetric key (the SecretKey interface represents symmetric keys) to generate
        the signature:
            SecretKey key = Keys.hmacShaKeyFor(signingKey.getBytes(StandardCharsets.UTF_8));
            String jwt = Jwts.builder()
             .setClaims(Map.of("username", username))
             .signWith(key)
             .compact();

!!!!!!  This key is known only by the business logic server. The business logic server signs the
        token and can use the same key to validate the token when the client calls an endpoint. For simplicity of the
        example, I use here one key for all users. In a real-world
        scenario, however, I would have a different key for each user, but as an exercise, you
        can change this application to use different keys. The advantage of using individual
        keys for users is that if you need to invalidate all the tokens for a user, you need only to
        change its key.
            Dan: i searched a bit online, and this one different key for each user presents various challenges as well
                like the increased complexity of handling all those keys etc

        A signed JWT is also called JWS (JSON Web Token Signed). This is
        why the name of the method we use is parseClaimsJws().


========================================================================================================================
Chapter 12. How does OAuth 2 work?

    If you already work with OAuth 2, I know what you’re thinking: the OAuth 2 framework is a vast subject that could
    take an entire book to cover. And I can’t argue with
    that, but in four chapters, you’ll learn everything you need to know about applying
    OAuth 2 with Spring Security.

    you’ll discover that the main actors in the OAuth 2 framework are the user, the client, the
    resource server, and the authorization server. After the general introduction, you’ll
    learn how to use Spring Security to implement the client. Then, in chapters 13
    through 15, we’ll discuss implementing the last two components: the resource
    server and the authorization server.

    To reach this goal, in this chapter, we’ll discuss what OAuth 2 is, and then we’ll
    apply it to an application focused on authentication with single sign-on (SSO). The
    reason why I like teaching this subject with the example of an SSO is that it’s very simple but also very useful.
    It provides an overview of OAuth 2, and it gives you the satisfaction of implementing a fully working application
    without writing too much code.

    The OAuth 2 framework
        The chances are that you’ll need to apply OAuth 2 in your applications. And this is why we need to
        discuss applying OAuth 2 in Spring applications with Spring Security. We start with a
        little bit of theory and then move on to apply it with an application using SSO.

        In most cases, OAuth 2 is referred to as an authorization framework (or a specification
        framework) whose primary purpose is to allow a third-party website or app access to a
        resource.
        Whatever you choose to call it, it’s important to remember that OAuth 2 is not a specific implementation
        or a library. You could, as well, apply the OAuth 2 flow definitions with other
        platforms, tools, or languages. In this book, you’ll find out how to implement OAuth 2
        with Spring Boot and Spring Security

        Most often, we want to have a separate system manage user credentials. Imagine, that you have to configure and use
        separate credentials for all the applications you work with in your organization
        It would be better if we isolated the responsibility for credential management in one
        component of our system. Let’s call it, for now, the authorization server

            Dan: see "12-2 multiple apps each with different password system in a company sucks.png"
                    "12-3 all apps in a company using a central system for auth.png"

    The components of the OAuth 2 authentication architecture
        You need to know these components and the role they play, as we refer to
        them throughout the next sections. I also refer to them throughout the rest of the
        book wherever we write an implementation related to OAuth 2. But in this section, we
        only discuss what these components are and their purpose

!!!!!   Dan: see "12-4 main components of OAuth2 architecture.png"

!!!!!   As you’ll learn in section 12.3, there are more ways in which these components “talk” to each
        other. And, in that section, you’ll also learn about different flows that cause different
        interactions between these components.
        As mentioned, OAuth 2 components include
             The resource server—The application hosting resources owned by users.
            Resources can be users’ data or their authorized actions.
             The user (also known as the resource owner)—The individual who owns resources
            exposed by the resource server. A user generally has a username and a password
            that they use to identify themselves.
             The client—The application that accesses the resources owned by the user on
            their behalf. The client uses a client ID and a client secret to identify itself. Be
            careful, these credentials are not the same as the user credentials. The client
            needs its own credentials to identify itself when making a request.
             The authorization server—The application that authorizes the client to access the
            user’s resources exposed by the resource server. When the authorization server
            decides that a client is authorized to access a resource on behalf of the user, it
            issues a token. The client uses this token to prove to the resource server that it
            was authorized by the authorization server. The resource server allows the client
            to access the resource it requested if it has a valid token.

    Implementation choices with OAuth 2
        OAuth 2 implies multiple possible authentication flows, and you need to know which one applies to your case.
        In this section, I take the most common cases and evaluate these

        So how does OAuth 2 work? What does it mean to implement OAuth 2 authentication and authorization? Mainly,
        OAuth 2 refers to using tokens for authorization.
        Remember from section 11.2 that tokens are like access cards. Once you obtain a
        token, you can access specific resources.

!!!     But OAuth 2 offers multiple possibilities for obtaining a token, called grants. Here are the most common OAuth
        2 grants you can choose from:
           Authorization code
           Password
           Refresh token
           Client credentials

        When starting an implementation, we need to choose our grant. Do we select it randomly? Of course not. We need
        to know how tokens are created for each type of grant.
        Then, depending on our application requirements, we choose one of them

            1. Implementing the "authorization code" grant type
                This grant type is one of the most commonly used OAuth 2 flows, so it’s quite important to understand
                how it works and how to apply it. There’s a high probability that you’ll use it in applications you
                develop.

!!!!!               Dan: see "12-5 authorization code grant type.png"

                NOTE The arrows in figure 12.5 don’t necessarily represent HTTP requests
                and responses. These represent messages exchanged among the actors of
                OAuth 2. For example, when the client tells the user (second arrow from the
                top of the diagram), “Tell the authorization server you allow me to do this
                action,” the client then redirects the user to the authorization server login
                page. When the authorization server gives the client an access token, the
                authorization server actually calls the client on what we call a redirect URI.

                an analogy for this flow. I sometimes buy books from a small
                shop I’ve known for ages. I have to order books in advance and then pick them up a
                couple of days later. But the shop isn’t on my daily route, so sometimes I can’t go
                myself to pick up the books. I usually ask a friend who lives near me to go there and
                collect them for me. When my friend asks for my order, the lady from the shop calls
                me to confirm I’ve sent someone to fetch my books. After my confirmation, my friend
                collects the package and brings it to me later in the day.
                In this analogy, the books are the resources. I own them, so I’m the user (resource
                owner). My friend that picks them up for me is the client. The lady selling the books is
                the authorization server. (We can also consider her or the book store as being the
                resource server.) Observe that to grant permission to my friend (client) to collect the
                books (resources), the lady (authorization server) selling the books calls me (user)
                directly.

                STEP 1: MAKING THE AUTHENTICATION REQUEST WITH THE AUTHORIZATION CODE GRANT TYPE
                    The client redirects the user to an endpoint of the authorization server where they
                    need to authenticate. You can imagine you are using app X, and you need to access a
                    protected resource. To access that resource for you, app X needs you to authenticate.
                    It opens a page for you with a login form on the authorization server that you must fill
                    in with your credentials.
                    NOTE What’s really important to observe here is that the user interacts
                    directly with the authorization server. The user doesn’t send the credentials
                    to the client app.

                    Technically, what happens here is that when the client redirects the user to the authorization server,
                    the client calls the authorization endpoint with the following details in the request query:
                         response_type with the value code, which tells the authorization server that
                        the client expects a code. The client needs the code to obtain an access token,
                        as you’ll see in the second step.
                         client_id with the value of the client ID, which identifies the application itself.
                         redirect_uri, which tells the authorization server where to redirect the user
                        after successful authentication. Sometimes the authorization server already
                        knows a default redirect URI for each client. For this reason, the client doesn’t
                        need to send the redirect URI.
                         scope, which is similar to the granted authorities we discussed in chapter 5.
                         state, which defines a cross-site request forgery (CSRF) token used for the
                        CSRF protection we discussed in chapter 10.

                    After successful authentication, the authorization server calls back the client on the
                    redirect URI and provides a code and the state value. The client checks that the state
                    value is the same as the one it sent in the request to confirm that it was not someone
                    else attempting to call the redirect URI. The client uses the code to obtain an access
                    token as presented in step 2

                STEP 2: OBTAINING AN ACCESS TOKEN WITH THE AUTHORIZATION CODE GRANT TYPE
                    To allow the user to access resources, the code resulting from step 1 is the client’s
                    proof that the user authenticated. You guessed correctly, this is why this is called the
                    authorization code grant type. Now the client calls the authorization server with the
                    code to get the token.

                    In the first step, the interaction was between the user and the authorization server. In this step,
                    the interaction is between the client and the authorization server

                    To return to step 2, technically, the client now makes a request to the authorization
                    server. This request contains the following details:
                         code, which is the authorization code received in step 1. This proves that the
                        user authenticated.
                         client_id and client_secret, the client’s credentials.
                         redirect_uri, which is the same one used in step 1 for validation.
                         grant_type with the value authorization_code, which identifies the kind
                        of flow used. A server might support multiple flows, so it’s essential always to
                        specify which is the current executed authentication flow

                    As a response, the server sends back an access_token. This token is a value that the
                    client can use to call resources exposed by the resource server.

                STEP 3: CALLING THE PROTECTED RESOURCE WITH THE AUTHORIZATION CODE GRANT TYPE
                    After successfully obtaining the access token from the authorization server, the client
                    can now call for the protected resource. The client uses an access token in the authorization
                    request header when calling an endpoint of the resource server.

                The authorization code grant type has the great advantage of enabling
                the user to allow a client to execute specific actions without needing to share
                their credentials with the client. But this grant type has a weakness: what happens if someone intercepts
                the authorization code? Of course, the client
                needs to authenticate with its credentials, as we discussed previously. But what
                if the client credentials are also stolen somehow? Even if this scenario isn’t
                easy to achieve, we can consider it a vulnerability of this grant type. To mitigate this vulnerability,
                you need to rely on a more complex scenario as presented by the Proof Key for Code Exchange (PKCE)
                authorization code grant type.

            2. Implementing the password grant type
                This grant type is also known as the resource owner credentials grant type. Applications using this flow assume
                that the client collects the user credentials and uses these to authenticate and obtain
                an access token from the authorization server.
                Remember our hands-on example in chapter 11? The architecture we implemented is quite close to what
                happens in the password grant type

                Dan: see "12-7 password grant type.png"

!!!!            To refer back to the analogy I made in section 12.3.1, imagine the lady selling the books
                doesn’t call me to confirm I want my friend to get the books. I would instead give my ID
                to my friend to prove that I delegated my friend to pick up the books. See the difference? In this
                flow, I need to share my ID (credentials) with the client. For this reason,
                we say that this grant type applies only if the resource owner “trusts” the client.

                The password grant type assumes that the user shares their credentials with the client.
                The client uses these to obtain a token from the authorization server. It then accesses the resources
                from the resource server on behalf of the user.

                Let’s see what happens when using the password grant type.
                The two tasks are as follows:
                    1 Request an access token.
                    2 Use the access token to call resources.

                STEP 1: REQUESTING AN ACCESS TOKEN WHEN USING THE PASSWORD GRANT TYPE
                    When requesting the access token, the client also sends the following details in the request:
                         grant_type with the value "password".
                         client_id and client_secret, which are the credentials used by the client
                        to authenticate itself.
                         scope, which you can understand as the granted authorities.
                         username and password, which are the user credentials. These are sent in
                        plain text as values of the request header

                    The client receives back an access token in the response. The client can now use the
                    access token to call the endpoints of the resource server.

                STEP 2: USING AN ACCESS TOKEN TO CALL RESOURCES WHEN USING THE PASSWORD GRANT TYPE
                    Once the client has an access token, it uses the token to call the endpoints on the
                    resource server, which is exactly like the authorization code grant type. The client
                    adds the access token to the requests in the authorization request header.

!!!             The password grant type is less secure than the authorization code
                grant type, mainly because it assumes sharing the user credentials with the client app. While it’s true
                that it’s more straightforward than the authorization code grant type and this is the main reason you
                also find it used plenty in theoretical examples, try to avoid this grant type in real-world scenarios.
                Even if the authorization server and the client are both built by the same organization, you should first
                think about using the authorization code grant type.

            3. Implementing the client credentials grant type
!!!!            This is the simplest of the grant types described by OAuth 2. You can use it when no user is involved;
                that is, when implementing authentication between two applications. I like to think
                about the client credentials grant type as being a combination of the password grant
                type and an API key authentication flow. We assume you have a system that implements authentication with
                OAuth 2. Now you need to allow an external server to
                authenticate and call a specific resource that your server exposes

                Dan: see "12-8 client credentials grant type"

                Here are the steps to implement this grant type:
                    1 Request an access token
                    2 Use the access token to call resources

                STEP 1: REQUESTING AN ACCESS TOKEN WITH THE CLIENT CREDENTIAL GRANT TYPE
                    To obtain an access token, the client sends a request to the authorization server with the following
                    details:
                         grant_type with the value client_credentials
                         client_id and client_secret, which represent the client credentials
                         scope, which represents the granted authorities

                    In response, the client receives an access token. The client can now use the access
                    token to call the endpoints of the resource server.

                STEP 2: USING AN ACCESS TOKEN TO CALL RESOURCES WITH THE CLIENT CREDENTIAL GRANT TYPE
                    Once the client has an access token, it uses that token to call the endpoints on the
                    resource server, which is exactly like the authorization code grant type and the password grant
                    type. The client adds the access token to the requests in the authorization request header.

            4. Using refresh tokens to obtain new access tokens
                Up to now, you learned that
                the result of an OAuth 2 flow, which we also call grant, is an access token. But we didn’t
                say much about this token. In the end, OAuth 2 doesn’t assume a specific implementation for tokens.
                What you’ll learn now is that a token, no matter how it’s implemented, can expire. It’s not mandatory—you
                can create tokens with an infinite lifespan—but, in general, you should make these as short lived as
                possible. The refresh tokens that we discuss in this section represent an alternative to using credentials
                for obtaining a new access token. I show you how refresh tokens work in OAuth 2,
                and you’ll also see these implemented with an application in chapter 13.

                    Dan: see "12-9 refresh token.png"

                If the token doesn’t expire, someone
                who gets their hands on the token can use it to access resources. A token that doesn’t
                expire is too powerful. It becomes almost as powerful as user credentials. We prefer to
                avoid this and make the token short lived. This way, at some point, an expired token
                can’t be used anymore. The client has to obtain another access token.

                To obtain a new access token, the client can rerun the flow, depending on the
                grant type used. For example, if the grant type is authentication code, the client would
                redirect the user to the authorization server login endpoint, and the user must again
                fill in their username and password. Not really user friendly, is it? Imagine that the
                token has a 20-minute lifespan and you work for a couple of hours with the online
                app. During that time, the app would redirect you back about six times to log in again.
                (Oh no! That app logged me out again!) To avoid the need to reauthenticate, the
                authorization server can issue a refresh token, which has a different value and purpose than an
                access token. The app uses the refresh token to obtain a new access
                token instead of having to reauthenticate.

!!!!            Instead of unsafely storing (user) credentials and without needing to redirect the user every time, you
                can store a refresh token and use it to obtain a new access token when needed. Storing the refresh token
                is safer because you can revoke it if you find that it was exposed.
                Moreover, don’t forget that people tend to have the same credentials for multiple
                apps. So losing credentials is worse than losing a token that one could use with a specific application

                Where do you get a refresh token from? The authorization server returns a refresh token together with
                an access token when using a flow like the authorization code or password grant types. With the client
                credentials grant, there’s no refresh token because this flow doesn’t need user credentials.
                Once the client has a refresh token, the client should issue a request with the following details
                when the access token expires:
                     grant_type with value refresh_token.
                     refresh_token with the value of the refresh token.
                     client_id and client_secret with the client credentials.
                     scope, which defines the same granted authorities or less. If more granted
                    authorities need to be authorized, a reauthentication is needed.
                In response to this request, the authorization server issues a new access token and a
                new refresh token.

     The sins of OAuth 2
        we discuss possible vulnerabilities of OAuth 2 authentication and
        authorization. It’s important to understand what can go wrong when using OAuth 2
        so that you can avoid these scenarios. Of course, like anything else in software development, OAuth 2 isn’t
        bulletproof. It has its vulnerabilities of which we must be aware
        and which we must consider when building our applications. I enumerate here some
        of the most common:
             Using cross-site request forgery (CSRF) on the client—With a user logged in, CSRF is
            possible if the application doesn’t apply any CSRF protection mechanism. We
            had a great discussion on CSRF protection implemented by Spring Security in
            chapter 10.
             Stealing client credentials—Storing or transferring unproteccted credentials can
            create breaches that allow attackers to steal and use them.
             Replaying tokens—As you’ll learn in chapters 13 and 14, tokens are the keys we
            use within an OAuth 2 authentication and authorization architecture to access
            resources. You send these over the network, but sometimes, they might be intercepted. If intercepted,
            they are stolen and can be reused. Imagine you lose the
            key from your home’s front door. What could happen? Somebody else could
            use it to open the door as many times as they like (replay). We’ll learn in chapter 14 more about tokens and
            how to avoid token replaying.
             Token hijacking—Implies someone interferes with the authentication process
            and steals tokens that they can use to access resources. This is also a potential
            vulnerability of using refresh tokens, as these as well can be intercepted and
            used to obtain new access tokens.

!!!!!   Remember, OAuth 2 is a framework. The vulnerabilities are the result of wrongly
        implementing functionality over it. Using Spring Security already helps us mitigate
        most of those vulnerabilities in our applications. When implementing an application
        with Spring Security, as you’ll see in this chapter, we need to set the configurations,
        but we rely on the flow as implemented by Spring Security.

    Implementing a simple single sign-on application
        In this section, we implement the first application of our book that uses the OAuth 2
        framework with Spring Boot and Spring Security. This example shows you a general
        overview of how to apply OAuth 2 with Spring Security and teaches you some of the
        first contracts you need to know. A single sign-on (SSO) application is, as the name
        suggests, one in which you authenticate through an authorization server, and then the
        app keeps you logged in, using a refresh token. In our case, it represents only the client from the
        OAuth 2 architecture

        In this application (figure 12.10), we use GitHub as the authorization and resource
        servers, and we focus on the communication between the components with the authorization code grant type.
        In chapters 13 and 14, we’ll implement both an authorization server and a resource server in an OAuth 2 architecture.

        In listing 12.2, we call a new method on the HttpSecurity object: the
        oauth2Login(). But you know what’s going on. As with httpBasic() or formLogin(), oauth2Login() simply adds a
        new authentication filter to the filter chain.
        ...the filter that the framework adds to the filter chain when you call the
        oauth2Login() method is the OAuth2LoginAuthenticationFilter (figure
        12.13). This filter intercepts requests and applies the needed logic for OAuth 2
        authentication.

        We need to establish that GitHub is our authorization server. For this purpose, Spring Security
        defines the ClientRegistration contract.
        The ClientRegistration interface represents the client in the OAuth 2 architecture. For the client, you need to
        define all its needed details, among which we have:
             The client ID and secret
             The grant type used for authentication
             The redirect URI
             The scopes

!!!     Wait! Spring Security is even smarter than this. The framework defines a class named
        CommonOAuth2Provider. This class partially defines the ClientRegistration
        instances for the most common providers you can use for authentication, which
        include:
             Google
             GitHub
             Facebook
             Okta

        ClientRegistration cr =
             CommonOAuth2Provider.GITHUB
             .getBuilder("github")
             .clientId("a7553955a0c534ec5e6b")
             .clientSecret("1795b30b42. . .")
             .build();

        In this section, you learn how to register the ClientRegistration instances for
        Spring Security to use for authentication.
        For this purpose, Spring Security uses an object of type ClientRegistrationRepository.

        The authentication filter (OAuth2LoginAuthenticationFilter) obtains details about
        the authorization server client registrations from a ClientRegistrationRepository.
        A ClientRegistrationRepository has one or more ClientRegistration objects.

            Dan : see "12-14 ClientRegistrationRepository.png"

        The ClientRegistrationRepository interface is similar to the UserDetailsService interface, which you learned
        about in chapter 2. In the same way that a UserDetailsService object finds UserDetails by its username, a
        ClientRegistrationRepository object finds ClientRegistration by its registration ID.

!!!!!   In this section, I show you a third approach to configuring the application we built
        earlier in this chapter. Spring Boot is designed to use its magic and build the ClientRegistration and
        ClientRegistrationRepository objects directly from the
        properties file. This approach isn’t unusual in a Spring Boot project.
        The following code snippet shows how to set the client registration for our example in the application.properties file:
            spring.security.oauth2.client.registration.github.client-id=a7553955a0c534ec5e6b
            spring.security.oauth2.client.registration.github.client-secret=1795b30b425ebb79e424afa51913f1c724da0dbb

        In this snippet, I only need to specify the client ID and client secret. Because the name
        for the provider is github, Spring Boot knows to take all the details regarding the
        URIs from the CommonOAuth2Provider class.

            @Configuration
            public class ProjectConfig extends WebSecurityConfigurerAdapter {
                 @Override
                 protected void configure(HttpSecurity http) throws Exception {
                    http.oauth2Login();
                    http.authorizeRequests().anyRequest().authenticated();
                 }
            }

        You’re already aware that in the Spring Security architecture, it’s the SecurityContext that
        stores the details of an authenticated user. Once the authentication process ends, the
        responsible filter stores the Authentication object in the SecurityContext. The
        application can take user details from there and use them when needed. The same
        happens with an OAuth 2 authentication as well.
        The implementation of the Authentication object used by the framework is
        named OAuth2AuthenticationToken in this case. You can take it directly from the
        SecurityContext or let Spring Boot inject it for you in a parameter of the endpoint, as you learned in chapter 6.


========================================================================================================================
Chapter 13. OAuth 2: Implementing the authorization server

    In this chapter, we’ll discuss implementing an authorization server with Spring Security. As you
    learned in chapter 12, the authorization server is one of the components
    acting in the OAuth 2 architecture.

    The role of the authorization server is to authenticate the user and provide a token to the client.
    The client uses this token to access resources exposed by the resource server on behalf of the user. You
    also learned that the OAuth 2 framework defines multiple flows for obtaining a
    token. We call these flows grants. You choose one of the different grants according to
    your scenario

    The behavior of the authorization server is different depending on
    the chosen grant. In this chapter, you’ll learn how to configure an authorization
    server with Spring Security for the most common OAuth 2 grant types:
         Authorization code grant type
         Password grant type
         Client credentials grant type

    You’ll also learn to configure the authorization server to issue refresh tokens. A client
    uses refresh tokens to obtain new access tokens. If an access token expires, the client
    has to get a new one. To do so, the client has two choices: reauthenticate using the
    user credentials or use a refresh token. We discussed the advantages of using refresh
    tokens over user credentials

    For months, rumors said the authorization server development with Spring Security
    would no longer be supported (http://mng.bz/v9lm). Finally, the Spring Security
    OAuth 2 dependency was deprecated. With this action, we have alternatives (the ones
    you learn in this book) for implementing the client and the resource server, but not
    for an authorization server. Luckily, the Spring Security team announced a new authorization server is
    being developed:
        TODO https://github.com/spring-projects/spring-authorization-server     (this is a new library that was
            developed since the book came out, so it is not covered by book)

!!! Naturally, it takes time for the new Spring Security authorization server to mature (refering to the TODO from above).
    Until then, the only choice we have for developing a custom authorization server with
    Spring Security is the way we’ll implement the server in this chapter. Implementing a
    custom authorization server helps you better understand how this component works.

!!! Instead of implementing a custom authorization server, you could go with a third party tool like
    Keycloak or Okta. In chapter 18, we’ll use Keycloak in our hands-on
    example. But in my experience, sometimes stakeholders won’t accept using such a solution, and you need to
    go with implementing custom code

    Writing your own authorization server implementation
        There’s no OAuth 2 flow without an authorization server. As I said earlier, OAuth 2 is
        mainly about obtaining an access token. And the authorization server is the component of the OAuth 2
        architecture that issues access tokens

        Besides the classic @Configuration annotation, we also need to annotate this class with
        @EnableAuthorizationServer. This way, we instruct Spring Boot to enable the
        configuration specific to the OAuth 2 authorization server. We can customize this configuration by
        extending the AuthorizationServerConfigurerAdapter class and
        overriding specific methods that we’ll discuss in this chapter.

        We already have the minimal configuration for our authorization server. This is awesome! However, to make
        it usable, we still have to implement user management, register at least one client, and decide which grant
        types to support.

!!!!    The authorization server is the component that deals with authenticating a user in the OAuth 2 framework.
        So, naturally, it needs to manage users. Fortunately, the user management implementation hasn’t
        changed from what you learned in chapters 3 and 4. We continue to use the UserDetails, UserDetailsService,
        and UserDetailsManager contracts to manage credentials. And to manage passwords, we continue to use the
        PasswordEncoder contract.

!!!     Dan: see "13-2 authentication process on oauth2 auth server.png"

!!      Figure 13.2 reminds you of the main components acting in the authentication process in Spring Security.
        What you should observe differently from the way we
        described the authentication architecture until now is that we don’t have a
        SecurityContext in this diagram anymore. This change happened because the
        result of authentication is not stored in the SecurityContext. The authentication is
        instead managed with a token from a TokenStore. You’ll learn more about the
        TokenStore in chapter 14, where we discuss the resource server.

        Now that we have users, we only need to link user management to the authorization server configuration.
        To do this, I expose the AuthenticationManager as a
        bean in the Spring context, and then I use it in the AuthServerConfig class. The
        next listing shows you how to add the AuthenticationManager as a bean in the
        Spring context.

        With these configurations in place, we now have users who can authenticate at our
        authentication server. But the OAuth 2 architecture implies that users grant privileges
        to a client. It is the client that uses resources on behalf of a user

     Registering clients with the authorization server
        In this section, you learn how to make your clients known to the authorization server.
        To call the authorization server, an app acting as a client in the OAuth 2 architecture
        needs its own credentials. The authorization server also manages these credentials
        and only allows requests from known clients

        Dan : see "13-3 Authorization server stores credentials of both clients aka apps and users.png"

!!!!    Do you remember the client application we developed in chapter 12? We used
        GitHub as our authentication server. GitHub needed to know about the client app, so
        the first thing we did was register the application at GitHub. We then received a client
        ID and a client secret: the client credentials. We configured these credentials, and our
        app used them to authenticate with the authorization server (GitHub). The same
        applies in this case. Our authorization server needs to know its clients because it
        accepts requests from them. Here the process should become familiar. The contract
        that defines the client for the authorization server is ClientDetails. The contract
        defining the object to retrieve ClientDetails by their IDs is ClientDetailsService.
        Do these names sound familiar? These interfaces work like the UserDetails and
        the UserDetailsService interfaces, but these represent the clients

     Using the password grant type
        In this section, we use the authorization server with the OAuth 2 password grant. Well,
        we mainly test if it’s working, because with the implementation we did in previous sections 13.2
        and 13.3, we already have a working authorization server that uses the password grant
        type. I told you it’s easy!

    Using the authorization code grant type
        you know it’s one of the most commonly used OAuth 2 grant types.
        It’s essential to understand how to configure your authorization server to work with
        this grant type as it’s highly probable that you’ll find this requirement in a real-world
        system.

        For the authorization code grant type, you also need to provide the
        redirect URI. This is the URI to which the authorization server redirects the user once
        it completes authentication. When calling the redirect URI, the authorization server
        also provides the access code.

        In the OAuth 2 flow, the client, even if it’s an application, acts as an independent
        component having its own credentials, which it uses to identify itself. Because you
        don’t share user credentials, you shouldn’t share client credentials either. Even if all
        applications that define clients are part of the same system, nothing stops you from
        registering these as separate clients at the authorization server level. Registering clients
        individually with the authorization server brings the following benefits:
             It provides the possibility to audit events individually from each application.
            When you log events, you know which client generated them.
             It allows stronger isolation. If one pair of credentials is lost, only one client is affected.
             It allows separation of scope. You can assign different scopes (granted authorities) to a client
            that obtains the token in a specific way.

    Using the client credentials grant type
        You may remember from chapter 12 that we use this grant type for backend-to-backend
        authentications

        We might use the client credentials grant type also when we secure an endpoint that’s
        unrelated to a specific user and for which the client needs access. Let’s say you want to
        implement an endpoint that returns the status of the server. The client calls this endpoint to check the
        connectivity and eventually displays a connection status to the user
        or an error message. Because this endpoint only represents a deal between the client
        and the resource server, and is not involved with any user-specific resource, the client
        should be able to call it without needing the user to authenticate. For such a scenario,
        we use the client credentials grant type.

!!!!    Be careful with the client credentials grant type. This grant type only requires the client to use its
        credentials. Make sure that you don’t offer it access to the same scopes as
        flows that require user credentials. Otherwise, you might allow the client access to the
        users’ resources without needing the permission of the user.

    Using the refresh token grant type
        refresh tokens offer several
        advantages when used together with another grant type. You can use refresh tokens
        with the authorization code grant type and with the password grant type



========================================================================================================================
Chapter 13. What are OAuth2 and OpenID Connect ?    - this chapter is from the second edition of the book !!!

    We also discuss what OAuth 2 is as a specification and
    the difference between OpenID Connect (a protocol) and OAuth 2 (the specification
    it relies on).

!!! We classify tokens based on the way they provide the resource server with the data for
    authorization:
   	    - Opaque—Tokens which don’t store data. To implement the authorization, the
            resource server usually needs to call the authorization server, provide the opaque
            token, and get the details. This call is known as the introspection call.
        - Non-opaque—Tokens that store data, making it immediately possible for the backend to implement the
            authorization. The JSON Web Token (JWT) is the most used non-opaque token implementation.

    Using opaque tokens
        Opaque tokens don’t contain data the backend can use to identify either the user or
        the client, or to implement the authorization rules. Opaque tokens are just proof of
        an authentication attempt. When a resource server receives an opaque token, it needs
        to call the authorization server to find out whether the token is valid and to get more
        information to allow it to apply authorization constraints

!!!     An opaque token is literally like a key to a treasure chest. It doesn’t provide any information up front;
        you know it works only when you try opening the chest with it. Once
        you find out it’s valid, it also gets you to what’s inside the chest (in this case, the user and
        client details)

!!      The resource server calls an endpoint provided by the authorization server to find
        out whether the opaque token is valid and obtain the needed details about the client
        and the user to whom the token was issued. This call is named a token introspection
        (figure 13.6). Once the resource server has these details, it can apply the authorization
        constraints

    Using non-opaque tokens
        non-opaque tokens contain
        information about the client and the user to whom the authorization server issued the
        tokens during the authentication process

        The most common implementation of a non-opaque token is the JWT. A JWT is composed of three parts
            Dan: i have this described already in my notes from the first edition of the book

!!!     You may be asking yourself now, “When should I use opaque tokens, and when should
        I use non-opaque ones?” As I told you a bit earlier in this section, non-opaque tokens
        are the most frequently used today because they don’t require introspection to validate
        them. However, non-opaque tokens contain data, and the client sends this data over
        the wire to its backend. Anyone obtaining the token can also see the data the token
        carries. In the majority of cases, this is not a problem. And I recommend anyone avoid
        sending too much data within the token.
        But what should you do if you have a larger amount of data or data that is unsafe to
        send over the wire carried within a token? In such a case, opaque tokens might be a
        good alternative. I recommend you first consider non-opaque tokens and fall back to
        opaque ones only if the amount of data to be carried by the token is too large, or you
        need to send details that are more sensitive, and you want to avoid exchanging them
        through the token.

        You might still find apps implementing two other grant types: the implicit
        and the password grant type. These two grant types became deprecated because
        they were found to not be secure enough. We won’t discuss them in this book; I
        don’t recommend using them in apps. You can always replace either with one of
        the other grant types discussed in this section. If you want to learn more about
        the password grant type, there is a good discussion about it in chapter 12 of the
        first edition of this book. We also go quickly over the implicit grant type and why
        it’s deprecated when discussing the authorization code grant type in this section

        we discuss an addition to the authorization code grant type—the proof key for code exchange
        (PKCE)      Dan: this is new for the 2nd edition of the book

        Applying PKCE protection to the authorization code grant type
            What if a bad-intentioned individual manages to get the client credentials as well? In
            this case, they could obtain an access token and send requests to the resource server.
            Is there a way in which we can prevent something like this from happening? Yes, the
            proof key for code exchange (PKCE, usually pronounced “pixy”) is an enhancement
            added to the authorization code flow to make it more secure. In this section, we discuss
            how PKCE covers the case where someone could get an access token by stealing the
            client credentials.

            Using PKCE only affects two of the steps of the authorization code grant type.

            Dan: see "13-11 2nd book edition - PKCE.png"

            These two are the steps of the authorization code grant type where PKCE
            is applied:
                1 First, the client needs to generate a random value. This value can be a random
                string of bytes. This value is called the verifier.
                2 Second, the client will apply a hash function over the randomly generated value
                at step 1. A hash function is encryption characterized by the fact that the output
                cannot be turned back to the input (chapter 4). The result of applying the hash
                function over the verifier is called the challenge.

!!!!        The client sends the challenge in step 3 with the user login. The authorization server
            keeps the challenge and expects the verifier with the request made at step 5 to get
            the access token. If the verifier the client sends when requesting the token at step 5
            matches the challenge they sent at step 3, then the authorization server knows the client app that
            requests the token is the same one that requests the user to authenticate.

            Someone cannot get an access token now even if they somehow manage to get the
            authorization code at step 4. This is because they would need to know the verifier value
            as well. They can’t know the verifier because the client has not yet sent it on the wire.
            And they can’t get the verifier simply by intercepting the challenge (at step 3) because
            the challenge is created with a hash function, implying that the output can’t be turned
            back into the input

    What OpenID Connect brings to OAuth 2           Dan: this is new for the 2nd edition of the book
        There’s certainly still a lot of confusion out there about OpenID Connect (sometimes
        named OIDC) and OAuth 2 and the differences between the two. I usually tell my students to stress less
        about this subject: “If you understand OAuth 2, you also know how to use OpenID Connect.”

        In fact, OIDC is a protocol built over the OAuth 2 specification. For this reason,
        understanding OAuth 2 helps you easily get OIDC. Let me give you an analogy for specifications versus protocols.
        We all use electrical sockets every day. Electrical sockets look different around the
        world. Sometimes, this is a real pain when you travel. You may need to have adapters to
        ensure you can charge your devices, especially if you travel between different geographical regions.
        But behind the scenes, all outlets work the same way. There are some wires that output the electrical
        voltage. You can define a framework on which all the electrical sockets
        in the world work in only a couple of bullet points:
            ¡	An electrical socket has three wires that allow electrical current to flow: the
            phase, the null, and a grounding. The grounding is optional.
            ¡	The electrical socket provides a voltage that can be either around 120 Volts or 230 Volts.
        Now, no worries if you’re not a technical person; you don’t need to understand these
        two bullets. At least not for learning Spring Security. Just take my word for it.
        The problem is that even if all sockets in the world fulfill these specifications, we
        still get situations where we need adapters to travel. The reason is that they don’t have
        a common protocol. Adapters are required to adapt the outlet from one protocol to
        another (for example, North America to Europe).

        The same happens with apps and authentication and authorization. If two apps fulfill the OAuth 2
        specification, they can still run in situations where they are not fully
!!!!!   compatible and need to be adapted because they don’t run the same protocol. OpenID
        Connect is a protocol that restricts a bit the liberty of the OAuth 2 specification, introducing a few
        changes. The major changes are
            -	Specific values for the scopes (such as profile or openid).
            -	The use of an extra token named ID token, used to store the details about the
            identity of the user and client to whom the token was issued.
            -	Usually the term grant type is also referred to as flow when discussing it in terms of
            OIDC, while the authorization server is commonly called the identity provider or IdP


========================================================================================================================
Chapter 14. Implementing and OAuth2 Authorization Server     - this chapter is from the second edition of the book !!!

    The Spring ecosystem offers a fully customizable way to implement an OAuth 2/
    OpenID Connect authorization server. The Spring Security authorization server is
    the de facto way to implement an authorization server using Spring today. In this
    chapter, we’ll review the main capabilities offered by this framework and implement
    a custom authorization server.

    We start by implementing a simple example in section 14.1, which uses the default configurations. The default
    configuration implies that the authorization server will issue
    non-opaque tokens. In section 14.2, we prove that our implementation works with the
    authorization code grant type, and then, in section 14.3, we demonstrate the client
    credentials grant type as well. In section 14.4, we continue with configuring the authorization server to work
    with opaque tokens and introspection. We end this chapter’s
    discussion in section 14.5 with token revocation.

!!  Before we start, I’d like to make you aware that the way to implement an authorization server with Spring
    Security is entirely different from that in the past years. In this
    chapter, we discuss the new approach, but you might also need to know how to implement an authorization server
    using an older way (for example, if you need to work on
    an existing app that hasn’t been upgraded). In that case, I recommend reading chapter
    13 of the book’s first edition.

    Implementing basic authentication using JSON web tokens
!!!!   The main components you need to set up for your authorization server to work properly are
            1 The configuration filter for protocol endpoints—Helps you define configurations specific to the
                authorization server capabilities, including various customizations
            2 The authentication configuration filter—Similar to any web application secured with
                Spring Security, you’ll use this filter to define the authentication and authorization configurations
                and configurations to any other security mechanisms such as
                cross-origin resource sharing (CORS) and cross-site request forgery (CSRF) (see
                chapters 2 through 10).
            3 The user details management components—Like any authentication process implemented with Spring Security,
            these are established through a UserDetailsService bean and a PasswordEncoder. They work as discussed in
            chapters 3 and 4.
            4 The client details management—The authorization server uses a component called
                RegisteredClientRepository to manage the client credentials and other details.
            5 The key-pairs (used to sign and validate tokens) management—When using non-opaque
                tokens, the authorization server uses a private key to sign the tokens. The authorization server also
                offers access to a public key that the resource server can use
                to validate the tokens. The authorization server manages the private–public key
                pairs through a “key source” component.
            6 The general app settings—A component named AuthorizationServerSettings
                helps you configure generic customizations such as the endpoints the app exposes

        The applyDefaultSecurity() method is a utility method we use to
        define a minimal set of configurations you can override later if needed. After calling
        this method, the listing shows how to enable the OpenID Connect protocol using the
        oidc() method of the OAuth2AuthorizationServerConfigurer configurer object.

        specifies the authentication page to which
        the app needs to redirect the user when asked to log in. We need this configuration
        because we expect to enable the authorization code grant type for our example, which
        implies that the users must authenticate

        The details we specified when creating the RegisteredClient instance are the
        following:
            ¡	A unique internal ID—Value that uniquely identifies the client and only has a purpose in the
                internal app processes.
            ¡	A client ID—An external client identifier, similar to what a username is for the user.
            ¡	A client secret—Similar to what a password is for a user.
            ¡	The client authentication method—Tells how the authorization server expects the
                client to authenticate when sending requests for access tokens.
            ¡	Authorization grant type—A grant type allowed by the authorization server for this
                client. A client might use multiple grant types.
            ¡	Redirect URI—One of the URI addresses the authorization server allows the client
                to request a redirect for providing the authorization code in case of the authorization code grant type.
            ¡	A scope—Defines a purpose for the request of an access token. The scope can be
                used later in authorization rules

!!!!    Besides having user and client details, you must configure key pair management
        if the authorization server uses non-opaque tokens. For
        non-opaque tokens, the authorization server uses private keys to sign the tokens and
        provides the clients with public keys they can use to validate the tokens’ authenticity.
        The JWKSource is the object providing key management for the Spring Security
        authorization server. Listing 14.5 shows how to configure a JWKSource in the app’s context. For this example,
        I create a key pair programmatically and add it to the set of keys
        the authorization server can use. In a real-world app, the app would read the keys from
        a location where they’re safely stored (such as a vault configured in the environment).

        Finally, the last component we need to add to our minimal configuration is an
        AuthorizationServerSettings object (listing 14.6). This object allows you to customize all the endpoints
        paths that the authorization server exposes. If you create the
        object as shown in the next listing, the endpoints paths will get some defaults that we’ll
        analyze later in this section

        In the example we worked on in this section, I used the authorization code with PKCE.
        In the authorization and token requests, I used a challenge and a verifier value I had
        previously generated. I didn’t pay too much attention to these values because they are
        the client’s business and not something the authorization or resource server generates.
        In a real-world app, your JavaScript or mobile app will have to generate both values when
        using them in the OAuth 2 flow.
        But in case you’re wondering, I will explain how I generated these two values in this sidebar. You find
        this example in project ssia-ch14-ex2.
        The code verifier is a random 32-byte piece of data. To make it easy to transfer through a
        HTTP request, this data needs to be Base64 encoded using an URL encoder and without
        padding. The next code snippet shows how to do that in Java:

        SecureRandom secureRandom = new SecureRandom();
        byte [] code = new byte[32];
        secureRandom.nextBytes(code);
        String codeVerifier = Base64.getUrlEncoder()
         .withoutPadding()
         .encodeToString(code);
        Once you have the code verifier, you use a hash function to generate the challenge. The
        next code snippet shows how to create the challenge using the SHA-256 hash function.
        As with the verifier, you need to use Base64 to change the byte array into a String value,
        making it easier to transfer through the HTTP request:
        MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
        byte [] digested = messageDigest.digest(verifier.getBytes());
        String codeChallenge = Base64.getUrlEncoder()
         .withoutPadding()
         .encodeToString(digested);
        Now you have a verifier and a challenge. You can use them in the authorization and token
        requests as discussed in this section.

    Using opaque tokens and introspection
        By now in this chapter, we have demonstrated the authorization code grant type (section 14.2) and the
        client credentials grant type (section 14.3). With both, we managed
        to configure clients that can get non-opaque access tokens. However, you can also easily configure the
        clients to use opaque tokens. In this section, I’ll show you how to
        configure the registered clients to get opaque tokens and how the authorization server
        helps with validating the opaque tokens

        As an opaque token doesn’t contain data, how can someone validate it and get more
        details about the client (and potentially the user) for whom the authorization server
        generated it? The easiest (and most used) way is to directly ask the authorization server.
        The authorization server exposes an endpoint where one can send a request with the
        token. The authorization server replies with the needed details about the token. This
        process is called introspection

        When the token is valid, its status appears as "active", and the response
        provides all the details the authorization server has about the token:
            {
             "active": true,
             "sub": "client",
             "aud": [
             "client"
             ],
             "nbf": 1682941720,
             "scope": "CUSTOM",
             "iss": "http://localhost:8080",
             "exp": 1682942020,
             "iat": 1682941720,
             "jti": "ff14b844-1627-4567-8657-bba04cac0370",
             "client_id": "client",
             "token_type": "Bearer"
            }
        If the token doesn’t exist or has expired, its active status is false, as shown in the next
        snippet:
            {
             "active": false,
            }

    Revoking tokens
        Suppose you discover a token has been stolen. How could you make a token invalid for
        use? Token revocation is a way to invalidate a token the authorization server previously
        issued. Normally, an access token lifespan is short, so stealing a token still makes it difficult for
        one to use it. But sometimes you want to be extra cautious

        Once you send the request, the token cannot be used anymore:
        curl -X POST 'http://localhost:8080/oauth2/revoke?token=N7BruErWm-44-…' --header 'Authorization: Basic Y2xpZW50OnNlY3JldA=='


========================================================================================================================
Chapter 15. Implementing and OAuth2 Resource Server     - this chapter is from the second edition of the book !!!

    This chapter discusses securing a backend application in an OAuth 2 system. What
    we call a resource server in OAuth 2 terminology is simply a backend service. While
    in chapter 14 you learned how to implement the authorization server responsibility
    using Spring Security, it’s now time to discuss how to use the token the authorization
    server generates.

    In real-world scenarios, you might or might not implement a custom authorization server like we did in chapter
    14. Your organization might use a third-party implementation instead of creating custom software. You can find
    many alternatives out there, ranging from open-source solutions such as Keycloak to enterprise products
    such as Okta, Cognito, or Azure AD. An example with Keycloak is available in chapter 18 of the book’s first edition.

!!! While you have options to configure an authorization server without needing to
    implement your own, you’ll have to implement the authentication and authorization
    on your backend properly. For that reason, I think this chapter is essential; the skills you
    learn by reading it have a high probability of helping you with your work.

    Configuring JWT validation
!!!     In this section, we discuss configuring a resource server to validate and use JWTs, which
        are non-opaque tokens (they contain data the resource server uses for authorization).
        To use JWTs, the resource server will need to prove they are authentic, meaning that
        the expected authorization server has indeed issued them as a proof of authentication
        of a user and/or a client. Second, the resource server will need to read the data in the
        token and use it to implement authorization rules.

        Here’re the steps we’ll follow:
            1 Add the needed dependencies to the project (in the pom.xml file since we use Maven).
            2 Declare a dummy endpoint that we’ll use to test our implementation.
            3 Implement authentication for JWTs by configuring the service with the public key set URI.
            4 Implement the authorization rules.
            5 Test the implementation by:
                a Generating a token with the authorization server.
                b Using the token to call the dummy endpoint we created in step 2.

!!!     You need this link to get information about the URL that the authorization server
        exposes to provide the public key set that the resource server can use to validate tokens.
        The resource server needs to call this endpoint and get the set of public keys. Then the
        resource server uses one of these keys to validate the access token’s signature
            Dan: see "15-2 2nd book edition - resource server calling auth server.png"

        "jwks_uri": "http://localhost:8080/oauth2/jwks"
            The key set endpoint provides the public parts of the asynchronous
            key pairs configured on the authorization server side. The
            authorization server uses the private parts to sign the tokens. The
            resource server can use the public parts to validate them

        To configure the public key set URI, we’ll first declare it in the project’s application
        .properties file. The configuration class can inject it into an attribute field and then use
        it to configure the resource server authentication:
            keySetURI=http://localhost:8080/oauth2/jwks

!!!!    To configure the authentication, we’ll use the oauth2ResourceServer() method of
        the HttpSecurity object. This method is similar to httpBasic() and formLogin(),
        which we used in the second and third parts of this book.
        Similar to httpBasic() and formLogin(), you need to provide an implementation of the Customizer interface
        to configure the authentication. In listing 15.5, you
        can observe how I used the jwt() method of the Customizer object to configure JWT
        authentication. Then I used a Customizer on the jwt() method to configure the public key set URI (using
        the jwkSetUri() method)

        Remember to make the endpoints require authentication. By default, the endpoints
        aren’t protected, so to test the authentication, you first need to ensure your /demo
        endpoint requires authentication.
            http.authorizeHttpRequests(
                c -> c.anyRequest().authenticated()
            );

        Observe that the access token must be sent in the Authorization header
        using the Bearer prefix (figure 15.4). The Bearer prefix implies that the one having
        the access token value can use it in the same way as any other party having it.
            Dan: (more info "Bearer is used in authorization tokens to distinguish it from other types of
                authentication, such as Basic, Digest, and several others.
                The Authorization: <type> <credentials> syntax was first described in the HTTP 1.0 spec, long before
                the concept of a Bearer token was introduced in the OAuth 2.0 authorization standard.")

        The following snippet shows the cURL command you can use to send a request to the
        /demo endpoint using the access token from the authorization server:
        curl 'http://localhost:9090/demo' \
        --header 'Authorization: Bearer eyJraW…'

    Using customized JWTs
        Systems’ needs are different from one another, even regarding authentication and
        authorization. Often, it happens that you need to transfer custom values between the
        authorization server and the resource server through the access token. The resource
        server can use such values to apply various authorization rules

        In this section, we’ll implement an example where the authorization and resource
        servers use custom claims in the access token. The authorization server customizes the
        JWT adding a claim named "priority" in the JWT. The resource server reads the
        "priority" claim and adds its value to the authentication instance in the security context. From there,
        the resource server can use it when implementing any authorization rule.
        We’ll follow these steps:
            1 Change the authorization server to add the custom claim to the access token.
            2 Change the resource server to read the custom claim and store it in the security context.
            3 Implement an authorization rule that uses the custom claim

        We need to add a custom value in the access token’s body to the
        SecurityConfig class. In the authorization server, you do this by adding a bean of
        type OAuth2TokenCustomizer. The next code snippet demonstrates such a bean’s
        definition. To simplify things and allow you to focus on the example, I added a dummy
        value in a field I named "priority". In real-world apps, such custom fields would
        have a purpose, and you’d potentially have to write certain logic for setting their value:
            @Bean
            public OAuth2TokenCustomizer<JwtEncodingContext> jwtCustomizer() {
             return context -> {
                JwtClaimsSet.Builder claims = context.getClaims();
                claims.claim("priority", "HIGH");
             };
            }

        The list of steps we need to follow to make our resource server understand the custom claims in the access
        token is the following:
            1 Create a custom authentication object. This object will define the new shape, including the custom data.
            2 Create a JWT authentication converter object. This object will define the logic
                for translating the JWT into the custom authentication object.
            3 Configure the JWT authentication converter you created in step 2 to be used by
                the authentication mechanism.
            4 Change the /demo endpoint to return the authentication object from the security context.
            5 Test the endpoint, and check that the authentication object contains the custom
            "priority" field.

        You may also observe in listing 15.9 that I have defined a dummy authority. In a real
        scenario, you’d either take these from the access token (considering they’re managed
        at the authorization server level), or from a database or other third-party system (considering they’re
        managed from a business perspective). In this case, I simplified the
        example and added a dummy "read" authority for all requests. But it’s important to
        remember that this is also the place where you’d deal with authorities (which should
        also end up in the authentication object from the security context, as they’re essential
        details for authorization rules in most cases).

            Dan: see "15-5 2nd book edition - custom converter to put information from the access token into our authentication object.png"

    Configuring token validation through introspection
        In this section, we discuss using introspection for access token validation. If your app uses
        opaque tokens, or if you want a system where you can revoke tokens at the authorization
        server level, then introspection is the process you must use for token validation

        Token introspection. In situations where the resource server cannot depend on signaturebased validation of
        access tokens (such as when token revocation is necessary), or when the token
        does not contain detailed information (as with opaque tokens), the resource server is required to make
        inquiries to the authorization server. This is done to ascertain the validity of a token and to gather
        additional information about it.

        We’ll implement a resource server to demonstrate the use of introspection. To achieve
        our goal, we must follow these steps:
            1 Ensure the authorization server recognizes the resource server as a client. The
            resource server needs client credentials registered on the authorization server side.
            2 Configure authentication on the resource server side to use introspection.
            3 Obtain an access token from the authorization server.
            4 Use a demo endpoint to prove that the configuration works the way we expect
            with the access token we got in step 3

        The next code snippet shows you an example of creating a client instance, which we’ll
        register at the authorization server side. This client represents our resource server. As
        you observe from figure 15.6, the resource server sends requests to the authorization
        server (for introspection), so this way, it also becomes a client of the authorization
        server.

    Implementing multitenant systems
        In real-world apps, things aren’t always perfect. Sometimes we’re in a situation where
        we must adapt our implementation to match some nonstandard case when integrating
        with a third party. Also, sometimes we need to implement backends that rely on multiple authorization
        servers for authentication and authorization (multitenant systems).
        How should we implement our apps’ configurations in such cases?

        Fortunately, Spring Security offers flexibility for implementing any scenario. In
        this section, we discuss implementing resource server configurations for more complex cases, such as
        multitenant systems or interacting with apps that don’t follow the standards.

        Why is it important to remember the Spring Security’s authentication design? Because for the resource server,
        like any other authentication approach, you need to change the authentication provider if you
        want to customize how the authentication works.
        In the case of a resource server, Spring Security allows you to plug into the configuration a
        component named the authentication manager resolver (figure 15.8). This
        component allows the app execution to decide which authentication manager to call.
        This way, you can delegate the authentication to any custom authentication manager
        that can use a custom authentication provider.
            Dan: see "15-8 2nd book edition-authentication manager resolver.png"

        If you want your app to use multiple authorization servers all using JWTs, Spring
        Security even provides an out-of-the-box authentication manager resolver implementation (figure 15.9).
        For such a case, you only need to plug in the JwtIssuerAuthenticationManagerResolver custom implementation
        that Spring Security provides.

        Dan: i moved fast through this subchapter as these are details that you don't come across often


========================================================================================================================
Chapter 16. Implementing an OAuth2 client - - this chapter is from the second edition of the book !!!

!!! Often, it is necessary to implement communication between backend applications,
    especially for backend apps involving multiple services. In such cases, when systems
    have authentication and authorization built over OAuth 2, it’s recommended that
    you authenticate calls between apps using the same approach. While developers use
    HTTP Basic and API Key authentication methods (chapter 6) for simplicity in some
    cases to keep the system consistent and more secure, using the OAuth 2 client credentials grant type is the
    preferred option

    We’ll discuss how to use Spring Security to implement an OAuth 2 client and when and how a backend app
    becomes a client in an OAuth 2 system.

    In the current chapter, we’ll solve the problem of implementing the communication between
    two backend apps, making one of them an actual OAuth 2 client. In such a case, we
    need to use Spring Security to build an OAuth 2 client.
        Dan: see "16-2 2nd book edition - backend app becomes client for another backend app.png"

    Implementing OAuth 2 login
        We’ll begin with a classic case (which you can use with most
        well-known providers such as Google, GitHub, Facebook, and Okta).

        Implementing authentication with a common provider
            You’ll recognize a new dependency we haven’t used in previous chapters: the OAuth 2 client
            dependency

            Listing 16.2 presents the configuration for OAuth 2 login as an authentication method
            for the web app. Configuring the app in such a way will automatically follow the authorization code
            grant type redirecting the user to log in on a specific authorization server
            and redirecting it back once the authentication succeeds. This process follows precisely what we
            discussed in chapters 13 through 15 and demonstrated multiple times in these chapters using cURL.

            I bet you are thinking, Shouldn’t we still have to fill in all those details we learned in
            chapters 13 through 15, such as the authorization URL, token URL, client ID, client
            secret, and so on? Yes, all these details are needed. Fortunately, Spring Security can
            help you again. If your app uses one of the providers Spring Security considers to be
            well known, most of these details are prefilled. You only need to configure the app’s
            client credentials. Spring Security considers the following providers as well known:
                ¡	Google
                ¡	GitHub
                ¡	Okta
                ¡	Facebook

            I implied here that you have registered your app in the Google Developer Console—
            that’s where you get your app’s unique set of credentials from. If you haven’t done this
            before, and you want to configure authentication using Google for your app, you can
            find Google’s detailed documentation on how to register your OAuth 2 app with Google at
            http://mng.bz/eEvz.

        Giving the user more possibilities
            I’m sure you’ve surfed the internet enough by now to observe that many apps offer
            more than one way for the user to log in. Sometimes you can even choose among four
            or five providers to log into an app. This approach is advantageous because not all of
            us already have an account with a social network. Some have a Facebook account, but
            others prefer to use LinkedIn. Some developers prefer to log in using their GitHub
            account, but others use their Gmail address

            Before asking you to authenticate, the app gives you two login options: the ones we
            previously configured (figure 16.4). You must choose either Google or GitHub to log
            in. After you choose your preferred provider, the app redirects you to that provider’s
            specific authentication page

        Using a custom authorization server
            You might want to use a custom authorization server you built, as you learned in chapter 14.
            You can configure an OAuth 2 login with any provider, including a custom one
            you built. In this section, we’re going to use an authorization server we built in chapter 14 to show
            the configuration of a custom OAuth 2 login

            We only need to ensure that our client configuration matches what we want to implement in this chapter.
            Listing 16.2 shows the registered client configured in our authorization server. The most important
            thing here is to make sure that the redirect URI
            matches the one we expect for our application for which we’ll implement the login:

            Figure 16.5 analyzes the anatomy of the redirect URI. Observe that the standard
            redirect URI uses the /login/oauth2/code path followed by the name of the authorization server.
            In this example, the name I gave to the authorization server is
            my_authorization_server.

            We run both apps, the authorization server and the web app we use on the
            local system. Running these apps on the same system and accessing them from the
            browser may cause problems with the cookies the browser uses to store the user’s
            session. For this reason, I recommend you use the IP address "127.0.0.1" to refer
            to one app and the DNS name "localhost" to refer to the other. Even if the two
            are identical from a networking point of view and they refer to the same system (the
            local system), they will be considered different by the browser, which will in this way
            be able to manage the sessions correctly. In this example, I use "127.0.0.1" to
            refer to the authorization server and "localhost" for the web app

        Adding flexibility to your configurations
            Often, we need to have more flexibility than the properties files offer us. Sometimes,
            we need to be able to dynamically change the credentials without redeploying the app.
            In other cases, we want to turn specific providers on or off or even offer access to these
            based on given logic. For such cases, adding the credentials in the properties file and
            allowing Spring Boot to do the magic for us doesn’t work anymore.
            However, if you know what happens behind the scenes, you can customize the provider’s details as you wish.
            The only two types you must remember are:
                ¡	ClientRegistration—This object is used to define the details the client needs
                to use the authorization server (credentials, redirect URI, authorization URI, etc.).
                ¡	ClientRegistrationRepository—This contract is implemented to define the
                logic that retrieves the client registrations. You, for example, can implement a
                client registration repository

            In this example, I do three things:
                1 Inject the credentials values from the properties file
                2 Create a ClientRegistration object with all the needed details
                3 Configure it in an in-memory ClientRegistrationRepository implementation

    Implementing an OAuth 2 client
        This section discusses implementing a service as an OAuth 2 client. In service-oriented
        systems, apps often communicate with one another. In such cases, the app sending
        the request to another app becomes a client of that particular app. In most cases, if we
        decide to implement authentication for the requests over OAuth 2, the app uses the
        client credentials grant type to obtain an access token.

        The client credentials grant type doesn’t imply a user. For this reason, you won’t
        need a redirect URI and an authorization URI. The client credentials are enough to
        allow a client to authenticate and obtain an access token by sending a request to the
        token URI

        We’ll build an app that uses
        the client credentials grant type to get an access token from an authorization server.
        This app will get an access token from an authorization server. To simplify the example, we’ll only
        discuss retrieving the access token.

        So what we’ll precisely do in this example is configure an app to retrieve an access
        token from an OAuth 2 authorization server using the client credentials grant type. To
        prove that we correctly retrieved the access token, we’ll return it in the response body of
        a demo endpoint.

        We’ll use the same authorization server you built in chapter 14

        Similarly to other authentication methods, Spring Security offers a method of
        the HttpSecurity object to configure an app as an OAuth 2 client. Call the
        oauth2Client() method presented in the following listing to configure the app as an
        OAuth 2 client.

        The app also needs to know some details to send the authorization server the requests
        for access tokens. As you learned in section 16.1, we provide these details using a
        ClientRegistrationRepository component.
        However, because I don’t use a common provider, I had to specify more details, such
        as the scope, the token URI, and the authentication method. Observe that I configured
        client credentials as a grant type.

        Dan: see "16-10 2nd book edition - how ClientManager is used.png"

        The client manager is the Spring Security component responsible for connecting to the authorization server and
        properly using the grant type to get the access token.

        You can now use the client manager wherever you need to get an access token. As
        shown in figure 16.10, I made the controller use the client manager directly to simplify
        this example and allow you to focus on the discussion about implementing an OAuth 2
        client. Remember that a real-world app would probably be more complex. In a design
        that correctly segregates the object’s responsibilities, the client manager would likely
        be used by a proxy object and not directly by a controller

!!!!!   Dan: "16-11 2nd book edition - very nice diagram of how ClientManager would be used in a production app .png"


========================================================================================================================
Chapter 16. Global method security: Pre- and postauthorizations

    But in terms of authorization, we only discussed configuration at the endpoint
    level. Suppose your app is not a web application—can’t you use Spring Security for
    authentication and authorization as well? Spring Security is a good fit for scenarios
    in which your app isn’t used via HTTP endpoints. In this chapter, you’ll learn how
    to configure authorization at the method level. We’ll use this approach to configure authorization in both web
    and non-web applications, and we’ll call it global method security

!!! Global method security enables you to apply authorization rules at any layer of your
    application. This approach allows you to be more granular and to apply authorization rules at a specifically
    chosen level.

    Enabling global method security
!!!     By default, global method security is disabled, so if you want to use this functionality, you first need
        to enable it. Also, global method security offers multiple approaches
        for applying authorization

!!      Briefly, you can do two main things with global method security:
             Call authorization—Decides whether someone can call a method according to
            some implemented privilege rules (preauthorization) or if someone can access
            what the method returns after the method executes (postauthorization).
             Filtering—Decides what a method can receive through its parameters (prefiltering) and
            what the caller can receive back from the method after the method executes (postfiltering).

        Understanding call authorization
            The call authorization approach refers to applying authorization rules that decide if a method can be
            called, or that allow the method to be called and then decide if the caller can access the value returned
            by the method. Often we need to decide if someone can access a piece of logic depending
            on either the provided parameters or its result. So let’s discuss call authorization and
            then apply it to some examples

            When we enable global method security in our application,
            we actually enable a Spring aspect. This aspect intercepts the calls to the method for
            which we apply authorization rules and, based on these authorization rules, decides
            whether to forward the call to the intercepted method

            Dan : see "16-2 Global security method aspect.png"

            Briefly, we classify the call authorization as
                 Preauthorization—The framework checks the authorization rules before the method call.
                 Postauthorization—The framework checks the authorization rules after the method executes.

            Say we have a method findDocumentsByUser(String username) that returns to
            the caller documents for a specific user. The caller provides through the method’s
            parameters the user’s name for which the method retrieves the documents. Assume
            you need to make sure that the authenticated user can only obtain their own documents. Can we apply a
            rule to this method such that only the method calls that receive
            the username of the authenticated user as a parameter are allowed? Yes! This is something we do with
            preauthorization

            If the caller doesn’t have the permissions according to the authorization
            rules that we define, the framework doesn’t delegate the call to the method. Instead,
            the framework throws an exception. This is by far the most often used approach to
            global method security

            When we apply authorization rules that allow someone to call a method but not necessarily to obtain the
            result returned by the method, we’re using postauthorization. With postauthorization, Spring Security
            checks the authorization rules after the
            method executes. You can use this kind of authorization to restrict access to the method
            return in certain conditions. Because postauthorization happens after method execution, you can apply the
            authorization rules on the result returned by the method
            After the
            protected method finishes execution, the aspect checks the authorization rules. If the rules aren’t
            respected, instead of returning the result to the caller, the aspect throws an exception.

!!!!        But be careful with postauthorization! If the method
            mutates something during its execution, the change happens whether or not authorization succeeds in the end.
            NOTE Even with the @Transactional annotation, a change isn’t rolled
            back if postauthorization fails. The exception thrown by the postauthorization functionality happens
            after the transaction manager commits the transaction.

        Enabling global method security in your project
            enabling this functionality is straightforward. You do this by simply using the
            @EnableGlobalMethodSecurity annotation on the configuration class.

!!!!!       Global method security offers us three approaches to define the authorization rules that we discuss in
            this chapter:
                 The pre-/postauthorization annotations        To enable this approach, we use the  prePostEnabled attribute of the @EnableGlobalMethodSecurity annotation
                 The JSR 250 annotation, @RolesAllowed
                 The @Secured annotation

    Applying preauthorization for authorities and roles
        To define the authorization rule for this method, we use the @PreAuthorize annotation. The @PreAuthorize
        annotation receives as a value a Spring Expression Language (SpEL) expression that describes the
        authorization rule. In this example, we apply a simple rule.

             @PreAuthorize("hasAuthority('write')")
             public String getName() {
                return "Fantastico";
             }

        You learned about the hasAuthority() method in chapter
        7, where we discussed applying authorization at the endpoint level.

!!!!    Similarly, you can use any other expression we discussed in chapter 7 for endpoint
        authentication. Here’s a short recap of them:
             hasAnyAuthority()—Specifies multiple authorities. The user must have at
            least one of these authorities to call the method.
             hasRole()—Specifies a role a user must have to call the method.
             hasAnyRole()—Specifies multiple roles. The user must have at least one of
            them to call the method.

        The expression we use for authorization now is #name == authentication.principal.username. In this
        expression, we use #name to refer to the value of the getSecretNames() method parameter called name, and
        we have access directly to the
        authentication object that we can use to refer to the currently authenticated user. The
        expression we use indicates that the method can be called only if the authenticated
        user’s username is the same as the value sent through the method’s parameter.

        Remember, you can apply global method security to any layer of your
        application. In the examples presented in this chapter, you find the authorization rules applied for methods
        of the service classes. But you can apply
        authorization rules with global method security in any part of your application: repositories, managers,
        proxies, and so on.

    Applying postauthorization
!!!!    It may sound a little bit awkward at the beginning: why would someone be able to execute the code but not
        get the result? Well, it’s not about the method itself, but imagine
        this method retrieves some data from a data source, say a web service or a database. You
        can be confident about what your method does, but you can’t bet on the third party
        your method calls. So you allow the method to execute, but you validate what it returns
        and, if it doesn’t meet the criteria, you don’t let the caller access the return value.

        To apply postauthorization rules with Spring Security, we use the @PostAuthorize annotation
        The annotation receives as a value the SpEL defining an authorization rule

        With postauthorization, we don’t protect the method from being called, but we protect the returned
        value from being exposed if the defined authorization rules aren’t respected.

        The scenario for our example, for which I created a project named ssia-ch16-ex3,
        defines an object Employee. Our Employee has a name, a list of books, and a list of
        authorities. We associate each Employee to a user of the application. To stay consistent with the other
        examples in this chapter, we define the same users, Emma and Natalie. We want to make sure that the caller
        of the method gets the details of the
        employee only if the employee has read authority. Because we don’t know the authorities associated with the
        employee record until we retrieve the record, we need to
        apply the authorization rules after the method execution. For this reason, we use the
        @PostAuthorize annotation.

        Observe that the expression we use with the @PostAuthorize annotation refers to the value returned by the
        method returnObject. The postauthorization expression can use the value
        returned by the method, which is available after the method executes.

        You can use both @PreAuthorize and @PostAuthorize on the
        same method if your requirements need to have both preauthorization and
        postauthorization.

    Implementing permissions for methods
!!!!    Up to now, you learned how to define rules with simple expressions for preauthorization and postauthorization.
        Now, let’s assume the authorization logic is more complex, and you cannot write it in one line.
        It’s definitely not comfortable to write huge
        SpEL expressions. I never recommend using long SpEL expressions in any situation,
        regardless if it’s an authorization rule or not. It simply creates hard-to-read code, and
        this affects the app’s maintainability. When you need to implement complex authorization rules, instead of
        writing long SpEL expressions, take the logic out in a separate
        class. Spring Security provides the concept of permission, which makes it easy to write
        the authorization rules in a separate class so that your application is easier to read and understand.

        In this scenario, you have an application managing
        documents. Any document has an owner, which is the user who created the document. To get the details of an
        existing document, a user either has to be an admin or
        they have to be the owner of the document

        It’s our duty to implement the permission logic. And we do this by writing an object
        that implements the PermissionEvaluator contract. The PermissionEvaluator
        contract provides two ways to implement the permission logic:
             By object and permission—Used in the current example, it assumes the permission
            evaluator receives two objects: one that’s subject to the authorization rule and
            one that offers extra details needed for implementing the permission logic.
             By object ID, object type, and permission—Assumes the permission evaluator
            receives an object ID, which it can use to retrieve the needed object. It also
            receives a type of object, which can be used if the same permission evaluator
            applies to multiple object types, and it needs an object offering extra details for
            evaluating the permission.

        For the current example, it’s enough to use the first method. We already have the subject, which in our
        case, is the value returned by the method. We also send the role
        name 'ROLE_admin', which, as defined by the example’s scenario, can access any document

        To make Spring Security aware of our new PermissionEvaluator implementation,
        we have to define a MethodSecurityExpressionHandler in the configuration
        class.

        In a similar manner, you can use the second PermissionEvaluator method to write
        your authorization expression. The second method refers to using an identifier and
        subject type instead of the object itself. For example, say that we want to change the
        current example to apply the authorization rules before the method is executed,
        using @PreAuthorize. In this case, we don’t have the returned object yet. But instead
        of having the object itself, we have the document’s code, which is its unique identifier.
        Listing 16.19 shows you how to change the permission evaluator class to implement

        You use the jsr250Enabled attribute to enable the
        @RolesAllowed annotation and the securedEnabled attribute to enable the
        @Secured annotation. Using these two annotations, @Secured and @RolesAllowed, is less powerful than
        using @PreAuthorize and @PostAuthorize,
        and the chances that you’ll find them in real-world scenarios are small. Even so, I’d
        like to make you aware of both, but without spending too much time on the details.

            @RolesAllowed("ROLE_ADMIN")
             public String getName() {
             return "Fantastico";
             }


========================================================================================================================
Chapter 17. Global method security: Pre- and postfiltering

!!! Suppose you don’t want to forbid the call to a method, but you want to make sure
    that the parameters sent to it follow some rules. Or, in another scenario, you want
    to make sure that after someone calls the method, the method’s caller only receives
    an authorized part of the returned value. We name such a functionality filtering,
    and we classify it in two categories:
         Prefiltering—The framework filters the values of the parameters before calling the method.
         Postfiltering—The framework filters the returned value after the method call.

    With preauthorization , if the parameter doesn’t follow the given authorization rule, the framework doesn’t call the method at all.
    With prefiltering , the method is called, but only values that follow the rules are provided to the method as parameters.

!!! Filtering works differently than call authorization. With filtering, the
    framework executes the call and doesn’t throw an exception if a parameter or
    returned value doesn’t follow an authorization rule you define. Instead, it filters out
    elements that don’t follow the conditions you specify.

!!!!!!  It’s important to mention from the beginning that you can only apply filtering to
    collections and arrays. You use prefiltering only if the method receives as a parameter
    an array or a collection of objects. The framework filters this collection or array
    according to rules you define. Same for postfiltering: you can only apply this approach
    if the method returns a collection or an array. The framework filters the value the
    method returns based on rules you specify.

    Applying prefiltering for method authorization
        Say you implement a use case where you process only specific details that are
        owned by the authenticated user. This use case can be called from multiple places.
        Still, its responsibility always states that only details of the authenticated user can be
        processed, regardless of who invokes the use case. Instead of making sure the invoker
        of the use case correctly applies the authorization rules, you make the case apply its
        own authorization rules. Of course, you might do this inside the method. But decoupling authorization logic
        from business logic enhances the maintainability of your
        code and makes it easier for others to read and understand it.

        Spring Security also implements filtering by using aspects. Aspects intercept specific method calls
        and can augment them with other instructions. For prefiltering, an aspect intercepts
        methods annotated with the @PreFilter annotation and filters the values in the collection provided as a
        parameter according to the criteria you define

!!!     you set authorization rules as the value of the @PreFilter annotation. In
        these rules, which you provide as SpEL expressions, you use filterObject to refer
        to any element inside the collection or array that you provide as a parameter to the
        method.

        The ProductService class defines the service method we protect with @PreFilter.
        You can find the ProductService class in listing 17.3. In that listing, before the
        sellProducts() method, you can observe the use of the @PreFilter annotation.
        The Spring Expression Language (SpEL) used with the annotation is filterObject
        .owner == authentication.name, which allows only values where the owner attribute of the
        Product equals the username of the logged-in user.
        On the left side of the
!!!!    equals operator in the SpEL expression; we use filterObject. With filterObject, we refer to objects
        in the list as parameters.
        Because we have a list of products, the filterObject in our case is of type Product. For this reason, we can
        refer to the product’s owner attribute.

!!!!!   What you need to be careful about is the fact that the aspect changes the given collection. In our case,
        don’t expect it to return a new List instance. In fact, it’s the same
        instance from which the aspect removed the elements that didn’t match the given criteria. This is important
        to take into consideration. You must always make sure that the
        collection instance you provide is not immutable. Providing an immutable collection
        to be processed results in an exception at execution time because the filtering aspect
        won’t be able to change the collection’s contents

    Applying postfiltering for method authorization
        Similar to prefiltering, postfiltering also relies on an aspect. This aspect allows a
        call to a method, but once the method returns, the aspect takes the returned value
        and makes sure that it follows the rules you define. As in the case of prefiltering, postfiltering
        changes a collection or an array returned by the method. You provide the criteria that the elements inside
        the returned collection should follow. The post-filter
        aspect filters from the returned collection or array those elements that don’t follow
        your rules.

        Dan: same thing as prefiltering but it is done after....i moved fast through this section

    Using filtering in Spring Data repositories
        It is pretty common to implement Spring Boot applications that use
        Spring Data as a high-level layer to connect to a database, be it SQL or NoSQL. We discuss two approaches
        for applying filtering at the repository level when using Spring Data, and we implement these with examples.
         The first approach we take is the one you learned up to now in this chapter: using
        the @PreFilter and @PostFilter annotations. The second approach we discuss is
        direct integration of the authorization rules in queries. As you’ll learn in this section,
        you need to be attentive when choosing the way you apply filtering in Spring Data
        repositories. As mentioned, we have two options:
             Using @PreFilter and @PostFilter annotations
             Directly applying filtering within queries

!!!!!   Using the @PreFilter annotation in the case of repositories is the same as applying
        this annotation at any other layer of your application. But when it comes to postfiltering, the situation
        changes. Using @PostFilter on repository methods technically
        works fine, but it’s rarely a good choice from a performance point of view.

        This approach is clearly wrong because it allows the application to
        retrieve all the records from the database and then filter the records itself. If we have
        a large number of documents, calling findAll() without pagination could directly
        lead to an OutOfMemoryError.
        Even if the number of documents isn’t big enough to
        fill the heap, it’s still less performant to filter the records in your application rather
        than retrieving at the start only what you need from the database

        At the service level, you have no other option than to filter the records in the app.
        Still, if you know from the repository level that you need to retrieve only records
        owned by the logged-in user, you should implement a query that extracts from the
        database only the required documents.


========================================================================================================================
Chapter 18. Hands-on: An OAuth 2 application

    Besides defining authorization rules at different layers of our resource server
    implementation, you’ll also learn how to use a tool named Keycloak as the authorization server for your system
    You’ll find many possible alternatives to Keycloak like Okta,
    Auth0, and LoginRadius. This chapter focuses on a scenario in which you need
    to use such a tool in the system you develop.

    Dan see "18-2 diagram of what is developed in this chapter.png"

    We start the implementations by configuring a local Keycloak instance as our
    authorization server. We then implement the resource server and set up the authorization rules using Spring
    Security. Once we have a working application, we test it by calling the endpoint with cURL.

    If you plan to use Keycloak in real-world scenarios, I recommend you first read the detailed documentation at their
    official website: https://www.keycloak.org/documentation. In chapter 9 of Enterprise Java Microservices by Ken
    Finnigan (Manning, 2018), you can also find a good discussion on securing microservices where the author uses
    Keycloak for user management

!!!!!We need to know which OAuth 2–related endpoints Keycloak exposes. You find those
    endpoints in the General section of the Realm Settings page, which is the first page
    you land on after logging in to the Administration Console.
    The OpenID Endpoint Configuration link offers you all the needed details regarding the OAuth 2
    endpoints exposed by this authorization server.
    You need these endpoints to obtain the access token and to configure the resource server

!!! In the next code snippet, I extracted a part of the OAuth 2 configuration that you find
    by clicking the OpenID Endpoint Configuration link. This configuration provides the
    token endpoint, the authorization endpoint, and the list of supported grant types.
    These details should be familiar to you, as we discussed them in chapters 12 through 15.
        {
         "issuer":
         "http://localhost:8080/auth/realms/master",
         "authorization_endpoint":
         "http://localhost:8080/auth/realms/master/
         ➥protocol/openid-connect/auth",
         "token_endpoint":
         "http://localhost:8080/auth/realms/master/
         ➥protocol/openid-connect/token",

         "jwks_uri":
        "http://localhost:8080/auth/realms/master/protocol/
        ➥openid-connect/certs",

         "grant_types_supported":[
         "authorization_code",
         "implicit",
         "refresh_token",
         "password",
         "client_credentials"
         ],
        ...
        }

!!  To test the application, we manually generate access tokens, which we use to
    call the endpoints. If you define a short lifespan for the tokens, you need to generate them more
    often, and you might get annoyed when a token expires before you can use it.
    In the Tokens tab, you can change the configuration related to the tokens issued
    by the authorization server.
    You configure a longer lifetime of the access token here: "Access token lifespan"
        Dan: i've set it to 1 hour

!!! in a production system, a token should expire within a few minutes.

    Now that we’ve installed Keycloak, set up the admin credentials, and made a few
    adjustments, we can configure the authorization server. Here’s a list of the configuration steps.
        1 Register a client for the system. An OAuth 2 system needs at least one client recognized by the authorization
            server. The client makes authentication requests for
            users. In section 18.2.1, you’ll learn how to add a new client registration.
        2 Define a client scope. The client scope identifies the purpose of the client in
            the system. We use the client scope definition to customize the access tokens
            issued by the authorization server. In section 18.2.2, you’ll learn how to add a
            client scope, and in section 18.2.4, we’ll configure it to customize the access token.
        3 Add users for our application. To call the endpoints on the resource server, we
            need users for our application. You’ll learn how to add users managed by Keycloak in section 18.2.3.
        4 Define user roles and custom access tokens. After adding users, you can issue
            access tokens for them. You’ll notice that the access tokens don’t have all the
            details we need to accomplish our scenario. You’ll learn how to configure roles
            for the users and customize the access tokens to present the details expected by
            the resource server we’ll implement using Spring Security in section 18.2.4

    Registering a client for our system
        In this section, we discuss registering a client when using Keycloak as an authorization
        server. Like in any other OAuth 2 system, we need to register the client applications at
        the authorization server level. To add a new client, we use Keycloak Administration
        Console. As presented in figure 18.9, you find a list of clients by navigating to the Clients
        tab on the left-hand menu. From here, you can also add a new client registration.

        I added a new client that I named fitnessapp. This client represents the application
        allowed to call endpoints from the resource server

    Specifying client scopes
        In this section, we define a scope for the client we registered in section 18.2.1. The client scope
        identifies the purpose of the client. We’ll also use client scope in section
        18.2.4 to customize the access token issued by Keycloak. To add a scope to the client,
        we again use the Keycloak Administration Console. As figure 18.11 presents, you find
        a list of client scopes when navigating to the Client Scopes tab from the left-hand
        menu. From here, you can also add a new client scope to the list.

        For the app that we build in this hands-on example, I added a new client scope named
        fitnessapp. When adding a new scope, also make sure that the protocol for which you
        set the client scope is openid-connect

        Once you have a client scope, you assign it to a client. In this figure, I already moved the scopes I
        need into the right-hand box named Assigned Default Client Scopes. This way, you can now use the defined scope
        with a specific client.

        (We don’t discuss using
         SAML 2.0 in this book because it’s not actively developed anymore for Spring
         Security. Also, SAML 2.0 is less frequently encountered than OAuth 2 in
         applications.)

    Adding users and obtaining access tokens
        In this section, we create and configure users for our application. Previously, we configured the client
        and its scope in sections. But besides the client
        app, we need users to authenticate and access the services offered by our resource
        server. We configure three users that we use to test our application. I
        named the users Mary, Bill, and Rachel.

        Having the users configured, you can now obtain an access token from your authorization server implemented
        with Keycloak. The next code snippet shows you how to
        obtain the token using the password grant type, to keep the example simple

        To obtain the access token, call the /token endpoint of the authorization server:
            curl -XPOST "http://localhost:8080/realms/master/protocol/openid-connect/token" -H "Content-Type: application/x-www-form-urlencoded" --data-urlencode "grant_type=password" --data-urlencode "username=rachel" --data-urlencode "password=12345" --data-urlencode "scope=fitnessapp" --data-urlencode "client_id=fitnessapp"

        You will recieve something like:
            {"access_token":"eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJSR0luY1RZbDV4Z3VVbVYtUXlQTTJIaW56eXo2Y3J4eGxUV21mVF9nLUdFIn0.eyJleHAiOjE3MTY3OTU4MDgsImlhdCI6MTcxNjc5MjIwOCwianRpIjoiYmI2NjU0NjUtZDQwZS00MWVkLWE2MTYtZDFmZWE0NzMxZTYyIiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwL3JlYWxtcy9tYXN0ZXIiLCJzdWIiOiI3ZGUyY2NjZi00YjZlLTQ5YTItYTNjZi1kNzRhMWMyYzc2N2IiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiJmaXRuZXNzYXBwIiwic2Vzc2lvbl9zdGF0ZSI6ImM2NjNhNjZhLWEyNDgtNDBmZC1hZjQ2LWE0Zjc4NWI4ZTI0YiIsInNjb3BlIjoiZml0bmVzc2FwcCIsInNpZCI6ImM2NjNhNjZhLWEyNDgtNDBmZC1hZjQ2LWE0Zjc4NWI4ZTI0YiJ9.YkFHtAbb3XrGYiDlVUMz9K4v8rGuGOdYC0lTU6yW0HRQDnl4KKLzATZAEEHKdcvdd_HlCsZ_bdXojOtXjDKd8dDTB8J6ASey5T7soabgBDTO7OgoBfMMPYjqhoCEE7DTEdNw-V0Ck02mZQVO7IPTAFIIVMaoYbGn77ELtdK3Rm1GSFh3x79XlQtxsW4aGIGMtnI3aQ7E4Ezv2bRz4VQEeDp6S-Pfgn9erDyHKzZ8UwI6aOU14Q1QwYLqtK-_XNkCmtX4jDRimU67ZU8DQlgO7Lk3HKjDkUEds3EqhSnNg5-Zd3ew2JstVGq7L3CZzWjlBPTJz1T9PjEI-5gajMhfPw",
            "expires_in":3600,
            "refresh_expires_in":1800,
            "refresh_token":"eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICI2MTViM2RiNy04MGM5LTRiZTktYjBkMi02ZmNmMzAxMjI2YWUifQ.eyJleHAiOjE3MTY3OTQwMDgsImlhdCI6MTcxNjc5MjIwOCwianRpIjoiZmM1ZjBlYzktNWY0OS00ODIxLTlhNmYtN2MzYWYzMTc0NGMwIiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwL3JlYWxtcy9tYXN0ZXIiLCJhdWQiOiJodHRwOi8vbG9jYWxob3N0OjgwODAvcmVhbG1zL21hc3RlciIsInN1YiI6IjdkZTJjY2NmLTRiNmUtNDlhMi1hM2NmLWQ3NGExYzJjNzY3YiIsInR5cCI6IlJlZnJlc2giLCJhenAiOiJmaXRuZXNzYXBwIiwic2Vzc2lvbl9zdGF0ZSI6ImM2NjNhNjZhLWEyNDgtNDBmZC1hZjQ2LWE0Zjc4NWI4ZTI0YiIsInNjb3BlIjoiZml0bmVzc2FwcCIsInNpZCI6ImM2NjNhNjZhLWEyNDgtNDBmZC1hZjQ2LWE0Zjc4NWI4ZTI0YiJ9.hmh73kwSzn5gW8g6XNqamz4vZTI5Vy9yM0Yhuf1qULc",
            "token_type":"Bearer",
            "not-before-policy":0,
            "session_state":"c663a66a-a248-40fd-af46-a4f785b8e24b",
            "scope":"fitnessapp"}

        The next code snippet presents the decoded JSON body of the JWT access token. Taking a glance at the code
        snippet, you can observe that the token doesn’t contain all
        the details we need to make our application work. The roles and username are missing.

    Defining the user roles
        Adding roles to a user is simple. The Roles tab in the left-hand menu allows you to
        find a list of all roles and add new roles, as presented in figure 18.19. I created two
        new roles, fitnessuser and fitnessadmin.

        By accessing the Roles tab in the left-hand menu, you find all the defined roles, and you
        can create new ones. You then assign them to users.
        We now assign these roles to our users. I assigned the role fitnessadmin to Mary, our
        administrator, while Bill and Rachel, who are regular users, take the role fitnessuser.
!!!!!   These role mappings appear as the user’s authorities in the access token, and you use these to implement
        authorization configurations.

!!!!!   Unfortunately, by default, these new details won’t appear in the access token. We have
        to customize the token according to the requirements of the application. We customize the token by configuring
        the client scope we created and assigned to the token in
        section 18.2.2. We need to add three more details to our tokens:
             Roles — Used to apply a part of the authorization rules at the endpoint layer according to the scenario
             Username — Filters the data when we apply the authorization rules
             Audience claim (aud) — Used by the resource server to acknowledge the requests,
            as you’ll learn in section 18.3.

        The next code snippet presents the fields that are added to the token once we finish
        setup. Then we add custom claims by defining mappers on the client scope, as figure
        18.21 presents.
            {
             // ...
             "authorities": [
             "fitnessuser"
             ],
             "aud": "fitnessapp",
             "user_name": "rachel",
             // ...
            }

        Figure 18.22 shows how to create a mapper to add the roles to the token. We add the
        roles with the authorities key in the token because this is the way the resource
        server expects it.

        To add roles in the access token, we define a mapper. When adding a mapper, we need to provide
        a name for it. We also specify the details to add to the token and the name of the claim identifying the assigned
        details.

!!!!!!  Finally, we need to specify the audience. The audience claim (aud) defines the
        intended recipient of the access token. We set up a value for this claim, and we configure the same value for
        the resource server, as you’ll learn in section 18.3. Figure 18.24
        shows you how to define the mapper so that Keycloak can add the aud claim to the JWT.
        If you obtain an access token again and decode it, you should find the authorities,
        user_name, and aud claims in the token’s body. Now we can use this JWT to authenticate and call endpoints
        exposed by the resource server.

    Implementing the resource server
        We need to choose the way the resource server validates tokens issued by the
        authorization server. We discussed three approaches in chapters 14 and 15:
             With a direct call to the authorization server
             Using a blackboarding approach
             With cryptographic signatures
!!!!    Because we already know the authorization server issues JWTs, the most comfortable
        choice is to rely on the cryptographic signature of the token. As you know from chapter 15, we need to provide
        the resource server the key to validate the signature. Fortunately, Keycloak offers an endpoint where public
        keys are exposed:
            http://localhost:8080/auth/realms/master/protocol/openid-connect/certs
        We add this URI, together with the value of the aud claim we set on the token in the
        application.properties file

        Dan see "18-27 verification of JWT signature diagram.png"

        The JWT needs to specify which key ID is used to sign the token. The resource server
        needs to find the key ID in the JWT header. If you generate a token with our resource
        server as we did in section 18.2 and decode the header of the token, you can see the
        token contains the key ID as expected.

    Testing the application
        Proving an authenticated user can only add a record for themself


========================================================================================================================
Chapter 19. Spring Security for reactive apps

    Reactive is a programming paradigm where we apply a different way of thinking
    when developing our applications. Reactive programming is a powerful way of
    developing web apps that has gained wide acceptance. I would even say that it
    became fashionable a few years ago when any important conference had at least a
    few presentations discussing reactive apps. But like any other technology in software development,
    reactive programming doesn’t represent a solution applicable to every situation.
    In some cases, a reactive approach is an excellent fit. In other cases, it might
    only complicate your life. But, in the end, the reactive approach exists because it
    addresses some limitations of imperative programming, and so is used to avoid
    such limitations

    One of these limitations involves executing large tasks that can
    somehow be fragmented. With an imperative approach, you give the application a
    task to execute, and the application has the responsibility to solve it. If the task is
    large, it might take a substantial amount of time for the application to solve it. The client who assigned the
    task needs to wait for the task to be entirely solved before receiving a response. With reactive programming,
    you can divide the task so that the app has the opportunity to approach some of the subtasks concurrently.
    This way, the client receives the processed data faster

    In this chapter, we’ll discuss implementing application-level security in reactive
    applications with Spring Security. As with any other application, security is an important aspect of
    reactive apps. But because reactive apps are designed differently, Spring
    Security has adapted the way we implement features discussed previously in this book.

    What are reactive apps?
        Because the topic of reactive applications is big, in this section I only review the main aspects of
        reactive apps as a refresher

        Figure 19.1 presents an analogy for the two programming approaches. Imagine a factory bottling milk.
        If the factory gets all the milk in the morning, and once it finishes
        the bottling, it delivers the milk, then we say it’s non-reactive (imperative). If the factory gets
        the milk throughout the day, and once it finishes bottling enough milk for an
        order, it delivers the order, then we say it’s reactive. Clearly, for the milk factory, it’s
        more advantageous to use a reactive approach rather than a non-reactive one.

        Dan: see "19-1 reactive vs non-reactive.png"

        For implementing reactive apps, the Reactive Streams specification (http://www.reactive-streams.org/)
        provides a standard way for asynchronous stream processing. One
        of the implementations of this specification is the Project Reactor, which builds the
        foundations of Spring’s reactive programming model. Project Reactor provides a
        functional API for composing Reactive Streams.

!!!!!   Next, we define a simple HelloController to hold the definition of our demo endpoint.
        Listing 19.1 shows the definition of the HelloController class. In the definition of the endpoint,
        you’ll observe I used as a return type a Mono. Mono is one of the
        essential concepts defined by a Reactor implementation. When working with Reactor,
        you often use Mono and Flux, which both define publishers (sources of data). In the
        Reactive Streams specification, a publisher is described by the Publisher interface.
        This interface describes one of the essential contracts used with Reactive Streams. The
        other contract is the Subscriber. This contract describes the component consuming the data.
         When designing an endpoint that returns something, the endpoint becomes a
        publisher, so it has to return a Publisher implementation. If using Project Reactor,
        this will be a Mono or a Flux. Mono is a publisher for a single value, while Flux is a
        publisher for multiple values

!!!!    Dan: see "19-2 publisher subscriber mono flux meanings.png"

        To make this explanation even more precise, let’s go back to the milk factory analogy.
        The milk factory is a reactive backend implementation that exposes an endpoint to
        receive the milk to be processed. This endpoint produces something (bottled milk),
        so it needs to return a Publisher. If more than one bottle of milk is requested, then
        the milk factory needs to return a Flux, which is Project Reactor’s publisher implementation that deals
        with zero or more produced values.

        You can now start and test the application. The first thing you observe by looking in
!!!!!   the app’s terminal is that Spring Boot doesn’t configure a Tomcat server anymore.
        Spring Boot used to configure a Tomcat for a web application by default, and you may
        have observed this aspect in any of the examples we previously developed in this book.
        Instead, now Spring Boot autoconfigures Netty as the default reactive web server for a
        Spring Boot project.

!!!     But why is the reactive approach different in terms of Spring Security? Behind the
        scenes, a reactive implementation uses multiple threads to solve the tasks on the
        stream. In other words, it changes the philosophy of one-thread-per-request, which we
        use for a web app designed with an imperative approach (figure 19.3). And, from
        here, more differences:
             The SecurityContext implementation doesn’t work the same way in reactive
            applications. Remember, the SecurityContext is based on a ThreadLocal,
            and now we have more than one thread per request. (We discussed this component in chapter 5.)
             Because of the SecurityContext, any authorization configuration is now
            affected. Remember that the authorization rules generally rely on the Authentication instance stored
            in the SecurityContext. So now, the security configurations applied at the endpoint layer as well as
            the global method security functionality are affected.
             The UserDetailsService, the component responsible for retrieving the user
            details, is a data source. Because of this, the user details service also needs to
            support a reactive approach.

            Fortunately, Spring Security offers support for reactive apps and covers all cases in
            which you can’t use the implementations for non-reactive apps anymore

    User management in reactive apps
        Often in applications, the way a user authenticates is based on a pair of username and
        password credentials. This approach is basic, and we discussed it, starting with the most
        straightforward application we implemented in chapter 2. But with reactive apps, the
        implementation of the component taking care of user management changes as well. In
        this section, we discuss implementing user management in a reactive app

        As its name suggests, the ReactiveUserDetailsService contract defines the user details service for a
        reactive app.
        The definition of the contract is as simple as the one for UserDetailsService.
        The ReactiveUserDetailsService defines a method used by Spring Security to
        retrieve a user by its username. The difference is that the method described by the
        ReactiveUserDetailsService directly returns a Mono<UserDetails> and not
        the UserDetails as happens for UserDetailsService

        As in the case of the UserDetailsService, you can write a custom implementation
        of the ReactiveUserDetailsService to give Spring Security a way to obtain the
        user details. To simplify this demonstration, we use an implementation provided by
        Spring Security. The MapReactiveUserDetailsService implementation stores the
        user details in memory (same as the InMemoryUserDetailsManager that you
        learned about in chapter 2).

        The main difference in the implementation
        of the ReactiveUserDetailsService is that the method returns a reactive
        Publisher object containing the UserDetails instead of the UserDetails
        instance itself.

        Spring Security offers us a different implementation of the context holder for reactive apps,
        ReactiveSecurityContextHolder. We use this to work with the SecurityContext in a reactive app.
        So we still have the SecurityContext, but now it’s managed differently

    Configuring authorization rules in reactive apps
         As for any other application, you probably need to configure authorization rules
        when developing reactive apps as well. To teach you how to set authorization rules in
        reactive apps, we’ll discuss first in section 19.3.1 the way you make configurations at
        the endpoint layer. Once we finish discussing authorization configuration at the endpoint layer,
        you’ll learn in section 19.3.2 how to apply it at any other layer of your
        application using method security.

        Why is it called anyExchange(), and why didn’t the developers keep
        the same name for the method anyRequest()? Why authorizeExchange() and why not authorizeRequests()?
        This simply comes from
        the terminology used with reactive apps. We generally refer to communication between two components in a
        reactive fashion as exchanging data. This
        reinforces the image of data being sent as segmented in a continuous stream
        and not as a big bunch in one request.

    Reactive apps and OAuth 2
        Dan: i went fast through this part


========================================================================================================================
Chapter 20. Spring Security testing

    Knowing all
    the functionalities implemented over time by others became impossible. Developers
    This chapter covers needed a way to make sure they didn’t break existing functionalities while correcting
    bugs or implementing new features.

    When testing applications, you need to remember it’s not only your application code
    that you need to test. You need to also make sure you test the integrations with the
    frameworks and libraries you use, as well.
    Sometime in the future, you may upgrade that framework or library to a new version. When changing
    the version of a dependency, you want to make sure your app still integrates well
    with the new version of that dependency. If your app doesn’t integrate in the same
    way, you want to easily find where you need to make changes to correct the integration problems.

    Remember what we discussed right from the
    first chapter: you need to consider security from the first design for the app, and you need to take
    it seriously. Implementing tests for any of your security configurations should be a mandatory task and should
    be defined as part of your definition of “done.” You shouldn’t
    consider a task finished if security tests aren’t ready

    In this chapter, we’ll focus on testing integration between an application and Spring Security

    Using mock users for tests
        When using a mock user, the test completely skips the authentication process (figure 20.3).
        The mock user is valid only for the test execution, and for this user, you can configure any characteristics
        you need to validate a specific scenario. You can, for example, give specific roles to the user
        (ADMIN, MANAGER, and so on) or use different authorities to validate that the app behaves as expected in
        these conditions.
            Dan: see "20-3 mock user meaning.png"

        The test directly uses a mock SecurityContext, which contains the mock user you define to
        call the tested functionality.

!!!!    It’s important to know which components from the framework are
        involved in an integration test. This way, you know which part of the integration you cover with the test.
        For example, a mock user can only be used to cover authorization.

        A convenient way to implement a test for the behavior of an endpoint is by using
        Spring’s MockMvc. In a Spring Boot application, you can autoconfigure the MockMvc
        utility for testing endpoint calls by adding an annotation over the class

        The test calls the endpoint but uses a mock SecurityContext. We
        decide what we add to this SecurityContext

        To test the second scenario, we need a mock user. To validate the behavior of calling
        the /hello endpoint with an authenticated user, we use the @WithMockUser annotation. By adding this
        annotation above the test method, we instruct Spring to set up a
        SecurityContext that contains a UserDetails implementation instance. It’s basically skipping
        authentication. Now, calling the endpoint behaves like the user defined
        with the @WithMockUser annotation successfully authenticated

        The difference between using annotations and the RequestPostProcessor to create the
        test security environment. When using annotations, the framework sets up the test security environment
        first. When using a RequestPostProcessor, the test request is created and then changed to define other
        constraints like the test security environment.

    Testing with users from a UserDetailsService
!!!     This approach is an alternative to creating a mock user. The difference is that, instead of creating a fake
        user, this time we need to get the user from a given UserDetailsService. You use this approach if you
        want to also test integration with the data source from where your app loads the user details

            Dan: see "20-6 testing with real users.png"

        Instead of creating a mock user for the test when building the SecurityContext used by the test,
        we take the user details from a UserDetailsService. This way, you can test authorization using real users
        taken from a data source

    Using custom Authentication objects for testing
        Dan: too detailed for now

    Testing method security
        All the tests we wrote until now in
        this chapter refer to endpoints. But what if your application doesn’t have endpoints?
        In fact, if it’s not a web app, it doesn’t have endpoints at all! But you might have used
        Spring Security with global method security as we discussed in chapters 16 and 17. You
        still need to test your security configurations in such scenarios.

        Fortunately, you do this by using the same approaches we discussed in the previous
        sections. You can still use @WithMockUser, @WithUserDetails, or a custom annotation to define your
        own SecurityContext. But instead of using MockMvc, you
        directly inject from the context the bean defining the method you need to test.

        We don’t configure MockMvc anymore because we don’t need to call an endpoint.
        Instead, we directly inject the NameService instance to call the tested method.

    Testing authentication
        You need to do this if,
        for example, you have custom logic implemented for your authentication, and you
        want to make sure the entire flow works. When testing authentication, the test implementation requests work
        like normal client requests, as presented in figure 20.10

        Dan: see "20-10 testing authentication.png"

        The logic we implement is straightforward. Only one set of credentials is accepted:
        the username "john" and the password "12345". We need to prove that, when using
        valid credentials, the call is successful, whereas when using some other credentials, the
        HTTP response status is 401 Unauthorized

    Testing CSRF configurations
        Fortunately, Spring Security provides an easy approach to test CSRF protection
        using a RequestPostProcessor

        If we don’t use a CSRF token, the HTTP response status is 403 Forbidden.
        If we send a CSRF token, the HTTP response status is 200 OK

    Testing CORS configurations

    Testing reactive Spring Security implementations
        Using the @WithMockUser annotation is straightforward because it works the same as
        for non-reactive apps, as we discussed in section 20.1. The definition of the test is different,
        however, because being a reactive app, we can’t use MockMvc anymore. But
        this change isn’t related to Spring Security. We can use something similar when testing
        reactive apps, a tool named WebTestClient.


========================================================================================================================
Chapter x.


TODO     I also recommend that you
         stay aware of the implemented features in different Spring Security projects using this
         link: https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix